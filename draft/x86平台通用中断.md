# x86平台Linux中断机制

[toc]

## 基础知识

NMI不能被IF禁止，其中断向量号由系统固定分配。

外部中断一般可分为非屏蔽中断和可屏蔽中断。对于非屏蔽中断，cpu直接在对应的中断向量表中取得中断入口地址，执行中断处理程序。而对于可屏蔽中断，一般是用8259A等中断管理器来管理。cpu从中断管理器中得到一个中断请求时，会去检查一下中断允许标志IF，若IF为1则取出中断类型码，从中断向量表中取得中断入口地址，执行中断处理程序。若IF为0，cpu将不响应外部提出的中断请求。

**IRQ** : `Interrupt ReQuest`

**PIC** : `Programmable Interrupt Controller` 可编程中断控制器

向量：每个中断和异常，由0-255之间的数来标识，Intel把这个无符号的整数叫做向量（`vector`）

PIC的作用：

 1. 监视IRQ线，检查产生的信号。

 2. 如果有引发信号出现在IRQ线上：

     a. 把接收到的引发信号转换成对应的向量。
     b. 把这个向量存放在中断控制器的一个I/O端口，从而允许CPU通过数据总线读取此向量。
     c. 把引发信号发送到处理器的`INTR`引脚，即产生一个中断。
     d. 等待，直到CPU通过把这个中断信号写进可编程中断控制器的一个I/O端口来确认，这种情况发生时，清`INTR`线。

 3. 返回第1步。

IRQ线从0开始编号，因此`IRQn`关联的Intel的缺省向量是`n+32`(CPU保留了一部分向量来处理异常)。可以通过向中断控制器端口发布合适的指令，修改IRQ和向量之间的映射，以及有选择的禁止或者激活相应的IRQ，此禁止只是告诉PIC暂时不向CPU发布此IRQ中断，而一旦此IRQ被再次激活，PIC又会发送此IRQ给CPU 。可屏蔽中断的全局屏蔽或者非屏蔽，由CPU的`eflags`寄存器的`IF`标志位决定，`cli`和`sti`指令分别清楚和设置该标志。  

传统的PIC由两片8259A外部芯片级联组成，只能作为单处理器的PIC。在SMP体系结构中，中断需要传递给系统中的每个CPU，为此Intel从Pentiun III开始引入I/O高级可编程控制器（`I/O Advanded Programmable Interrupt Controller, I/O APIC`）用以代替老式的8259A PIC。  

多APIC结构：**`APIC`总线**把“前端”**I/O APIC**连接到**本地APIC**。来自设备的`IRQ`线连接到`I/O APIC`，相对于本地APIC来说，`I/O APIC`起路由作用。  `I/O APIC`中的中断重定向表将每个外部IRQ信号转换为一条消息，然后，通过`APIC`总线发送给一个或多个CPU的本地`APIC`单元。多`APIC`系统还允许`CPU`产生处理器间中断（`interprocessor interrupt`, 简称`IPI`）。 

目前大部分单处理器系统都包含一个I/O APIC芯片，可以用以下两种方式进行配置：

- 作为一种标准的8259A方式的外部PIC连接到CPU。本地APIC被禁止，LINT0和LINT1本地IRQ线分别配置为INTR和NMI引脚。
- 作为一种标准的I/O APIC。本地APIC被激活，且所有的外部中断都通过I/O APIC接收。

### 关于I/O APIC的一些更详细的资料

[PIC 、APIC(IOAPIC LAPIC)](https://blog.csdn.net/jk198310/article/details/9250355)

[1. IO APIC](https://blog.csdn.net/GerryLee93/article/details/106474994/)

---



Linux kernel version : **linux 2.6.30.4**

## 基本数据结构



每个中断向量都有自己的`irq_desc_t`描述符，所有这些描述符组织在一起形成了`irq_desc`数组。

```c
/*include/linux/irq.h*/
/**
 * struct irq_desc - interrupt descriptor
 * @irq:                interrupt number for this descriptor
 * @timer_rand_state:   pointer to timer rand state struct
 * @kstat_irqs:         irq stats per cpu
 * @irq_2_iommu:        iommu with this irq
 * @handle_irq:         highlevel irq-events handler [if NULL, __do_IRQ()]
 * @chip:               low level interrupt hardware access
 * @msi_desc:           MSI descriptor
 * @handler_data:       per-IRQ data for the irq_chip methods
 * @chip_data:          platform-specific per-chip private data for the chip
 *                      methods, to allow shared chip implementations
 * @action:             the irq action chain
 * @status:             status information
 * @depth:              disable-depth, for nested irq_disable() calls
 * @wake_depth:         enable depth, for multiple set_irq_wake() callers
 * @irq_count:          stats field to detect stalled irqs
 * @last_unhandled:     aging timer for unhandled count
 * @irqs_unhandled:     stats field for spurious unhandled interrupts
 * @lock:               locking for SMP
 * @affinity:           IRQ affinity on SMP
 * @cpu:                cpu index useful for balancing
 * @pending_mask:       pending rebalanced interrupts
 * @threads_active:     number of irqaction threads currently running
 * @wait_for_threads:   wait queue for sync_irq to wait for threaded handlers
 * @dir:                /proc/irq/ procfs entry
 * @name:               flow handler name for /proc/interrupts output
 */
struct irq_desc {
        unsigned int            irq;
        struct timer_rand_state *timer_rand_state;
        unsigned int            *kstat_irqs;
#ifdef CONFIG_INTR_REMAP
        struct irq_2_iommu      *irq_2_iommu;
#endif
        irq_flow_handler_t      handle_irq;
        struct irq_chip         *chip;
        struct msi_desc         *msi_desc;
        void                    *handler_data;
        void                    *chip_data;
        struct irqaction        *action;        /* IRQ action list */
        unsigned int            status;         /* IRQ status */

        unsigned int            depth;          /* nested irq disables */
        unsigned int            wake_depth;     /* nested wake enables */
        unsigned int            irq_count;      /* For detecting broken IRQs */
        unsigned long           last_unhandled; /* Aging timer for unhandled count */
        unsigned int            irqs_unhandled;
        spinlock_t              lock;
#ifdef CONFIG_SMP
        cpumask_var_t           affinity;
        unsigned int            cpu;
#ifdef CONFIG_GENERIC_PENDING_IRQ
        cpumask_var_t           pending_mask;
#endif
#endif
        atomic_t                threads_active;
        wait_queue_head_t       wait_for_threads;
#ifdef CONFIG_PROC_FS
        struct proc_dir_entry   *dir;
#endif
        const char              *name;
} ____cacheline_internodealigned_in_smp;

/* include/linux/cache.h */
#if !defined(____cacheline_internodealigned_in_smp)
#if defined(CONFIG_SMP)
#define ____cacheline_internodealigned_in_smp \
        __attribute__((__aligned__(1 << (INTERNODE_CACHE_SHIFT))))
#else
#define ____cacheline_internodealigned_in_smp
#endif
#endif

/*  */
struct irq_desc irq_desc[NR_IRQS] __cacheline_aligned_in_smp = {
        [0 ... NR_IRQS-1] = {
                .status = IRQ_DISABLED,
                .chip = &no_irq_chip,
                .handle_irq = handle_bad_irq,
                .depth = 1,
                .lock = __SPIN_LOCK_UNLOCKED(irq_desc->lock),
        }
};

```



Linux支持多种`PIC`，为了以统一的方式处理所有这样的设备，Linux用了一个`PIC对象`，由`PIC`名字和七个`PIC`标准方法组成。定义`PIC对象`的数据结构叫做`hw_interrupt_type`（也叫作`hw_irq_controller`），后来被`irq_chip`取代，并添加了很多新的底层硬件操作函数。

```c
/*include/linux/irq.h*/
/**
 * struct irq_chip - hardware interrupt chip descriptor
 *
 * @name:               name for /proc/interrupts
 * @startup:            start up the interrupt (defaults to ->enable if NULL)
 * @shutdown:           shut down the interrupt (defaults to ->disable if NULL)
 * @enable:             enable the interrupt (defaults to chip->unmask if NULL)
 * @disable:            disable the interrupt (defaults to chip->mask if NULL)
 * @ack:                start of a new interrupt
 * @mask:               mask an interrupt source
 * @mask_ack:           ack and mask an interrupt source
 * @unmask:             unmask an interrupt source
 * @eoi:                end of interrupt - chip level
 * @end:                end of interrupt - flow level
 * @set_affinity:       set the CPU affinity on SMP machines
 * @retrigger:          resend an IRQ to the CPU
 * @set_type:           set the flow type (IRQ_TYPE_LEVEL/etc.) of an IRQ
 * @set_wake:           enable/disable power-management wake-on of an IRQ
 *
 * @release:            release function solely used by UML
 * @typename:           obsoleted by name, kept as migration helper
 */
struct irq_chip {
        const char      *name;
        unsigned int    (*startup)(unsigned int irq);
        void            (*shutdown)(unsigned int irq);
        void            (*enable)(unsigned int irq);
        void            (*disable)(unsigned int irq);

        void            (*ack)(unsigned int irq);
        void            (*mask)(unsigned int irq);
        void            (*mask_ack)(unsigned int irq);
        void            (*unmask)(unsigned int irq);
        void            (*eoi)(unsigned int irq);

        void            (*end)(unsigned int irq);
        void            (*set_affinity)(unsigned int irq,
                                        const struct cpumask *dest);
        int             (*retrigger)(unsigned int irq);
        int             (*set_type)(unsigned int irq, unsigned int flow_type);
        int             (*set_wake)(unsigned int irq, unsigned int on);

        /* Currently used only by UML, might disappear one day.*/
#ifdef CONFIG_IRQ_RELEASE_METHOD
        void            (*release)(unsigned int irq, void *dev_id);
#endif
        /*
         * For compatibility, ->typename is copied into ->name.
         * Will disappear.
         */
        const char      *typename;
};
```



多个设备能共享一个单独的`IRQ`，因此，内核要维护多个`irqaction`描述符，其中的每个描述符涉及一个特定的硬件设备和一个特定的中断。

```c
/* include/linux/interrupt.h */
/**
 * struct irqaction - per interrupt action descriptor
 * @handler:    interrupt handler function
 * @flags:      flags (see IRQF_* above)
 * @mask:       no comment as it is useless and about to be removed
 * @name:       name of the device
 * @dev_id:     cookie to identify the device
 * @next:       pointer to the next irqaction for shared interrupts
 * @irq:        interrupt number
 * @dir:        pointer to the proc/irq/NN/name entry
 * @thread_fn:  interupt handler function for threaded interrupts
 * @thread:     thread pointer for threaded interrupts
 * @thread_flags:       flags related to @thread
 */
struct irqaction {
        irq_handler_t handler;
        unsigned long flags;
        cpumask_t mask;
        const char *name;
        void *dev_id;
        struct irqaction *next;
        int irq;
        struct proc_dir_entry *dir;
        irq_handler_t thread_fn;
        struct task_struct *thread;
        unsigned long thread_flags;
};
 
```





## 初始化



`init/main.c  :: start_kernel :: init_IRQ`



```c
/*arch/x86/kernel/paravirt.c*/
void init_IRQ(void)
{
        pv_irq_ops.init_IRQ();
}

/*pv_irq_ops的定义在arch/x86/kernel/paravirt.c*/
struct pv_irq_ops pv_irq_ops = {
        .init_IRQ = native_init_IRQ,
        .save_fl = __PV_IS_CALLEE_SAVE(native_save_fl),
        .restore_fl = __PV_IS_CALLEE_SAVE(native_restore_fl),
        .irq_disable = __PV_IS_CALLEE_SAVE(native_irq_disable),
        .irq_enable = __PV_IS_CALLEE_SAVE(native_irq_enable),
        .safe_halt = native_safe_halt,
        .halt = native_halt,
#ifdef CONFIG_X86_64
        .adjust_exception_frame = paravirt_nop,
#endif
};

/* 这里的调用关系搞不清楚是通过paravirt.c中的init_IRQ还是直接调用的irqinit_32.c中的init_IRQ然后再调用的native_init_IRQ, 通过irqinit_32.c中的注释：Overridden in paravirt.c 推断应该是直接调用的irqinit_32.c中的代码*/

/*arch/x86/kernel/irqinit_32.c*/
/* Overridden in paravirt.c */
void init_IRQ(void) __attribute__((weak, alias("native_init_IRQ")));

void __init native_init_IRQ(void)
{
        int i;

        /* Execute any quirks before the call gates are initialised: */
        x86_quirk_pre_intr_init();

        /*
         * Cover the whole vector space, no vector can escape
         * us. (some of these will be overridden and become
         * 'special' SMP interrupts)
         */
        for (i =  FIRST_EXTERNAL_VECTOR; i < NR_VECTORS; i++) {
                /* SYSCALL_VECTOR was reserved in trap_init. */
                if (i != SYSCALL_VECTOR)
                        set_intr_gate(i, interrupt[i-FIRST_EXTERNAL_VECTOR]);
        }
	/*略*/
}
```

> \__attribute__((weak, alias("native_init_IRQ")));
>
> weak 和 alias 分别是GNU扩展的两个属性。
>
> weak 使得所修饰的符号在目标文件中作为 weak symbol 而不是 global symbol。用 nm 命令查看编译生成的目标文件可用看到所修饰的符号是一个 weak symbol，它前面的标记是 W。给函数加上weak属性时，即使函数没定义，函数被调用也可以编译成功。 若两个或两个以上全局符号（函数或变量名）名字一样，而其中之一声明为weak symbol（弱符号），则这些全局符号不会引发重定义错误。链接器会忽略弱符号，去使用普通的全局符号来解析所有对这些符号的引用，但当普通的全局符号不可用时，链接器会使用弱符号。当有函数或变量名可能被用户覆盖时，该函数或变量名可以声明为一个弱符号。
>
> 而 alias 为所修饰的符号定义一个别名，前边代码中init_IRQ是native_init_IRQ的一个别名，所定义的别名和原符号名必须在同一个编译单元中定义，如native_init_IRQ和init_IRQ在同一个.c文件中，否则会编译出错。
>
>  [参考](http://www.techbulo.com/2374.html)

其中`x86_quirk_pre_intr_init`函数定义在`arch/x86/kernel/setup.c`中，主要调用了`init_ISA_irqs`函数完成中断控制器8259A的初始化。

```c
/**
 * x86_quirk_pre_intr_init - initialisation prior to setting up interrupt vectors
 *
 * Description:
 *      Perform any necessary interrupt initialisation prior to setting up
 *      the "ordinary" interrupt call gates.  For legacy reasons, the ISA
 *      interrupts should be initialised here if the machine emulates a PC
 *      in any way.
 **/
void __init x86_quirk_pre_intr_init(void)
{
        if (x86_quirks->arch_pre_intr_init) {
                if (x86_quirks->arch_pre_intr_init())
                        return;
        }
        init_ISA_irqs();
}
/* init_ISA_irqs函数定义在arch/x86/kernel/irqinit_32.c中，主要完成8259A中断控制器的初始化*/

```

之后循环调用`set_intr_gate`函数，完成中断门的初始化。循环中的几个宏定义如下。

```c
/*arch/x86/include/asm/irq_vectors.h*/
/*
 * IDT vectors usable for external interrupt sources start
 * at 0x20:
 */
#define FIRST_EXTERNAL_VECTOR           0x20

#define NR_VECTORS                       256

# define SYSCALL_VECTOR                 0x80

```

即初始化`IDT`从`0x20`开始的256个中断门，并跳过`0x80`。`set_intr_gate`函数定义在`arch/x86/include/asm/desc.h`中，定义如下。

```c
/*
 * This needs to use 'idt_table' rather than 'idt', and
 * thus use the _nonmapped_ version of the IDT, as the
 * Pentium F0 0F bugfix can have resulted in the mapped
 * IDT being write-protected.
 */
static inline void set_intr_gate(unsigned int n, void *addr)
{
        BUG_ON((unsigned)n > 0xFF);
        _set_gate(n, GATE_INTERRUPT, addr, 0, 0, __KERNEL_CS);
}
/*
	其中 GATE_INTERRUPT定义如下
	arch/x86/include/asm/desc_defs.h"
	enum {
        GATE_INTERRUPT = 0xE,
        GATE_TRAP = 0xF,
        GATE_CALL = 0xC,
        GATE_TASK = 0x5,
	};
*/
```

简单总结`native_init_IRQ`函数主要完成两个工作，

- 初始化中断控制器；
- 将`interrupt[]`数组中的中断服务程序地址写进了`IDT`中。



## interrupt[]的定义

[参考](#参考)的第二项：中断之中断向量表IDT的初始化，有对这段代码的注释以及解释。

```assembly
/*arch/x86/kernel/entry_32.S*/
/*
 * Build the entry stubs and pointer table with some assembler magic.
 * We pack 7 stubs into a single 32-byte chunk, which will fit in a
 * single cache line on all modern x86 implementations.
 */
.section .init.rodata,"a"
ENTRY(interrupt)
.text
        .p2align 5
        .p2align CONFIG_X86_L1_CACHE_SHIFT
ENTRY(irq_entries_start)
        RING0_INT_FRAME
vector=FIRST_EXTERNAL_VECTOR
.rept (NR_VECTORS-FIRST_EXTERNAL_VECTOR+6)/7
        .balign 32
  .rept 7
    .if vector < NR_VECTORS
      .if vector <> FIRST_EXTERNAL_VECTOR
        CFI_ADJUST_CFA_OFFSET -4
      .endif
1:      pushl $(~vector+0x80)   /* Note: always in signed byte range */
        CFI_ADJUST_CFA_OFFSET 4
      .if ((vector-FIRST_EXTERNAL_VECTOR)%7) <> 6
        jmp 2f
      .endif
      .previous
        .long 1b
      .text
vector=vector+1
    .endif
  .endr
2:      jmp common_interrupt
.endr
END(irq_entries_start)

.previous
END(interrupt)
.previous

```

>.rept语法
>
>.rept *count*
>Repeat the sequence of lines between the .rept directive and the next .endr directive count times.
>For example, assembling
>**.rept 3
>.long 0
>.endr**
>is equivalent to assembling
>**.long 0
>.long 0
>.long 0**
>
>[参考](https://blog.csdn.net/waverider2012/article/details/8524175)
>
>---
>
>.IF、.ELSE、.ELSEIF 和 .ENDIF 伪指令使得程序员易于对多分支逻辑进行编码。它们让汇编器在后台生成 CMP 和条件跳转指令，这些指令显示在输出列表文件中。语法如下所示：	
>
>.IF conditionl
>  statements
>[.ELSEIF condition2
>  statements ]
>[.ELSE
>  statements ]
>.ENDIF
>
>方括号表示 .ELSEIF 和 .ELSE 是可选的，而 .IF 和 .ENDIF 则是必需的。condition（条件）是布尔表达式，
>
>[参考](http://c.biancheng.net/view/3585.html)

数组中每个元素的初始值是标号1的地址。因此访问数组中的元素时，都会跳到标号1处，执行相应的指令。也就是，在除了0~19号和0x80号中断外，其余的所有中断在进入其自己的中断服务程序之前，必须是先条转执行common_interrupt的.



## common_interrupt



```assembly
/*
 * the CPU automatically disables interrupts when executing an IRQ vector,
 * so IRQ-flags tracing has to follow that:
 */
        .p2align CONFIG_X86_L1_CACHE_SHIFT
common_interrupt:
        addl $-0x80,(%esp)      /* Adjust vector into the [-256,-1] range */
        SAVE_ALL
        TRACE_IRQS_OFF
        movl %esp,%eax
        call do_IRQ
        jmp ret_from_intr
ENDPROC(common_interrupt)
        CFI_ENDPROC

```



## 中断请求队列的初始化

由于硬件的限制，很多外部设备不得不共享中断线，例如，一些PC配置可以把同一条中断线分配给网卡和图形卡。由此看来，让每个中断源都必须占用一条中断线是不现实的。所以，仅仅中断描述符表并不能提供中断产生的所有信息，内核必须对中断线给出进一步的描述。在Linux设计中，专门为每个中断请求IRQ设置了一个队列，这就是我们所说的中断请求队列。





```C
void __init init_ISA_irqs(void)
{
        int i;

#ifdef CONFIG_X86_LOCAL_APIC
        init_bsp_APIC();
#endif
        init_8259A(0);

        /*
         * 16 old-style INTA-cycle interrupts:
         */
        for (i = 0; i < NR_IRQS_LEGACY; i++) {
           /* #define NR_IRQS_LEGACY                    16*/
                struct irq_desc *desc = irq_to_desc(i);

                desc->status = IRQ_DISABLED;
                desc->action = NULL;
                desc->depth = 1;

                set_irq_chip_and_handler_name(i, &i8259A_chip,
                                              handle_level_irq, "XT");
        }
}

```





## <a id="参考">参考</a>

[x86体系结构下Linux-2.6.26的中断处理](http://home.ustc.edu.cn/~hchunhui/linux_intr.html)

[中断之中断向量表IDT的初始化](https://blog.csdn.net/farmwang/article/details/52318573)