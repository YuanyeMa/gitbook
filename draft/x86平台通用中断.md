# x86平台通用中断

[toc]

Linux kernel version : **linux 2.6.30.4**

## 初始化



`init/main.c  :: start_kernel :: init_IRQ`



```c
/*arch/x86/kernel/paravirt.c*/
void init_IRQ(void)
{
        pv_irq_ops.init_IRQ();
}

/*pv_irq_ops的定义在arch/x86/kernel/paravirt.c*/
struct pv_irq_ops pv_irq_ops = {
        .init_IRQ = native_init_IRQ,
        .save_fl = __PV_IS_CALLEE_SAVE(native_save_fl),
        .restore_fl = __PV_IS_CALLEE_SAVE(native_restore_fl),
        .irq_disable = __PV_IS_CALLEE_SAVE(native_irq_disable),
        .irq_enable = __PV_IS_CALLEE_SAVE(native_irq_enable),
        .safe_halt = native_safe_halt,
        .halt = native_halt,
#ifdef CONFIG_X86_64
        .adjust_exception_frame = paravirt_nop,
#endif
};

/* 这里的调用关系搞不清楚是通过paravirt.c中的init_IRQ还是直接调用的irqinit_32.c中的init_IRQ然后再调用的native_init_IRQ, 通过irqinit_32.c中的注释：Overridden in paravirt.c 推断应该是直接调用的irqinit_32.c中的代码*/

/*arch/x86/kernel/irqinit_32.c*/
/* Overridden in paravirt.c */
void init_IRQ(void) __attribute__((weak, alias("native_init_IRQ")));

void __init native_init_IRQ(void)
{
        int i;

        /* Execute any quirks before the call gates are initialised: */
        x86_quirk_pre_intr_init();

        /*
         * Cover the whole vector space, no vector can escape
         * us. (some of these will be overridden and become
         * 'special' SMP interrupts)
         */
        for (i =  FIRST_EXTERNAL_VECTOR; i < NR_VECTORS; i++) {
                /* SYSCALL_VECTOR was reserved in trap_init. */
                if (i != SYSCALL_VECTOR)
                        set_intr_gate(i, interrupt[i-FIRST_EXTERNAL_VECTOR]);
        }
	/*略*/
}
```

> \__attribute__((weak, alias("native_init_IRQ")));
>
> weak 和 alias 分别是GNU扩展的两个属性。
>
> weak 使得所修饰的符号在目标文件中作为 weak symbol 而不是 global symbol。用 nm 命令查看编译生成的目标文件可用看到所修饰的符号是一个 weak symbol，它前面的标记是 W。给函数加上weak属性时，即使函数没定义，函数被调用也可以编译成功。 若两个或两个以上全局符号（函数或变量名）名字一样，而其中之一声明为weak symbol（弱符号），则这些全局符号不会引发重定义错误。链接器会忽略弱符号，去使用普通的全局符号来解析所有对这些符号的引用，但当普通的全局符号不可用时，链接器会使用弱符号。当有函数或变量名可能被用户覆盖时，该函数或变量名可以声明为一个弱符号。
>
> 而 alias 为所修饰的符号定义一个别名，前边代码中init_IRQ是native_init_IRQ的一个别名，所定义的别名和原符号名必须在同一个编译单元中定义，如native_init_IRQ和init_IRQ在同一个.c文件中，否则会编译出错。
>
>  [参考](http://www.techbulo.com/2374.html)

其中`x86_quirk_pre_intr_init`函数定义在`arch/x86/kernel/setup.c`中，主要调用了`init_ISA_irqs`函数完成中断控制器8259A的初始化。

```c
/**
 * x86_quirk_pre_intr_init - initialisation prior to setting up interrupt vectors
 *
 * Description:
 *      Perform any necessary interrupt initialisation prior to setting up
 *      the "ordinary" interrupt call gates.  For legacy reasons, the ISA
 *      interrupts should be initialised here if the machine emulates a PC
 *      in any way.
 **/
void __init x86_quirk_pre_intr_init(void)
{
        if (x86_quirks->arch_pre_intr_init) {
                if (x86_quirks->arch_pre_intr_init())
                        return;
        }
        init_ISA_irqs();
}
/* init_ISA_irqs函数定义在arch/x86/kernel/irqinit_32.c中，主要完成8259A中断控制器的初始化*/

```

之后循环调用`set_intr_gate`函数，完成中断门的初始化。循环中的几个宏定义如下。

```c
/*arch/x86/include/asm/irq_vectors.h*/
/*
 * IDT vectors usable for external interrupt sources start
 * at 0x20:
 */
#define FIRST_EXTERNAL_VECTOR           0x20

#define NR_VECTORS                       256

# define SYSCALL_VECTOR                 0x80

```

即初始化`IDT`从`0x20`开始的256个中断门，并跳过`0x80`。`set_intr_gate`函数定义在`arch/x86/include/asm/desc.h`中，定义如下。

```c
/*
 * This needs to use 'idt_table' rather than 'idt', and
 * thus use the _nonmapped_ version of the IDT, as the
 * Pentium F0 0F bugfix can have resulted in the mapped
 * IDT being write-protected.
 */
static inline void set_intr_gate(unsigned int n, void *addr)
{
        BUG_ON((unsigned)n > 0xFF);
        _set_gate(n, GATE_INTERRUPT, addr, 0, 0, __KERNEL_CS);
}
/*
	其中 GATE_INTERRUPT定义如下
	arch/x86/include/asm/desc_defs.h"
	enum {
        GATE_INTERRUPT = 0xE,
        GATE_TRAP = 0xF,
        GATE_CALL = 0xC,
        GATE_TASK = 0x5,
	};
*/
```

简单总结`native_init_IRQ`函数主要完成两个工作，

- 初始化中断控制器；
- 将`interrupt[]`数组中的中断服务程序地址写进了`IDT`中。



## interrupt[]的定义

[参考](#参考)的第二项：中断之中断向量表IDT的初始化，有对这段代码的注释以及解释。

```assembly
/*arch/x86/kernel/entry_32.S*/
/*
 * Build the entry stubs and pointer table with some assembler magic.
 * We pack 7 stubs into a single 32-byte chunk, which will fit in a
 * single cache line on all modern x86 implementations.
 */
.section .init.rodata,"a"
ENTRY(interrupt)
.text
        .p2align 5
        .p2align CONFIG_X86_L1_CACHE_SHIFT
ENTRY(irq_entries_start)
        RING0_INT_FRAME
vector=FIRST_EXTERNAL_VECTOR
.rept (NR_VECTORS-FIRST_EXTERNAL_VECTOR+6)/7
        .balign 32
  .rept 7
    .if vector < NR_VECTORS
      .if vector <> FIRST_EXTERNAL_VECTOR
        CFI_ADJUST_CFA_OFFSET -4
      .endif
1:      pushl $(~vector+0x80)   /* Note: always in signed byte range */
        CFI_ADJUST_CFA_OFFSET 4
      .if ((vector-FIRST_EXTERNAL_VECTOR)%7) <> 6
        jmp 2f
      .endif
      .previous
        .long 1b
      .text
vector=vector+1
    .endif
  .endr
2:      jmp common_interrupt
.endr
END(irq_entries_start)

.previous
END(interrupt)
.previous

```

>.rept语法
>
>.rept *count*
>Repeat the sequence of lines between the .rept directive and the next .endr directive count times.
>For example, assembling
>**.rept 3
>.long 0
>.endr**
>is equivalent to assembling
>**.long 0
>.long 0
>.long 0**
>
>[参考](https://blog.csdn.net/waverider2012/article/details/8524175)
>
>---
>
>.IF、.ELSE、.ELSEIF 和 .ENDIF 伪指令使得程序员易于对多分支逻辑进行编码。它们让汇编器在后台生成 CMP 和条件跳转指令，这些指令显示在输出列表文件中。语法如下所示：	
>
>.IF conditionl
>  statements
>[.ELSEIF condition2
>  statements ]
>[.ELSE
>  statements ]
>.ENDIF
>
>方括号表示 .ELSEIF 和 .ELSE 是可选的，而 .IF 和 .ENDIF 则是必需的。condition（条件）是布尔表达式，
>
>[参考](http://c.biancheng.net/view/3585.html)

数组中每个元素的初始值是标号1的地址。因此访问数组中的元素时，都会跳到标号1处，执行相应的指令。也就是，在除了0~19号和0x80号中断外，其余的所有中断在进入其自己的中断服务程序之前，必须是先条转执行common_interrupt的.



## common_interrupt



```assembly
/*
 * the CPU automatically disables interrupts when executing an IRQ vector,
 * so IRQ-flags tracing has to follow that:
 */
        .p2align CONFIG_X86_L1_CACHE_SHIFT
common_interrupt:
        addl $-0x80,(%esp)      /* Adjust vector into the [-256,-1] range */
        SAVE_ALL
        TRACE_IRQS_OFF
        movl %esp,%eax
        call do_IRQ
        jmp ret_from_intr
ENDPROC(common_interrupt)
        CFI_ENDPROC

```



## 中断请求队列的初始化

由于硬件的限制，很多外部设备不得不共享中断线，例如，一些PC配置可以把同一条中断线分配给网卡和图形卡。由此看来，让每个中断源都必须占用一条中断线是不现实的。所以，仅仅中断描述符表并不能提供中断产生的所有信息，内核必须对中断线给出进一步的描述。在Linux设计中，专门为每个中断请求IRQ设置了一个队列，这就是我们所说的中断请求队列。





```C
void __init init_ISA_irqs(void)
{
        int i;

#ifdef CONFIG_X86_LOCAL_APIC
        init_bsp_APIC();
#endif
        init_8259A(0);

        /*
         * 16 old-style INTA-cycle interrupts:
         */
        for (i = 0; i < NR_IRQS_LEGACY; i++) {
           /* #define NR_IRQS_LEGACY                    16*/
                struct irq_desc *desc = irq_to_desc(i);

                desc->status = IRQ_DISABLED;
                desc->action = NULL;
                desc->depth = 1;

                set_irq_chip_and_handler_name(i, &i8259A_chip,
                                              handle_level_irq, "XT");
        }
}

```





## <a id="参考">参考</a>

[x86体系结构下Linux-2.6.26的中断处理](http://home.ustc.edu.cn/~hchunhui/linux_intr.html)

[中断之中断向量表IDT的初始化](https://blog.csdn.net/farmwang/article/details/52318573)