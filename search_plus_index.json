{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction This is yuanye's blog. I am focusing on linux kernel and welcome to email me to discuss kernel issues. E-mail : yuanye.ma@qq.com or yuanye.ma20@gmail.com Copyright © Yuanye.Ma 2020-2021 all right reserved，powered by Gitbook文件修订时间： 2023-04-02 10:05:52 "},"_posts/devEnv/2019-05-15-在ubuntu上安装vnc服务.html":{"url":"_posts/devEnv/2019-05-15-在ubuntu上安装vnc服务.html","title":"2019-05-15-在ubuntu上安装vnc服务","keywords":"","body":"在ubuntu上安装vnc服务 故事起因 由于需要运行一些桌面程序，但是又没有多余的地方放置显示器以及鼠标键盘balaba乱七八糟的东西，于是就想在跑代码的机器上开启共享桌面，然后在自己的座位上用写代码的机器远程桌面连接上去。 最初的想法 最初在网上搜索的都是使用系统原生自带的桌面共享实现的。参考 sudo apt install dconf-editor 选择 org->gnome->desktop->remote access->require encrytion 选择OFF 然后重启桌面共享服务：Settings-> Sharing-> Screen Sharing:设置 允许远程连接，设置密码 重启ubuntu后在其他电脑上用vncviewer登录 ip:5900 输入密码 此种方法也能实现远程桌面连接，而且远程桌面和服务器上的桌面环境是同步的，使用的也是原生的GNOME 3环境。 但是。。。。 此种方法有一个弊端，必须要连上屏幕、键盘、鼠标，手动登录系统后，才能在别的地方连接上。直接冷启动是连不上的。 网友)的说法是，vnc和GNOME 3不兼容，Ubuntu系统自带的屏幕共享是Ubuntu自己开发的Vino-Server，必须要先登录，创建一个session后才能从远程连接上去。 果断放弃这种方式。 最终解决方案 参照 安装所需环境 sudo apt update sudo apt install vnc4server sudo apt install --no-install-recommends ubuntu-desktop gnome-panel gnome-settings-daemon metacity nautilus gnome-terminal -y 配置 先用命令vncserver :1使其自动创建配置文件~/.vnc/xstartup， 然后使用命令vncserver -kill :1断开连接。 然后打开配置文件~/.vnc/xstartup在x-window-manger &后边添加下边内容 gnome-session & gnome-panel & gnome-settings-daemon & metacity & nautilus & dbus-launch gnome-terminal & # 这一项是为了解决连接后无法打开terminal的问题 可以在~/.vnc/xxx.log中查看vncserver的运行信息。 我当时先是连接上后无法打开terminal后，查看log显示下边的报错信息。然后参照这篇blog输入了上边那条命令 ： dbus-launch gnome-terminal & Error constructing proxy for org.gnome.Terminal:/org/gnome/Terminal/Factory0: 为 org.gnome.Terminal 调用 StartServiceByName 出错：已到超时限制 完整的xstartup文件内容如下 #!/bin/sh # Uncomment the following two lines for normal desktop: # unset SESSION_MANAGER # exec /etc/X11/xinit/xinitrc [ -x /etc/vnc/xstartup ] && exec /etc/vnc/xstartup [ -r $HOME/.Xresources ] && xrdb $HOME/.Xresources xsetroot -solid grey vncconfig -iconic & x-terminal-emulator -geometry 80x24+10+10 -ls -title \"$VNCDESKTOP Desktop\" & x-window-manager & gnome-session & gnome-panel & gnome-settings-daemon & metacity & nautilus & dbus-launch gnome-terminal & 修改系统的默认启动环境 既然要将机器放到角落里去吃灰，当然要关闭桌面环境了。 Ubuntu 18.04和别的Linux系统不同，修改默认启动环境要使用下边命令 默认以字符界面启动： sudo systemctl set-default multi-user.targe 在字体界面系统桌面环境： sudo systemctl start lightdm 默认以图形界面方式启动： sudo systemctl set-default graphical.target 最终效果 启动训练代码，然后关闭窗口，随时重新连接查看运行结果。美滋滋。。。。 Copyright © Yuanye.Ma 2020-2021 all right reserved，powered by Gitbook文件修订时间： 2023-04-02 10:05:52 "},"_posts/devEnv/2019-07-24-配置jupyter-notebook服务.html":{"url":"_posts/devEnv/2019-07-24-配置jupyter-notebook服务.html","title":"2019-07-24-配置jupyter-notebook服务","keywords":"","body":"配置jupyter-notebook服务 $jupyter notebook --generate-config #生成配置文件 $conda install nb_conda # 设置jupyter Notebook密码的方式 # 先打开python终端 $ python # 然后生成密码 In[1]: from IPython.lib import passwd In[2]: passwd() Enter password: Verify password: Out[2]: 'sha1编码后的密码' # 复制上边编码后的密码，退出python终端 设置服务器配置文件 $vim ~/.jupyter/jupyter_notebook_config.py # 配置文件中有几项内容需要修改。 c.NotebookApp.allow_remote_access = True c.NotebookApp.allow_root = False c.NotebookApp.ip = '*' c.NotebookApp.notebook_dir = '这里填jupyter notebook的工作目录' c.NotebookApp.open_browser = False c.NotebookApp.password = u'这里填上边复制的加密后的密码' c.NotebookApp.port = 8888 c.NotebookApp.terminals_enabled = False 安装完Anaconda利用conda创建的虚拟环境，但是启动jupyter notebook之后却找不到虚拟环境。 实际上是由于在虚拟环境中缺少kernel.json文件，解决方法如下 # 首先安装ipykernel $conda install ipykernel # 然后在虚拟环境中安装ipykernel $conda install -n 环境名称 ipykernel # 激活虚拟环境 $conda activate 环境名称 # 将环境写入notebook的kernel中 $python -m ipykernel install --user --name 环境名字 --display-name \"要显示的环境名字\" # 此外，以后再创建虚拟环境的时候，最好直接装上ipykernel $conda create -n 环境名称 python=版本 ipylernel # 删除kernel环境的命令如下 $jupyter kernelspec remove 环境名称 安装完成后可以通过命令jupyter notebook启动服务，然后在工作的电脑的浏览器中输入ip:port输入密码就可以登录使用了。 Copyright © Yuanye.Ma 2020-2021 all right reserved，powered by Gitbook文件修订时间： 2023-04-02 10:05:52 "},"_posts/devEnv/2019-07-27-BreakWall.html":{"url":"_posts/devEnv/2019-07-27-BreakWall.html","title":"2019 07 27 Break Wall","keywords":"","body":"Docker部署python版本的shadowsocks服务 ubuntu服务端 安装docker 使用shadowsocks的docker镜像启动服务 更新内核启用Google BBR进行加速 # 安装docker apt update apt install docker apt install docker.io # 拉取镜像 docker pull oddrationale/docker-shadowsocks # 启动container docker run -d -p port:port oddrationale/docker-shadowsocks -s 0.0.0 -p port -k passwd -m aes-256-cfb BBR加速 # 下载安装新版本的内核 wget -c http://kernel.ubuntu.com/~kernel-ppa/mainline/v4.11.4/linux-image-4.11.4-041104-generic_4.11.4-041104.201706071003_amd64.deb # 安装新版本内核 dpkg -i ./linux-image-4.11.4-041104-generic_4.11.4-041104.201706071003_amd64.deb # 查看现在使用的内核版本 lsmod | grep bbr uname -r # 更新grub使新版本内核开机自启 update-grub # 卸载多余的软件包 apt autoremove # 重启系统启用新的内核 reboot # 查看是否启用了新版本内核，以及是否支持BBR lsmod | grep bbr uname -r # 开启BBR modprobe tcp_bbr echo \"tcp_bbr\" >> /etc/modules-load.d/modules.conf cat /etc/modules-load.d/modules.conf echo \"net.core.default_qdisc=fq\" >>/etc/sysctl.conf echo \"net.ipv4.tcp_congestion_control=bbr\" >>/etc/sysctl.conf sysctl -p # 查看BBR是否启动 sysctl net.ipv4.tcp_available_congestion_control # net.ipv4.tcp_available_congestion_control = bbr cubic reno sysctl net.ipv4.tcp_congestion_control # net.ipv4.tcp_congestion_control = bbr sysctl net.core.default_qdisc # net.core.default_qdisc = fq uname -r # 4.11.4-041104-generic lsmod | grep bbr # tcp_bbr 20480 156 此外还有一键安装BBR的脚本 https://github.com/google/bbr/blob/master/Documentation/bbr-quick-start.md CentOS 7的服务端 安装docker yum update yum install docker service docker start 设置docker自动启动 chkconfig docker on 使用ncat测试网络是否联通 yum install nmap-ncat -y ncat -l port 在本地使用nc命令连接服务器指定port nc ip port 然后可以随便输入一下内容，看另外一端是否能正常收发数据。 拉取镜像并创建container docker pull oddrationale/docker-shadowsocks docker run -d -p port:port --name name oddrationale/docker-shadowsocks -s 0.0.0.0 -p port -k passwd -m aes-256-cfb 查看是否正常监听端口 netstat -nalp | grep port 设置container随docker自动启动 docker update --restart=always BBR加速 升级内核 rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org rpm -Uvh http://www.elrepo.org/elrepo-release-7.0-2.el7.elrepo.noarch.rpm yum --enablerepo=elrepo-kernel install kernel-ml -y 设置grub2默认使用新内核启动 egrep ^menuentry /etc/grub2.cfg | cut -f 2 -d \\' sudo grub2-set-default 0 reboot 查看是否使用新内核启动 uname -r 开启BBR echo 'net.core.default_qdisc=fq' | sudo tee -a /etc/sysctl.conf echo 'net.ipv4.tcp_congestion_control=bbr' | sudo tee -a /etc/sysctl.conf sysctl -p 查看BBR是否开启 sysctl net.ipv4.tcp_available_congestion_control # 输出应为 net.ipv4.tcp_available_congestion_control = bbr cubic reno sysctl -n net.ipv4.tcp_congestion_control # 输出应为 bbr lsmod | grep bbr # 输出应类似 tcp_bbr 16384 28 客户端 sslocal Linux 安装shadowsocks客户端 # 使用python版的shadowsocks $ sudo apt install python3-pip $ pip install shadowsocks # 使用 $ sudo vim /etc/shadowsocks/config.json # 创建配置文件，并写入以下内容 { \"server\": \"自己shadowsocks服务端ip\", \"server_port\": \"服务端口\", \"local_port\": 1080, \"password\": \"密码\", \"timeout\": 300, \"method\": \"aes-256-cfb\" # 加密方式根据自己需要修改 } $ sslocal -c /etc/shadowsocks/config.json # 启动breakwall 此外还有很多种图形界面版)的。 Proxychains Proxychains是一个可以让终端命令走代理的软件。 # 安装proxychains $ sudo apt install proxychains # 修改配置文件 $ sudo vim /etc/proxychains.conf # 注释掉最后一行的 #socks4 127.0.0.1 9050 # 添加一行 socks5 127.0.0.1 1080 proxychains的使用 $ proxychains wget #后边加一个下载地址 关于非sudo执行proxychains时会有一个错误： ERROR: ld.so: object 'libproxychains.so.3' from LD_PRELOAD cannot be preloaded (cannot open shared object file): ignored. 解决方法为 修改/usr/bin/proxychains 中的export LD_PRELOAD=libproxychains.so.3为export /usr/lib/x86_64-linux-gnu/libproxychains.so.3 修改/usr/lib/proxychains3/proxyresolv 中的export LD_PRELOAD=libproxychains.so.3为/usr/lib/x86_64-linux-gnu/libproxychains.so.3 其中/usr/lib/x86_64-linux-gnu/libproxychains.so.3可以通过命令sudo find /usr/ -name \"libproxychains.so.3\"找到。 安装simple_obfs混淆插件 simple_obfs是一个混淆插件，是把经过shadowsocks封装socks5协议后的数据包，再封装成正常的http/tls数据包的一个插件。 shadowsocks-libev是另一个实现socks5代理的软件本质上和前边用的python版本的ssserver/sslocal没什么区别。但是基于libev实现的功能更加强大，不同版本的区别在这里。最明显的就是shadowsocks-libev同时包含客户端和服务端即ss-local/ss-server，而且都可以安装插件。 Ubuntu sudo apt update sudo apt install shadowsocks-libev CentOS 7 yum install git # 下载shadowsocks-libev的源代码 git clone https://github.com/shadowsocks/shadowsocks-libev.git cd shadowsocks-libev/ git submodule update --init # 安装依赖 yum install gcc gettext autoconf libtool automake make pcre-devel asciidoc xmlto c-ares-devel libev-devel libsodium-devel mbedtls-devel -y # 编译安装 ./autogen.sh && ./configure && make && make installl simple_obfs # 安装依赖 sudo yum install gcc autoconf libtool automake make zlib-devel openssl-devel asciidoc xmlto libev-devel ## Ubuntu 安装依赖： sudo apt-get install --no-install-recommends build-essential autoconf libtool libssl-dev libpcre3-dev libev-dev asciidoc xmlto automake # 下载源代码 git clone https://github.com/shadowsocks/simple-obfs.git cd simple-obfs/ git submodule update --init --recursive # 编译安装 ./autogen.sh ./configure && make && make install 启动配置 服务端：ss-server -c /etc/shadowsocks-libev/config.json 客户端： ss-local -c /etc/shadowsocks-libev/config.json 创建配置文件 # 创建配置文件 mkdir /etc/shadowsocks-libev vim /etc/shadowsocks-libev/config.json # 服务端写入以下内容 { \"server\":\"0.0.0.0\", \"server_port\":8388, \"local_port\":1080, \"password\":\"passwd\", \"user\":\"nobody\", \"timeout\":600, \"method\":\"chacha20-ietf-poly1305\", \"fast_open\": false, \"nameserver\":\"8.8.8.8\", \"mode\":\"tcp_and_udp\", \"plugin\":\"obfs-server\", \"plugin_opts\":\"obfs=http\" } # 客户端写入以下内容 { \"server\":\"server_ip\", \"server_port\":8388, \"local_port\":1080, \"password\":\"passwd\", \"timeout\":60, \"method\":\"chacha20-ietf-poly1305\", \"plugin\":\"obfs-local\", \"plugin_opts\":\"obfs=http;obfs-host=www.bing.com\" } 设置systemctl托管shadowsocks-libev sudo vim /etc/systemd/system/shadowsocks-libev.service # 写入以下内容 [Unit] Description=Shadowsocks-libev Server Documentation=https://shadowsocks.org/en/ After=network.target [Service] Type=simple ExecStart=/usr/local/bin/ss-server -c /etc/shadowsocks-libev/config.json -u Restart=on-abort [Install] WantedBy=multi-user.target 启动服务： sudo systemctl start shadowsocks-libev 开机自启动： sudo systemctl enable shadowsocks-libev VirtualBox部署LEDE旁路由 安装VirtualBox 下载koolshare-lede固件，安装LEDE虚拟机，设置网络桥接到物理网卡。 下载科学上网插件 登录LEDE后台，添加节点信息 将上网机器的网关和DNS都设置为LEDE的ip地址，LEDE的网关设置为主路由的IP。 设置开机自动启动LEDE虚拟机(以下方法无效，新版本应该利用autostart-enabled参数，具体设置方法应该参照这个或这个) # 查看虚拟机列表 VBoxManage list vms # 启动LEDE VBoxManage startvm LEDE -type headless # headless是无图形界面的模式，gui为有图形界面的模式 # 关闭LEDE虚拟机 VBoxManage controlvm LEDE poweroff # --------- 修改ubuntu的启动项目 sudo vim /etc/rc.local # 写入 #!/bin/bash VBoxVRDP startvm LEDE -type headless # 修改 rc.lodal的权限 chmod 755 /etc/rc.local # 创建启动项 sudo ln -fs /lib/systemd/system/rc-local.service /etc/systemd/system/rc-local.service # Ubuntu 18.04默认没有启动rc.local的服务，需要手动开启，参考https://blog.csdn.net/github_38336924/article/details/98183253 sudo vim /etc/systemd/system/rc-local.service # 写入 [Install] WantedBy=multi-user.target Alias=rc-local.service 最后，服务器启动的时候会在network那里卡5min之久 sudo vim /etc/systemd/system/network-online.target.wants/networking.service # 将里面的TimeoutStartSec=5min 修改为TimeoutStartSec=30sec Copyright © Yuanye.Ma 2020-2021 all right reserved，powered by Gitbook文件修订时间： 2023-04-02 10:05:52 "},"_posts/devEnv/2019-11-05-记一次NVIDIA-Driver-cuda升级.html":{"url":"_posts/devEnv/2019-11-05-记一次NVIDIA-Driver-cuda升级.html","title":"2019-11-05-记一次NVIDIA-Driver-cuda升级","keywords":"","body":"记一次NVIDIA driver/cuda/cudnn升级 系统环境：Ubuntu 18.04 / NVIDIA_Driver version:390 / cuda 9.0 / cudnn 7.1 目标： 升级NVIDIA_Driver version :410.104 /cuda 10.0 / cudnn 7.6 NVIDIA Driver 首先关闭桌面系统 $ sudo init 3 # 表示以字符界面启动 然后屏幕黑了，左上角有个光标在闪烁，没有出来login的提示符，这是因为当前窗口是init 5即图形界面终端。同时按键盘Ctrl+Alt+F1三个按键，进入一个其他终端，然后会出现login提示符，输入用户名密码登陆。 因为后续很多操作需要root权限，所以可以直接以root身份登陆，或者以普通用户身份登陆后用sudo -i切换为root身份。 由于我之前安装的390驱动需要gcc-5支持，但是410驱动需要gcc-7，因此需要切换会gcc-7. # update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-7 70 # update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-7 70 如果不知道当前gcc是什么版本，可以使用gcc -v命令查看 update-alternatives 是Debian系系统中用于管理不同软件版本的工具。本质上是通过修改软链接的指向来确定使用哪个版本的命令。 基本用法如下： ​ update-alternatives --display # 显示组的情况 ​ update-alternatives --remove # 从组中删除 ​ update-alternatives --remove-all # 删除整个组 ​ update-alternatives --install # 向组中添加一个路径 ​ update-alternatives --config # 选择一个当前使用的路径 其中是软连接的位置，对应上边命令中的/usr/bin/gcc； 命令组的名字，可以随便写，对应上边命令中的gcc； 是确切要执行的命令的路径，对应上边命令中的 /usr/bin/gcc-7 ；最后的70是优先级。 因此上边命令的意思就是创建一个软连接/usr/bin/gcc指向/usr/bin/gcc-7。当执行gcc时调用的是/usr/bin/gcc-7,也就是7.4版本的gcc. 先卸载NVIDIA-390，然后安装NVIDIA-410. # apt purge nvidia* 进入到驱动安装脚本保存的位置执行安装命令 # ./NVIDIA-Linux-x86_64-410.104.run 根据提示下一步就好，其中有一步问是否开启Xorg支持，要选“是”，不然的话，安装完驱动，返回桌面的时候会失败。 安装完成后通过init 5命令启动桌面环境。进入桌面环境后可以通过nvidia-smi命令查看驱动安装是否正确。 CUDA 9.0 升级CUDA 10.0 $sudo cuda_10.0.130_410.48_linux.run 接受用户协议，不安装驱动，安装路径默认，安装samples，完成。 设置动态连接库的路径 $ sudo vim /etc/ld.so.conf.d/cuda-10.conf 写入 /usr/local/cuda-10.0/lib64 $ sudo ldconfig cuda-9.0不用卸载 /usr/local/cuda也是一个软连接安装cuda 10.0的时候已经自动修改指向了cuda-10.0. 安装cudnn $ sudo dpkg -i libcudnn7_7.6.4.38-1+cuda10.0_amd64.deb $ sudo dpkg -i libcudnn7-dev_7.6.4.38-1+cuda10.0_amd64.deb $ sudo dpkg -i libcudnn7-doc_7.6.4.38-1+cuda10.0_amd64.deb 测试 import tensorflow as tf tf.test.gpu_device_name() Copyright © Yuanye.Ma 2020-2021 all right reserved，powered by Gitbook文件修订时间： 2023-04-02 10:05:52 "},"_posts/devEnv/2020-03-08-omv.html":{"url":"_posts/devEnv/2020-03-08-omv.html","title":"2020 03 08 Omv","keywords":"","body":"OpenMediaVault+Nextcloud搭建私有云盘 安装omv 下载镜像 macOS制作启动盘 diskutil list #确定是disk3 diskutil unmountDisk /dev/disk3 # 将镜像写入U盘 dd if=openmediavault.iso of=/dev/disk3 然后将U盘插入主机并调整开机引导选项，安装过程的提示都很显而易见。 安装完成后终端会显示IP地址，直接在浏览器中输入相应的IP就可以打开管理页面。默认用户名和密码在终端中也有显示。 默认用户名 admin 默认密码 openmediavault 安装插件 # 安装Omg-extras wget http://omv-extras.org/openmediavault-omvextrasorg_latest_all5.deb 按照以下步骤安装：插件->上传-〉弹出选择文件框选，选中文件并上传->选中openmediavault-omvextrasorg（点击方框打勾）->安装 安装docker 点击侧边栏OMV-Extras -> docker-〉安装 镜像加速 ssh root@ip vim /etc/systemd/system/multi-user.target.wants/docker.service # ------ ExecStart=/usr/bin/dockerd --registry-mirror=https://docker.mirrors.ustc.edu.cn -H fd:// # http://hub-mirror.c.163.com/ # ------ systemctl daemon-reload 或者 service docker restart 或者reboot 安装硬盘 创建文件系统 挂载文件系统 启用SMB/CIFS 添加共享 使用Docker安装nextcloud 参考这篇文档不过我先拉取了一个portainer镜像，然后基于此通过图形界面安装nextcloud和mariadb 数据库 mariadb没有配置成功，直接使用了sqlite 遇到的问题 nextcloud通过不被信任的域名访问 vim path_to_nextcloud_html/config/config.php 'trusted_domains' => array ( 0 => '192.168.1.140:8888', 1 => '域名', ), OMV启用rc-local 起因是因为OMV设置的静态IP无效，每次开机都需要进入终端使用dhclient命令去获取IP，实在没办法了，就像写一个开机启动脚本在每次开机的时候去执行dhclient命令。 Debian 10默认禁用了rc-local可以通过systemctl status rc-local查看。 vim /etc/rc.local # --- 写入以下内容 #!/bin/bash /usr/sbin/dhclient echo \"hello\" > /root/log # 这行是为了重启后检查配置是否生效用的，配置好后可以删掉这一行。 exit 0 # --- end chmod 755 /etc/rc.local systemctl start rc-local nextcloud 文件锁定 nextcloud的data目录还可以通过smb访问，所以从nextcloud上传了一个文件，又在smb中把上传的文件给删除了。然后造成nextcloud中显示有所上传的文件，删除的时候报错，重复上传的时候显示\"文件被锁定了\"，删也删不掉。 google了一下，都说先开启“维护模式”(maintenance:mode),然后进数据库删掉“锁定标记”，最后再关闭“维护模式“。但是实际部署时候的一些细节不一样，所以具体操作也不一样。 # 首先登陆`portainer`， # 找到nextcloud的contianer点击`Exec Console` # `User`处填入`www-data`点击`Connect` # 进入nextcloud的data所在目录 cd nextcloud/data/ # 查看以下php可执行程序的路径 which php # /usr/local/bin/php 是我机器的响应 /usr/local/bin/php ./occ files:scan --all /usr/local/bin/php ./occ files:cleanup # 打开“维护模式” /usr/local/bin/php ./occ maintenance:mode --on # 然后ssh到omv上 apt update apt install sqlite3 cd /srv/xxxx/nextcloud/data sqlite3 nextcloud.db # 在数据中执行 delete from oc_file_locks where 1 .exit # 退出数据库 # 关闭“维护模式” # 还回到'portainer'的nextcloud container的console执行下边命令 /usr/local/bin/php ./occ maintenance:mode --off # 最后重启一下nextcloud的container Copyright © Yuanye.Ma 2020-2021 all right reserved，powered by Gitbook文件修订时间： 2023-04-02 10:05:52 "},"_posts/devEnv/2020-03-29-noVnc.html":{"url":"_posts/devEnv/2020-03-29-noVnc.html","title":"2020 03 29 No Vnc","keywords":"","body":"noVNC+frp访问学校的服务器桌面 1. 阿里云开一个实例 开一个实例 配置安全组 ​ 7000 -> frp内网穿透服务端口 ​ 8806 -> noVnc的访问端口 创建好实例，设置好安全组后测试一下端口是否能正常访问。 #在vps上 nc -l 7000 #在本地 nc vps_ip 7000 然后两边随便输入一些内容看另一端是否能正常受到，如果能，则说明实例安全组配置成功，本地到服务器的链路是畅通的。 2. 配置frp内网穿透 release下载链接 tar -zxvf frp_0.32.0_linux_amd64.tar.gz #解压 cd ./frp_0.32.0_linux_amd64 ls # LICENSE frpc frpc.ini frpc_full.ini frps frps.ini frps_full.ini systemd # 其中 # frpc 客户端程序 # frpc.ini 客户端程序的配置文件 # frps 服务端程序 # frps.ini 服务端程序配置文件 # 在vps上执行以下操作 vim ./frps.ini # 写入以下内容 [common] bind_port = 7000 vhost_http_port = 8806 # 后台执行 nohup ./frps -c ./frps.ini& # 在内网的机器上执行以下操作 vim ./frpc.ini # 写入以下内容 [common] server_addr = vps_ip server_port = 7000 [web] type = http local_port = 6080 # noVnc默认的代理端口 custom_domains = vps_ip/domain_name # 有域名的话可以直接写域名，我没域名就直接写vps的公网Ip了 # 后台执行 nohup ./frpc -c ./frpc.ini 3. 配置vncserver 部分参考这个链接 因为我之前安装过vncserver所以直接安装桌面环境 # 以下操作均在内网的服务器上执行 sudo apt update sudo apt install xfce4 xfce4-goodies mv ~/.vnc/xstartup ~/.vnc/xstartup.bak vim ~/.vnc/xstartup # 写入以下内容 #!/bin/bash xrdb $HOME/.Xresources startxfce4 & # 赋予执行权限 sudo chmod +x ~/.vnc/xstartup # 启动vncserver vncserver :2 # 关闭vncserver的操作 vncserver -kill :2 可以手动设置vnc桌面的分辨率 ：vncserver -geometry 1280x1024 :2 4. 配置noVnc 这里下载源码 # 解压 tar -zxvf ./v1.1.0.tar.gz cd noVNC-1.1.0/ ./utils/launch.sh -h #查看帮助 ./utils/launch.sh --vnc 127.0.0.1:5902 #启动noVnc第一次启动会去github拉取web相关内容 # 之后也可以后台运行 nohup ./utils/launch.sh --vnc 127.0.0.1:5902 & 5. 测试 在本地打开浏览器，地址栏输入http://vps_ip:8806/vnc.html点击链接，输入前边配置vncserver时设置的密码。刚进入桌面的时候会让选择面板，我点了默认。 6. bug 刚进入桌面发现点Terminal模拟器没有相应，参照这篇文章设置后就可以用了。 Copyright © Yuanye.Ma 2020-2021 all right reserved，powered by Gitbook文件修订时间： 2023-04-02 10:05:52 "},"_posts/devEnv/BreakWall-3-Trojan.html":{"url":"_posts/devEnv/BreakWall-3-Trojan.html","title":"Break Wall 3 Trojan","keywords":"","body":"Trojan的主页：https://trojan-gfw.github.io/trojan/ 步骤一： 购买、部署VPS 推荐使用Vultr, 因为“便宜”。 我安装的是“CentOS 8” ，自带了BBR，因此不用再手动设置。 步骤二：申请域名，设置DNS解析，申请证书 我使用的是腾讯云的域名和免费的证书。 步骤三：部署并配置Nginx yum install nginx nginx -h # 查看nginx的命令帮助 nginx # 启动nginx nginx -t # 检查配置文件是否有效 nginx -s stop # 关闭nginx nginx -s reload # 重新加载配置文件 nginx默认的配置文件在/etc/nginx/nginx.conf 设置防火墙 firewall-cmd --permanent --add-port=80/tcp firewall-cmd --permanent --add-port=443/tcp firewall-cmd --list-port 80/tcp 443/tcp # 配置生效 步骤四：部署并配置Trojan sudo bash -c \"$(curl -fsSL https://raw.githubusercontent.com/trojan-gfw/trojan-quickstart/master/trojan-quickstart.sh)\" 或者 sudo bash -c \"$(wget -O- https://raw.githubusercontent.com/trojan-gfw/trojan-quickstart/master/trojan-quickstart.sh)\" 安装完成后配置文件路径： /usr/local/etc/trojan/config.json # 配置文件中需要修改的地方 \"password\": [ \"trojan的连接密码\" ], # 以及 \"ssl\": { \"cert\": \"证书crt文件的路径\", \"key\": \"证书key文件的路径\", \"key_password\": \"证书的密码\", } 启动：systemctl start trojan 重启：systemctl restart trojan 查看状态：systemctl status trojan 关闭：systemctl stop trojan 开机自启：systemctl enable trojan 步骤五 : 客户端设置 windows端客户端 使用的是V2rayN V3.27， 服务器 -> 添加[Trojan]服务器 -> 服务器地址：VPS的IP地址 服务器端口 ： 443 密码 ： 步骤四中配置的“trojan的连接密码” 域名(SNI) : 填写证书的域名 ubuntu 参考 https://xbsj6147.xyz/pagesv2/download-linux.html 官网参数介绍 下载页面 tar xvf trojan-1.16.0-linux-amd64.tar.xz cd trojan vim config.json 配置内容如下 { \"run_type\": \"client\", \"local_addr\": \"0.0.0.0\", \"local_port\": 1080, \"remote_addr\": \"服务器地址\", \"remote_port\": 443, \"password\": [ \"trojan连接密码\" ], \"log_level\": 1, \"ssl\": { \"verify\": false, \"verify_hostname\" : false, \"cert\": \"\", \"cipher\": \"ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384\", \"cipher_tls13\": \"TLS_AES_128_GCM_SHA256:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_256_GCM_SHA384\", \"sni\":\"\", \"alpn\": [ \"h2\", \"http/1.1\" ], \"reuse_session\": true, \"session_ticket\": false, \"session_timeout\": 600, \"curves\": \"\" }, \"tcp\": { \"prefer_ipv4\": false, \"no_delay\": true, \"keep_alive\": true, \"reuse_port\": false, \"fast_open\": false, \"fast_open_qlen\": 20 }, \"mysql\": { \"enabled\": false, \"server_addr\": \"127.0.0.1\", \"server_port\": 3306, \"database\": \"trojan\", \"username\": \"trojan\", \"password\": \"\", \"key\": \"\", \"cert\": \"\", \"ca\": \"\" } } 配置systemctl管理 cat > /etc/systemd/system/trojan.service 设置开机自启动sudo systemctl enable trojan Copyright © Yuanye.Ma 2020-2021 all right reserved，powered by Gitbook文件修订时间： 2023-04-02 10:05:52 "},"_posts/devEnv/gitbook.html":{"url":"_posts/devEnv/gitbook.html","title":"Gitbook","keywords":"","body":"使用gitbook记笔记 $ sudo apt update $ sudo apt install nodejs npm $ nodejs --version v10.19.0 $ npm config set registry http://registry.npm.taobao.org/ # 设置npm源为淘宝的源 # 设置回官方的源 npm config set registry http://registry.npmjs.org/ $ sudo npm install gitbook-cli -g 常用命令 git clone blog cd blog gitbook install ./ cd ../ gitbook build /root/blog /var/www/html/_book Copyright © Yuanye.Ma 2020-2021 all right reserved，powered by Gitbook文件修订时间： 2023-04-02 10:05:52 "},"_posts/diary/2017-01-14-回顾2016年.html":{"url":"_posts/diary/2017-01-14-回顾2016年.html","title":"2017-01-14-回顾2016年","keywords":"","body":"回顾2016年 2017/01/14 星期六 小雨（深圳） 一转眼2016也过去了，回首这一年，感觉大回顾2016年脑一片空白。 其实这一年也经历了很多事情，只是一时竟不知道该从何说起，翻看qq空间2015年的最后一天12月31日发的说说，是对2015年的总结--误落尘网中，一去三十年，那是因为感觉2015年一直在为一些没有意义的事情奔忙。现在回首2016，虽然没有感到自己在瞎忙，也做了一些正事，但是却感觉记忆空空荡荡，仿佛做了一场令人疲惫的梦。 不记得这梦是从什么时候开始的了，2015年8月16号，前女友生日的第二天，也是开学的第二天，我们理智的结束了两年的关系，随之结束的也是我对那个地方最后的一点眷恋。之后的半年我不知道自己是怎么度过的了，上课、下课、做比赛、处理各种烦人的事情，冷静下来回想自己的大学生活，开始冷眼看待身边的浮云。 2016年12月x号到2月2号，在哈尔滨甲骨文基地，写代码、写代码、写代码，每天就是听课，写代码，中间休息的话还和其他九个室友买点菜做一顿饭。 2016年2月2号到2月25号，在家过了一个寒假，小姑带小妹回来，小妹都已经长成一米六的大姑娘了（虽然她才十一岁），记得上次她回来还是六岁的时候，那时候我还不到十六岁，那时候还刚刚到城市上高中。不过她活泼好动的性格倒是一点没变。陪着他们玩了一个寒假，也拍了我们全家的第一张全家福。2月25号晚准备行李返回哈尔滨，看着妈妈跑过来跑过去往我行李箱里塞东西，第一次发现她其实不高，也不知道确实是我长大了，还是她渐渐老了？ 翻看相册的时候看到小时候照相的时候她教我拿枪被爸爸抓拍到，照片上她没有皱纹，我才突然发现，自己竟然记不起来是什么时候皱纹悄悄的爬到了她的头上，我竟然没有注意过她也曾经年轻过。 出发吧，不要问那路在哪。迎风向前，是唯一的方法。 -- 《亡命之徒》 2016年6月23号，2016届毕业典礼在科技广场冒雨召开。我们在主楼上做实验，看着他们即将离开学校奔赴社会的各个角落，一种无形的压力在心头升起，不久我们也将奔向全国各地，开始尝试在社会上摸爬滚打的滋味。 2016年7月15号，这次放暑假，我难得早早的回家，因为休息不了几天就要南下了。 2016年7月18号，带上行李箱，坐上南下深圳的火车，奔向曾无数次想象的远方。 之后的两周一直在跑招聘，网上投简历，打电话的话就拿着简历过去面试，晚上回来回想一下面试内容，整理到笔记里。 跑的时候心态也在不断变化，本以为自身能力不错，应该能拿一个差不多的薪资，可往往事与愿违，对待实习生公司的态度还是很慎重的，而且想找合适的工作也确实不容易，需要各方面的巧合。看着日子一天天过去，内心真是无比焦急，要求一再调整。终于在7月27号报道。 2016年8月23号，在室友的一再催促下，我查了一下四级成绩，竟然过了。也不枉我天天敲代码，得空就看考虫。 Copyright © Yuanye.Ma 2020-2021 all right reserved，powered by Gitbook文件修订时间： 2023-04-02 10:05:52 "},"_posts/diary/2019-01-04-2017考研年.html":{"url":"_posts/diary/2019-01-04-2017考研年.html","title":"2019-01-04-2017考研年","keywords":"","body":"2019/01/04 星期五 晴 ps: 挺冷的（大连） 今天下午懒着什么也不想干，就把好早以前烂尾的工程捡了起来--在github搭建博客,终于今天付诸行动了。在整理文档的时后发现了2017年1月初的一篇日记。重读了之后感慨时间过的真快啊，又一年过去了，不对，是两年。 早就想写一些东西，一直拖着，考研开始的时候想写一下当时下决心的心情，拖着没写，然后又想考研结束吧，结束了记录一下考研一年的心得，考完后感觉心态一下子放松了，又被搁置了。今天重读了2017年的日记，反而万般思绪涌上心头想再写点什么了，那就趁着这股热乎劲赶紧动手吧。 先简单回顾一下17年吧 决定 如果要我给17年的生活贴一个标签的话，我觉得用“奔波”两个字比较合适吧。17年过年的时候和妈妈谈了之后就下定决心要考研了，过完年回深圳后开始有一搭没一搭的复习：白天上班，晚上不加班了，到5点半就坐地铁回去了，路上吃个饭就回去看数学了。后来买了考虫的考研网络课，把单词音频放在手机里，上下班路上听，我现在还记得傍晚的时候我从公司出来，穿过南山区的几个产学研基地，也没什么人，我听着vivian的‘proposal，建议，求婚’，脚步匆匆。 辞职 五一搬完家后我没回家，哥哥回家订婚了，我给公司的解释是五月中旬要回哈尔滨毕业了，到时候要请很久的假，五一期间我多加班吧。其实也是为了五月份的工资。五月中旬正式辞职，和公司说要回去考研，毕业后不打算回深圳了，leader和老板虽然想挽留，无奈我已经考虑清楚，并且决定了。其实这件事情办的挺不好的，我提出辞职到离开公司一共不到半个月时间，算是很突然的离职了，再加上老板介绍我考他深圳先进技术研究所或者哈工大深研院的师弟的研究生，并且让我再工作到十月把项目完结或者好好交接了，我都没有接受。总之，算是给公司带来的损失吧。 毕业旅行 5月中旬辞职后，我并没有直接回哈尔滨，约了瑞琪和志权打算边走边玩回去。一则路途遥远，直接回去也难受；二则我整个大学也没好好出去玩过，毕业后学生证优惠也要过期了。先去了黄山，在黄山景区徒步一天走了应该有三四十公里吧，也没完全逛完，西海大峡谷只逛了一环。虽然累的浑身疼，说实话挺尽兴的，“五岳归来不看山，黄山归来不看岳” 名不虚传。以后有机会一定带爸妈去看看。黄山逛完去了青岛，从小到大没有见过海，在深圳也没去过大小梅沙，没见过沙滩。在青岛吃了肥美的生蚝，然后绕着海岸线逛了海军博物馆、第一、第二海滨浴场、八大关没进去只走了沿海部分。看了军舰、海礁、在沙滩上踩了从没见过的细沙。拍了很多照片，拍到相机都没电了。不过青岛的太阳是真的厉害，走了一天脸晒成了四种颜色，回哈尔滨后开始蜕皮。然后到烟台坐船出海到大连，到大连的时候真的玩不动了，休息了一天然后就回哈尔滨了。 毕业 在路上玩了五天，到哈尔滨的时候已经比学校规定时间晚了三天，然后就是上午去主楼写论文，下午回宿舍和室友一起打游戏。因为早有准备，所以毕业设计做的一直不紧不慢。毕业设计结束就是最后的狂欢了，各种聚餐 ，拍毕业照。6月13日哥哥结婚的时候我正准备毕业答辩，没能参加，实属一大遗憾，特别是回家后看婚礼录像，拍全家福的时候我不在，心里更是难受。我在毕业答辩结束的第一时间定了回家的票，6月23日的毕业典礼也没有参加。6月17日到家，刚两天吧，具体记不清了，哥哥带着嫂子就南下深圳了。我在家待到7月9日，又乘车北上，回学校复习准备考研。 在哈尔滨复习的日子 在哈尔滨复习考研的日子，虽然紧凑，现在想想还是挺充实的。大学四年没怎么去过图书馆，毕业了又回学校天天泡图书馆了，真的印证了那句话：“出来混的，早晚要还的”，我这也算是还我大学时没泡图书馆的债了。温宇飞、吴越一熊、余术强我们四个在学校小区租了房子，每天早上七点多起床，轮流洗漱，去餐厅吃饭，差不多八点到图书馆吧。虽然经常有人懒的不想起，但是彼此相互拿“再不起考不上了”威胁，彼此“鼓励”，也不可谓不有趣。傍晚去田径场跑一跑，周六去篮球场打打篮球。虽然我之前从未真的打过球，但是运动运动，出出汗，舒舒服服洗个澡，感觉心情都变好不少。时间过得很快，十月份要报考了，一熊从七月份就已经决定了要考北京交通大学；温宇飞复习状态很不错，但是还是不敢报我俩都想去的哈尔滨工业大学，最后打算冲一冲有“计算机界黄埔军校”之称的“北京邮电大学”；我当时的复习状态并不是很好，最后温宇飞帮着我从前往后捋了一遍国内高校计算机排名，最后决定报考“大连理工大学”；余术强打算报考北京工业大学，并留在哈尔滨参加考试。 寄居西安 十一月我和温宇飞考虑到考期将至，不想反复在路上折腾，最后打算回家现场确认后一起去西安，投奔已经考到西安交通大学的郭翔宇。真的很感谢翔宇，帮我们找了住处，并且两个多月在西交的吃饭学习给翔宇也添了不少麻烦。西交校园出入要刷卡，进图书馆要刷卡，吃饭要刷卡。我们又租不到卡，只能和翔宇共用一张卡。没地方学习只能死皮赖脸的待在翔宇他们实验室。最后一个月的时候要背政治了，我们只好顶着寒风，在西交图书馆后边小花园的草坪旁边背（那边没什么人）。大飞说其实咱们现场确认完后还是应该回哈尔滨去，我虽然嘴上不说什么，但是心里边深表赞同。 回家考试 12月21日回家考研，巧的是22日去平顶山实验高中的路上得知连英豪和我一个考点。刚好在官庄接上他一起去了平顶山。到平顶山看了考点和宾馆，徒步测了一下宾馆到考点的时间，虽然有点远，但是还算僻静。于是就把哥哥订的大床房换成了标准间，俩人住下。考试期间，我心态并不是很好，英语小作文，题目的词不认识，很简单的单词也写错，考数学的时候，急的满头大汗，双手也全是汗，期间英豪也一直在给我打气，宽慰我。 等成绩的日子 后来元旦过后，和大飞又回西安准备复试。这个时候其实已经学不进去了，原本打算复习到过年再回家的，不到半个月，我俩就都想回去了。最后也只是把复试资料简单看了一遍，就灰溜溜的回家了。 之后过年期间，成绩还没出来，真的是坐卧不安。爸爸妈妈也知道我没心思，也什么都不让我干，也不催我。过年走亲戚见朋友绝口不提考研的事情。这里要说一下我的几个发小，当时心里真的是没把握，也烦的不行，所以问我的时候我只能含糊其辞。还记的妈妈在洗衣服，我蹲在旁边和她聊天的情景，我说要是考不上就还出去挣钱算了。妈妈一边洗衣服一遍和我说先不想那么多，等成绩出来再说，现在先准备着复试，考不上再说考不上的事，不行咱再来一年，不着急挣钱。很多次类似的对话，妈妈给了很多宽慰。 出成绩啦 具体日期记不清了，我在房顶看书，与其说是在看书，还不如说在晒太阳，因为真的是看不进去。妈妈在院子里忙活。我喊了一声“妈”，“咋了？”，“成绩出来了”，老妈超级冷静的说“下来说”。一直以为考完不出成绩很煎熬，殊不知，知道成绩了，不知道能不能上，更加煎熬。总分319，专业排名33，英语校线45，我46，数学校线75，我78，专业课还不错，128分。我按照往年的惯例算了一下，32名应该就稳了，33不好说。真是更加纠结。后来在群里得知有一个同学总分比我高，但是英语39，排名在我前边，说实话我还窃喜了一下，原谅我的不厚道。 之后真的就是耐着性子，顶着头皮又把复试科目看了一遍。之后就是去复试了。 写的有点累了，今天先写这么多吧。 事实证明，当你用电脑编辑一个很长的文档的时候，一定要记住时不时的保存一下。这已经时今天第二次了，差点将写了半天的东西“付之一炬”。 Copyright © Yuanye.Ma 2020-2021 all right reserved，powered by Gitbook文件修订时间： 2023-04-02 10:05:52 "},"_posts/diary/2019-01-09-我的2018.html":{"url":"_posts/diary/2019-01-09-我的2018.html","title":"2019-01-09-我的2018","keywords":"","body":"2019/01/09 晴 （大连） 今天是这学期在网信中心值班的最后一天了。八点上班，七点的时候闹钟响了，本来都起不来的，但是想想‘善始善终’吧，下学期不来了是下学期的事情，这学期的班还是好好上吧，就又爬起来洗漱，买了两个包子和一包牛奶就过来了。其实值班也没什么事情，十分钟不到把例行工作做完了，别的资料也看不进去，还是继续写这个吧。 从复试开始 我的2018年差不多是从复试开始的，别的也记不得太多了。过年的时候复试名单还没有出来，所以发小们几个聚在一起的时候我一直没说我也考研了的事情，本想着要是没进复试就继续出去工作了。后来复试名单出来了，我就顶着头皮开始在家里复习了，期间还尝试着联系了几个导师，但是都没有回应，只好把复试科目又看了一遍，后来就来了大连参加复试了。 复试期间其实没什么说的。第一天到达大连，先到宾馆把东西放下，然后去第二天要参加笔试的研教楼看了一下，顺便测一下路程，看走过去要多久，路上在哪里吃早饭。宾馆是我哥给订的，订的晚了，北门那边没有房间了，就在西门订了一家最便宜的，而我复试也在北门，走过去至少要二十分钟，所以在大连的几天我都是6点就起来了。笔试前一天晚上我还在宾馆看书，房间没有窗户，开着灯也很暗，就看一会儿睡一会儿时间就过去了。 第二天笔试感觉好像也没什么难的，交完卷感觉放松了一些，只要笔试能过，面试其实我并不是很怕，所以就回宾馆待着了。 第三天面试，分英语面试和专业面试，英语面试提前准备了一段简短的英文自我介绍，其他的只能听天由命了，好在大家英语都不是很好，老师也不太为难你，两人一组先自我介绍，然后抽一个题签用英文回答，另一个同学根据你的回答提一个问题，你作答，然后另一个同学抽题签并回答问题，我再提问，他作答这样子。 专业面试分四组，学硕两组，专硕两组，很多人都围在面试教室门口，出来一个都要打听一下老师都问了什么问题。因为我的名次比较靠后，听了前边人说的情况，本科做过项目的就简单问问你的项目，没做过项目的就问问毕业设计，要是毕业设计也是水过去的，就只好聊聊家常了，现场抽的题签，回答正确，错误好像关系也不是很大。听了这些我觉得更有底气了。轮到我的时候我抱了一堆证书，抽了两个选择题，都回答正确了，然后简单做了一个自我介绍，介绍了一下我本科时参加过很多比赛，大四在深圳工作一年，主要做过的项目。有老师对我手里拿的东西感兴趣，所以就又挨个把奖状和证书拿出来展示了一边，提问环节也没问什么太难的正经问题，问我确定导师了吗，我说没有。但是在我收拾完东西出教室的时候有个老师（卢志茂老师，后边还会提到）追了出来，留了联系方式和办公室地址，让我下午有空的话去他办公室坐坐。至此，觉得也有老师要了，考上应该是没什么问题了，随便找了个地方吃点东西，在校园里转了转，到下午两点的样子给卢老师打了电话，问他什么时候在办公室，我什么时候过去比较合适，他说下午随时去都可以，然后我就去了。 我到他办公室的时候已经有了一个同学（这个同学是我后来的室友）在和他聊，看我来了后匆匆离开了。其实也没聊什么东西，大体就是想让我去他们实验室，然后给我介绍了一下他们实验室的主要方向，但是我当时没有直接答应，因为我还想多了解一些信息再做决定，最后说定下午下班前给他答复，他同意了。刚从他办公室出来，就又有一个老师（这个是杨鑫老师）给我打电话，让我过去聊聊。杨老师看起来比卢老师年轻很多，毕竟卢老师是教授、博士生导师，杨鑫是副教授、硕导。杨老师说他的实验室是电信学部唯一一个国家级实验室（国家地方联合实验室，由教育部和大连市教育局共同出资建设），实验室主要方向有机器人、图像、人工智能balabala... 我依然没有当时决定，也是说下午下班前给他答复。 从老师办公室出来后，我先给哥哥打了个电话简单介绍了一下两个老师的情况，然后又给考试前联系的一个学长打了电话，问了一下两个老师的情况，他说只是听说杨鑫实验室项目多，经费充足，卢老师实验室不了解。综合多方面因素，最后觉得杨老师团队可能比较有潜力，最终决定去杨老师实验室。给杨老师回了电话，说第二天上午领了导师确认条后再去他办公室。给卢老师回了电话表示遗憾，最后给哥哥姐姐爸爸妈妈挨个回了电话，第一时间告诉他们考研这一年终于有了结果，现在终于可以和他们分享我的喜悦和成就感了。 下午四点，去电信学部研究生招生办公室门口看了一下确认录取名单以及奖学金情况。初试成绩不好，复试面试翻盘，最终排名虽然比初试提前了几个名次，但是还是三等奖学金，不过我已经很知足了。 第二天，体检，见导师，然后终于结束大连之行。 回首考研这一年，感慨日子过得真快。 一件事如果说考虑清楚了，那就去做就好了，考虑清楚了也就不要再纠结了。 事不预，则不立。提前做好计划，然后按照计划无脑执行，会比只想、不做好很多。 做计划的时候不要把目标定得太高，可以一点点的来做的切合实际的小目标，比一下把自己吓得不敢行动的大目标要实际的多。 如果一件事情你现在想不清楚，但是知道当下做什么是对的，那就先去做当下该做的就好了，想不清楚的留着慢慢想。 考研，难的不是知识，而是去了解自己并和自己做斗争的过程。本以为自己会很努力，会按照时间表严格执行，早上六点起床晚上十一点睡觉，在图书馆坐一天，除了吃饭喝水上厕所，都在专注的学习。然而事实是，早上睡到七点还是不想起，坐在图书馆看不进去书，前怕狼后怕虎，担心考不上，担心自己一年白费。看着厚厚的复习资料会烦躁，复习进度慢了会急躁。‘踏实’、‘专注’两个词，想要做到，真的不容易。 说起考驾照 大连 开学 Copyright © Yuanye.Ma 2020-2021 all right reserved，powered by Gitbook文件修订时间： 2023-04-02 10:05:52 "},"_posts/diary/2019-01-25-写在大连回家路上.html":{"url":"_posts/diary/2019-01-25-写在大连回家路上.html","title":"2019-01-25-写在大连回家路上","keywords":"","body":"2019年1月25日 大连回家的火车上 阴天（邢台） 今天本来是实验室举行年会的日子，而我缺在回家的火车上，成为实验室唯一一个不参加年会的人。这要从月初说起，当时接到了初中同学——王龙飞的电话， 说年前或者年后打算结婚了，日子大概会定在小年左右。有一次见导师汇报完后，说起什么时候可以回家，闫俊名（我导师的另一个学生）说想腊月二十（1月25日）回家， 家里有两个表妹要出嫁，年后没啥事可以早点来，我就没说啥，我也是这个打算。然后老师就说那就腊月二十回去，过完年早点来吧，初六。 然后我就按照这个时间买的车票。后来中旬的时候杨鑫在群里发通知说实验室放假时间为1月27日到2月22日（正月十五），1月25日实验室举办年会，会有抽奖等活动。 并且27日到22日之间回家的往返车票或者机票行程单保存好，后边给报销。后来王龙飞又给我发消息说23号结婚，我是赶不上了。这个时候想改签晚几天也不行了， 车票早没了，改的话只能买机票了，大概六百多。而且这个报销我觉得也不好说，可能会通过每个月的学生助研经费走。思忱之下我决定还是按照计划好的行程走吧， 不给报就不给报吧。 继续上次说考驾照的事情。 关于考驾照 说起考驾照真是。。。。一言难尽啊。 2013年6月刚高考完的时候，没出成绩的时候觉得考砸了，准备复读，我爸也一直在说让我复习的话。成绩出来的时候过了二本线，不走吧，可惜了。走又走不了好学校。 结果还是走了。所以三个月的假期就是：等成绩、准备报考、准备开学。。。就这样过去了。 大学期间一直瞎忙，周围同学都报驾校了，我又觉得在哈尔滨考太贵了，四千多。在家报名才两千多一点。大一：作比赛，没报。大二：作比赛，假期回家时间也短， 依旧没报。大三：准备找工作了，报名倒是报名了，钱也交了，没空回家，也就没考。大四：深圳上班，更加的没时间了。总之，就是各种事情给耽搁了下来。 一直拖到了大学毕业，考研结束，在家等考研成绩的时候，我妈说不行年前先把科目一给考了，反正现在也学不进去了，不如找点事情干着，换换脑子。 我爸依旧说等成绩吧，成绩出来再说考驾照的事情。成绩出来了，复试结束了，已经到了四五月份。 之前报的驾校在妙水寺，离家倒是很近，走路半个小时也到了。但是倒闭了，交的两千多块钱，现在还没退回来。后来托熟人在汝州汝东报的名，这个驾校特别远，在汝州城东南角的城边， 就在汝河旁边，当时只是说去看看情况，到了后就由不得你冷静思考了，说什么有接送车，人少教得好，容易过巴拉巴拉的。然后就报了名。 事实是，交钱的时候你是大爷，你有什么后顾之忧都能给你解决了。交完钱，啊？我说过这事吗？按照流程走吧，慢慢考。说好的接送车，我到现在都没见过。 科目一还好，我回去看了一星期，去听了半天课就考过了。科目二就开始难受了，在家等了半个月才安排练车。练车二十多天，我风雨无阻，每天骑个电动车三十公里的跑。 二十天都是上午练半天。练了十七八天的时候，教练还不说让约考试，我们才知道，教练的意思是这二十天是你交的学费里的标准的课时，课时上完后还要你再加课时练到 考试的时候。我就不乐意了，我们真练的不行加课时没啥说，关键我们组练的还可以，教练天天也不管我们，我们自己相互监督，相互总结，每人两圈每人两圈的练， 中间是有几天大家感觉练的差不多了，有点飘，开的乱七八糟。后来冷静下来后表现都还是不错的。我们就没管教练自己约了考试，在课时结束后的几天。教练还威胁我们， 让在这几天过去加课时，我也没去，只在考前的加了一个课时恢复一下手感。第二天考试，在最后一个项目，坡道定点停车的时候，停的稍微有点早，扣了十分，但是算及格，一次通过了。 科目三是最难受的，科目二考完后一直不通知练车，这个时候已经快要六月份了。而我在复试完的时候杨鑫找我们说想让我们早点过去大连，也就说原计划六月下旬去大连的。 我就很着急，不停给驾校打电话，他们就说没车，练了也约不上什么的，我就不信怎么可能约不上，我就说那我自己约考试，我如果约上了，她得给我安排练车，她说行。 结果我一次就约上了，这个时候驾校不承认说过约上了给我安排练车的事情。真正考验人际关系的时候到了，各种打电话协商，最后结果是，驾校把我原本六天的课时给折合 成四个课时在加课时的时候两天给我补了。只得同意。 驾校给补的两天，整个人都是懵的，教练巴拉巴拉说了一大推，不停给你举一些不知所谓的例子。到了考场才知道科目三是怎么回事。在考场加课时，一个课时要一百二十元，一个课时一个小时。 我有点心疼钱，在考场加了两个课时，中间也在车上看别人练了几天，感觉好可以，不要太紧张，也没什么难的。然后就去考试了。 考试的时候紧张的不行，前边一个女生考试，我在后座备考，不让说话。前边女生开的挺好的，都是到最后停车的时候，老是压线，没通过。监考的给骂的哭着走了。 到我的时候更是紧张的不行，二号线本来车也多，上下坡的难度也不小。我上去到第一个左转弯的时候是红灯，等灯期间转向灯自动熄灭了，我没注意到，红灯变绿了，我发现了赶紧把灯打上了， 这个时候已经晚了。教练下来又把我骂一通，把车开了回去，第二次我小心翼翼，有惊无险，到最后停车点，只要把车停好就通过了，该死的系统，就是不报停车指令，眼看着就要过了考试区域了。 监考说停车，和监控室交涉，说让我回去把最后一项再补一下，说的也是模模糊糊，我想确认清楚他表达的意思，他又给我骂一通。然后开回去的时候没有任何系统指令，我也不知道具体是只让我补一项 还是全部从头来，然后第一个红绿灯的时候，跪了。没办法，回家吧，爷爷奶奶还包了饺子，本想庆祝我考试通过的，我说没通过的时候他们都不相信，我从小到大无证驾驶好多年，什么车上手就能开， 都对我考驾照信心满满的，殊不知，就是考驾照的这种小轿车，我爸从来不让我碰，我也没像小时候那么犟了，无所谓了，不让开就不让开吧，我爸和我哥这俩人还新鲜不够，我就不和他们抢了， 所以到练科目二之前，我从来没开过这种车。拖拉机也是在考了科目二后我爸一个人忙不过来才让我开的。 无奈，继续预约，加课时，考试，第二次我调整好心态，觉得一定给考过，一洗前耻的时候，在候考大厅等了半天，系统故障死活连不上网，所有人全部取消预约，我连被分到了哪条线都没看到就回家了。 这个时候已经六月底了，我不能再被驾照耽误了，第二天就和姐姐一起动身去大连了。 我们家我是最小接触各种车的，自行车、摩托车、三轮的两轮的、四轮的基本上都不怎么费劲就学会了，还记得小时候和嘉祥嘉瑞好几个表兄弟姐妹一起学自行车，我也是第一个学会的。 然而驾照我却是最后一个。 所以，说来惭愧，到现在我依然没有驾驶证。 总结一下经验，中国是个人情社会这是毫无疑问的，但是什么事都找熟人，真的合适吗？我不这样认为。小时候跟着我爸到处跑，对镇子上也比较熟，买个衣服、年货什么的也是直接到这个叔叔那个阿姨那里， 买了就走，刚开始觉得确实挺方便的，有时候确实能便宜一点。时间长了慢慢的发现不一样。熟人给你优惠是给你面子，不给你优惠你也没啥说，面子这个是建立在彼此利用价值上的， 你对别人有利用价值，别人才会给你面子。别人也是做生意的凭什么不挣钱的给你提供批发价？而且如果你买的东西有什么问题，这又该怎么算？因此我觉得，人情这个东西，能不用还是尽量不要用， 你欠的人情能还上还好，大家礼尚往来，但是如果你无限制的透支，慢慢的就不招人待见了。所以，能自己办的事情还是自己努力好了，别人帮你一定要记在心里，有机会能还，还是要还的。 不轻易开口，但是到了开口的时候，往往你的诉求就变的比较有分量了。 行百里者半九十。要认真对待每一件事，不能一切都想当然。想当然我驾照应该是很快就能拿到手的，但是事实是我到如今依旧没驾照。 所以对待任何事情都不能掉以轻心，踏踏实实做好该做的，结果肯定不会太坏。所需要做的，就是尽量的思虑周全，然后踏踏实实做事。 关于写作，写一些开心的事情，总会越写越开心，以至于任何一个细节都不忍放过，总是越写兴致越高，越想写，也就越写越多。而一些不是不是很开心的事情，就不太想写， 写的过程无异于揭伤疤，人就会本能的逃避，这可能是很多人想写日记，却迟迟不肯动笔的原因吧。 车到安阳了，再等一会儿就到站了，累了，有时间继续补2018年下半年。 2019年2月2日 阴历腊月二十八 今天，终于把科目三考过了，一百分。 这几天爸爸什么也不忙了，天天专门开车送我去考场练车，加了四个课时，终于考过了。　　 2019年2月10日 阴历正月初六 昨晚一场大雪，今天高速、长途汽车站全部关闭，赶不上下午的火车了，就退票了，改买2月16日的机票。再在家待几天就预约了2月14日的“站岗”。顺利的话下次回来把科目四考了，就可以拿证了。 2019年2月16日 晴 正月十二 大连 今天早上要赶早上六点洛阳到新郑的机场大巴，昨晚就住姐那里了（她这几天装房子）。一大早五点就起来了，简单洗漱一下，就到开元大道和龙门大道交叉口“八达航空”坐大巴去了。路上还算顺利，就是在过安检的时候两包纯牛奶没喝完给放那里了。晴空万里，只有洛阳起飞的时候稍微有点雾，后边全程都能看到地面的建筑，天气很好。 下午三点就到学校了，现在开始补过年时欠下的工作。 之所以这篇日记写在这里是因为，我其实是想说本来14号的“站岗”被取消了，只能下次回去再继续考了。无奈脸。。。 Copyright © Yuanye.Ma 2020-2021 all right reserved，powered by Gitbook文件修订时间： 2023-04-02 10:05:52 "},"_posts/Hackintosh/2019-04-15-Hackintosh（黑苹果）.html":{"url":"_posts/Hackintosh/2019-04-15-Hackintosh（黑苹果）.html","title":"2019-04-15-Hackintosh（黑苹果）","keywords":"","body":"黑苹果安装步骤简记 最近突然对安装黑苹果系统很感兴趣，就上网找了一些资料来看看，下边简单记录一下我的收获。以下操作都在虚拟机中进行。工具软件在这里(显示不出来了，可以直接到tonymac.com下载) 今天无意间发现大神们整理的资源，然后刚好和我的一台台式机型号匹配，打算有时间的时候操刀试试。 目录 {:toc} 1. 下载镜像 我在win里边装了一个macos的虚拟机，在app sotre中下载的mojave镜像。不过下载的时候有一个小插曲，我虚拟机装的是10.11.6的，在app store中只能下载22.8MB的一个在线升级工具，最后通过这个工具下载到了完整的6G+的镜像。此外其他版本的完整镜像也可以通过这个工具下载。 2. 制作启动U盘 制作启动U盘有很多中方式，前题是U盘必须转换为GUID格式。 windows 下可以使用transmac软件制作 使用镜像中的工具制作 使用tonymacx86论坛提供的UniBeats工具制作 格式化U盘 在虚拟机中新建一个大小为10G的硬盘，插入后MacOS会检测到，然后点击Initialize... 左边选择好要擦除的硬盘后，点击上方的Erase Name随便写，Format选择OS X Extended， 最后一行的Scheme 一定选GUID 方式一：使用镜像中的工具制作 命令如下 :sudo /Applications/Install\\ macOS\\ Mojave.app/Contents/Resources/createinstallmedia --volume /Volumes/Mojave /Applications/Install\\ macOS\\ Mojave.app --nointeraction 其中 第一项：/Applications/Install\\ macOS\\Mojave.app/Contents/Resources/createinstallmedia 指的是下载好的镜像中的工具的路径； 第二项：--volume /Volumes/Mojave 指定U盘位置 第三项：/Applications/Install\\ macOS\\ Mojave.app 整个安装包的路径 操作步骤如下 右键点击下载好的Mojave镜像，选择Show Package Contents， 然后找到Contents -> Resources -> createinstallmedia 文件，直接拖动放入Terminal； 输入--velume /Volumes/you_disk 可以通过tab键补全路径名； 点击返回按钮，返回到没有打开镜像的地方，拖动镜像放入Terminal中； 输入密码，输入Y，开始刻录U盘； 刻录完成； 此种方法刻录的U盘好像不用再用Clover写入引导，我在虚拟机中测试可以引导，具体情况还得到实体机上测试。 方案二：windows下使用transmac软件制作 --TODO 下载安装后会在桌面生成快捷方式。右键以管理员身份打开。 教程 方案三：使用UniBeats工具制作 注：使用的工具都在tonymacx86.com下载，下载需要登录，注册需要使用国外的邮箱，我使用了gmail。 先在虚拟机中分了一个10G大小的硬盘当做的我U盘，挂载到Mac的虚拟机后格式化为GPT分区格式。 然后打开UniBeast工具开始制作。 此软件要求系统语言是英文，所以如果系统语言不是英文会要求更改，只需打开系统偏好设置 然后将英文拖动到第一位，点击重启就好了。 点击Agree 选中U盘，我这里前边把U盘命名为boot 选中要刻录的系统，这里的Mojave系统要拖动到Application目录中才能自动识别出来。 选择UEFI引导模式。 注入显卡驱动 开始拷贝文件 制作完成后桌面会多出来一个EFI分区。 写入Clover引导 打开Clover开始写入引导。 这里要选择Change Install Location... 选择Install ... 这个是写入镜像后的U盘，名字变了可以通过分区大小区分。然后点击Continue 点击Customize 进入配置页面，选择一些必要的驱动，点击Install 关闭虚拟机，在虚拟机重启时进入BIOS,选择做好的U盘引导系统。 3. 配置Clover 使用前边制作好的U盘就可以插入电脑从U盘启动了，接下来进入安装黑苹果最难的部分：配置Clover驱动。 使用Clover Configure软件进行配置。 打开软件后，在左边找到Mount EFI 左下会出现可以挂载的EFI分区。点击Mount Partition -> Open Parition。如下图，选择EFI -> CLOVER -> config.plist 双击打开。 然后就进入了下边的配置界面。 后边的内容需要在实体机上根据具体的硬件信息进行配置，暂时不看。 4. 安装系统 5. 进入系统解决驱动问题 6. 将Clover引导写入硬盘 Copyright © Yuanye.Ma 2020-2021 all right reserved，powered by Gitbook文件修订时间： 2023-04-02 10:05:52 "},"_posts/Hackintosh/2019-05-09-制作dmg格式的苹果镜像.html":{"url":"_posts/Hackintosh/2019-05-09-制作dmg格式的苹果镜像.html","title":"2019-05-09-制作dmg格式的苹果镜像","keywords":"","body":"制作dmg格式的苹果镜像 思路：创建一个dmg镜像，将macos的内容写入dmg，然后将dmg转换为压缩镜像。 但是直接拷贝到其他系统中就是一个文件夹。 开始制作 一、 创建一个镜像文件 将Install macOS High Sierra.app内容复制到桌面的High Sierra文件夹; 然后打开Disk Utility工具，选择File -> New Image -> Image from Folder; 点击桌面上刚才创建的High Sierra文件夹，选择下边的Choose 保存路径选为桌面，镜像格式选择为read/write，最后选择save,几分钟后会在桌面生成一个High Sierra.dmg的镜像文件。 二、 写入镜像内容 此部分和制作U盘镜像的方法一样。 首先双击刚才生成的High Sierra.dmg，会在桌面出现High Sierra挂载点。 打开终端，输入命令sudo ~/Desktop/Install\\ macOS\\ High\\ Sierra.app/Contents/Resources/createinstallmedia --volume /Volumes/High\\ Sierra --applicationpath ~/Desktop/Install\\ macOS\\ High\\ Sierra.app --nointeraction。 createinstallmedia命令的参数列表如下, 个人猜测后边的--applicationpath 和--nointeraction参数不加也无所谓 命令执行完成后发现，桌面上的卷标从High Sierra 变为了Install macOS High Sierra 推出刚才创建的Install macOS High Sierra卷，删除桌面上最开始创建的文件夹High Sierra。 三、转换镜像格式 打开刚才用到的Disk Utility工具，点击Images->Convert,选择桌面的High Sierra.dmg,按照如下图的参数，点击Convert 四、验证 双击创建好的macOS High Sierra.dmg验证完毕后打开如下窗口。 搞定。 Copyright © Yuanye.Ma 2020-2021 all right reserved，powered by Gitbook文件修订时间： 2023-04-02 10:05:52 "},"_posts/Hackintosh/2019-05-13-在黑苹果上部署开发环境.html":{"url":"_posts/Hackintosh/2019-05-13-在黑苹果上部署开发环境.html","title":"2019-05-13-在黑苹果上部署开发环境","keywords":"","body":"在黑苹果上部署开发环境 使用ubuntu的nfs 首先在ubuntu上安装nfs服务 sudo apt install nfs-kernel-server 创建共享目录并赋予权限 sudo mkdir /home/rl/share sudo chmod 777 /home/rl/share 配置/etc/exports文件 sudo vim /etc/exports 写入下边内容 /home/rl/share *(rw,sync,insecure,no_subtree_check,no_root_squash) 注意 `insecure`必须填，不然在macos的Finder中无法访问nfs目录 在MacOS中访问ubuntu的nfs目录 首先在终端中查看共享目录共享是否成功 $ showmount -e 192.168.50.30 Exports list on 192.168.50.30: /home/rl/share * 然后在Finder中链接nfs服务 在Finder图标上右键选择连接服务器，填入共享目录，如下图点击connect。 深度学习环境搭建 参照此教程安装CUDA Nvidia driver CUDA driver CUDA Toolkits 添加环境变量 export CUDA_HOME=/usr/local/cuda export DYLD_LIBRARY_PATH=\"$CUDA_HOME/lib:$CUDA_HOME/extras/CUPTI/lib\" export LD_LIBRARY_PATH=$DYLD_LIBRARY_PATH export PATH=$DYLD_LIBRARY_PATH:$PATH export flags=\"--config=cuda --config=opt\" export PATH=\"/Developer/NVIDIA/CUDA-9.2/bin:$PATH\" #nvcc 命令路径 以下为尝试，未能解决问题。 首先需要安装Xcode，登录苹果开发者 下载完成后得到一个.xip压缩文件，双击进行校验，校验完成后会自动解压。解压完成得到Xcode.app拖进/Applications中完成安装。 sudo xcode-select --switch /Applications/Xcode.app/Contents/Developer/ 再次执行编译命令 make -C ./1_Utilities/deviceQuery 然后会显示 Agreeing to the Xcode/iOS licese requires admin privileges, please run `sudo xcodebuild -license ` and then retry this command 然后执行 sudo xcodebuild -license 按回车 按space直到最后然后输入 agree 再次执行编译命令,报错 nvcc fatal : The version ('10.0') of the host compiler ('Apple clang') is not supported 网上找到解决方案，此错误是Xcode Command Line版本太高了，需要切换为低版本的。 下载安装Command Line Tools macOS 10.13 for Xcode9.2 sudo xcode-select --switch /Library/Developer/CommandLineTools 如图，编译成功，执行编译完的程序，发现能够正常识别显卡。 cudnn 参照教程我也下载了cudnn v7.2.1下载完成双击解压，然后按照下边过程安装。 $ sudo cp cuda/include/cudnn.h /usr/local/cuda/include/ $ sudo cp cuda/lib/libcudnn* /usr/local/cuda/lib/ $ sudo chmod a+r /usr/local/cuda/include/cudnn.h /usr/local/cuda/lib/libcudnn* $ vim ~/.zshrc 写入：export DYLD_LIBRARY_PATH=/usr/local/cuda/lib/:$DYLD_LIBRARY_PATH $ source ~/.zshrc 测试 $ echo -e '#include \"cudnn.h\"\\n void main(){}' | nvcc -x -c - -o /dev/null -I/usr/local/cuda/include -L /usr/local/cuda/lib -lcudnn 测试 cuda cudnn pytorch cuda和cudnn都安装完了后，安装pytorch。 首先按照这篇blog)尝试安装pytorch 0.4.0但是切换到v0.4.0执行git submodule update init的时候一直报 错，说找不到仓库。 后按照另外一篇blog，直接安装pytorch 1.1.0 git clone --recursive https://github.com/pytorch/pytorch git submodule update --init --recursive python setup.py install 安装完成后需要切换出pytorch的源码目录，再执行python然后import torch才有效，不然会报错ModuleNotFoundError: No module named 'torch._C' Copyright © Yuanye.Ma 2020-2021 all right reserved，powered by Gitbook文件修订时间： 2023-04-02 10:05:52 "},"_posts/Hackintosh/2019-05-13-尝试吃黑苹果.html":{"url":"_posts/Hackintosh/2019-05-13-尝试吃黑苹果.html","title":"2019-05-13-尝试吃黑苹果","keywords":"","body":"尝试吃苹果 系统配置 CPU i7 7700k GPU GTX 1050 Ti 主板 ASUS PRIME Z270-P 声卡 瑞昱 ALC887 网卡 瑞昱 RTL8186/8111/8112 具体请看鲁大师检测结果(原谅手机的渣像素) BIOS先恢复默认，然后设置成下边样子。 U盘启动 本来在虚拟机中装了一个macOS系统，想着使用tonymacx86网站提供的UniBeast软件写盘的，但是发现UniBeast在虚拟机中使用时不能写U盘。 后使用命令的方式将mac High Sierra.dmg镜像写入了U盘。 插入电脑进入BIOS设置从U盘启动，发现U盘没有引导程序，使用windows下的Transmac软件或者使用镜像中提供的工具写的U盘都额外需要使用Clover手动创建引导。创建引导的时候只需要写成EFI方式就好，其他的无所谓，因为后边还要修改参数。 刚开始从网上找了一个和自己配置一样的EFI文件想着偷下懒，直接拖进U盘的EFI分区，后来发现启动不了，最后按照B站 爱折腾 前辈的建议，删掉所有东西遇到问题再添的思路，删掉了EFI/CLOVER/kexts目录下的所有东西，只留了一个EFI/CLOVER/kexts/Other/FakeSMC.kext。并且用Clover Configurator打开EFI/CLOVER/config.plist取消ACPI设置中的所有Fixes，并删掉了补丁栏目中的所有东西。再次插入U盘重启，打开-v参数，看到了下边的错误。 网上搜了一番后说是需要在引导参数中添加-disablegfxfirmware参数，终于进入U盘引导。 格盘装系统 这部分也纠结了一番，本来win-ubuntu的双系统硬盘还有一百多个G的空余，就想把macos安装在这一百多个G的空间，但是 后来，又搜索一番后，在这个磁盘的头部分配了一个500MB大小的EFI分区，才抹盘成功。 装驱动 网卡驱动 网卡驱动比较好弄，直接用MultiBeast 重启后就可以在关于本机->系统报告->网络部分看到。 这里还有一点，BIOS中要开启网络堆栈，不然的话进入系统后，能看到网卡，但是系统偏好设置->网络部分一直显示'未连接'或者'电缆拔出' 显卡驱动 在tonymacx86/Download/Nvidia Driver下载点最右边的图标是下载。 声卡驱动 首先使用AppleHDA Patcher软件show Jarvis 发现声卡未识别，显示Found \"Device(HDAS)\" in DSDT.aml, you should rename it as \"Device(HDEF)\" for a working audio 打开Clover Configurator 挂载EFI分区，用Clover Configurator打开EFI/CLOVER/config.plist 设置有效，但是仍然未识别出来声卡型号。 尝试使用万能声卡。 到sourceforge.net上搜索VoodooHDA,下载，拖到EFI/CLOVER/kexts/Other 重启后在关于本机->系统报告-> 音频 系统偏好设置 -> 声音 -> 输出 均能看到音频设备。 再次打开AppleHDA Patcher 好像识别的是HDMI 下载安装网易云音乐随便放一首音乐，可以正常播放。 系统偏好设置 -> 声音 -> 输出下边的[]在菜单栏中显示音量勾选后就可以点击屏幕的右上角喇叭状图标调节音量，并选择输出设备。 USB 3.0 USB3.0口无效，只能用来充电，即使是USB3.0的U盘也只能在USB2.0的口上被识别出来。 打开Clover Configuator挂载EFI分区，打开EFI/CLOVER/config.plist。 然后转到内核和驱动补丁选项， key value 名称 com.apple.driver.usb.AppleUSBXHCI 查找 837D880F 0F83A704 0000 替换 837D880F 90909090 9090 注释 随便写 此外还要到这个网站下载USBInjectALL.kext驱动程序并放入EFI/CLOVER/kexts/Other目录中，然后重启。 重启后打开关于本机->系统报告->USB可以看到速度原本最大480Mb/秒的U盘现在识别为最大5 Gb/秒,U盘插入USB 3.0的插口也能正常识别。 TODO AppleALC原生驱动 长时间睡眠唤醒会一直黑屏 工具列表 名称 作用 Clover 引导工具 Clover Configurator Clover配置工具 PlistEdit Pro 同样是编辑CLOVER/config.plist的工具 MultiBeast 安装驱动以及安装clover到磁盘的EFI分区（有些驱动会安装失败） Kext Wizard 安装驱动到 /L/E，并构建内核驱动列表库 DPCIManager 查看网卡信息 IORegistryExplorer 查看系统硬件接口信息 AppleHDA Patcher 注入AppleALC Copyright © Yuanye.Ma 2020-2021 all right reserved，powered by Gitbook文件修订时间： 2023-04-02 10:05:52 "},"_posts/LDD/2020-10-06-Linux设备驱动模型.html":{"url":"_posts/LDD/2020-10-06-Linux设备驱动模型.html","title":"2020-10-06-Linux设备驱动模型","keywords":"","body":"Linux设备驱动模型 本来是看了宋宝华写的《linux设备驱动开发详解（第2版）》的第5章：设备文件系统，关于设备模型的描述做了一些笔记，想参照着代码整理一下，发现所参考的Linux 3.0.8的内核代码和书上描述结构体的代码不一样。所以，就简单列一下这些关键的结构体，只求以后读内核代码的时候再见到这些结构体的时候知道是怎么回事。 kobject kobject是linux 2.6引入的设备管理机制，在内核中由kobject结构体表示，该结构使所有设备在底层都具有统一的接口。kobject是linux内核中面向对象思想的重要体现，是一个基类， device对象、driver对象、class对象以及bus对象都继承或者间接继承此类。每一个kobject都对用sysfs中的一个目录。 #include struct kobject { const char *name; struct list_head entry; struct kobject *parent; // 指向父对象的指针 struct kset *kset; // 所属于哪个kset struct kobj_type *ktype; // 对象类型描述符指针 struct sysfs_dirent *sd; struct kref kref; // 对象引用计数 unsigned int state_initialized:1; unsigned int state_in_sysfs:1; unsigned int state_add_uevent_sent:1; unsigned int state_remove_uevent_sent:1; unsigned int uevent_suppress:1; }; struct kobj_type { void (*release)(struct kobject *); /*当kobject的引用计数为0时调用此函数，用以释放资源*/ const struct sysfs_ops *sysfs_ops; struct attribute **default_attrs; }; 内核中提供了一系列操作kobject的函数 void kobject_init(struct kobject *kobj, struct kobj_type *ktype); /*初始化kobject, 设置引用计数为1， entry域指向自己，其所属的kset引用计数加1*/ int kobject_set_name(struct kobject *kobj, const char *name, ...); /*用于设置kobject的名字*/ int kobject_add(struct kobject *kobj, struct kobject *parent, const char *fmt, ...); /*该函数用于将kobject对象加入Linux设备层次，它会挂接该kobject对象到kset的list链中，增加父目录各级kobject的引用计数，在其parent指向的目录下创建文件节点，并启动该类型内核对象的hotplug函数*/ void kobject_del(struct kobject *kobj); /*该函数执行和kobject_add()相反的操作*/ void kobject_cleanup(struct kobject *kobj); void kobject_release(struct kref *kref) /*这两个函数用于清除kobject，当其引用计数为0时，释放对象所占用的资源*/ struct kobject *kobject_get(struct kobject *kobj); void kobject_put(struct kobject *kobj); /*这两个函数分配用于增加和减少引用计数，当引用计数为0时，所有该对象使用的资源将被释放*/ kset kobject通常通过kset组织成层次化的结构，kset是具有相同类型的kobject的集合，在内核中用结构体kset表示。 kset是kobject的子类之一，表示一些kobject的集合。比如在总线中，所有挂接在同一总线的device就可以组成成一个kset，所有挂接在同一总线的driver也可以组织成一个kset。 #include struct kset { struct list_head list; spinlock_t list_lock; struct kobject kobj; /* 内嵌一个kobject对象，用作kset的引用计数，也作为集合内所有kobject对象的parent*/ const struct kset_uevent_ops *uevent_ops; }; 与kobject类似，内核也提供了一些操作kset的函数。 void kset_init(struct kset *kset); int __must_check kset_register(struct kset *kset); void kset_unregister(struct kset *kset); struct kset *kset_get(struct kset *k); void kset_put(struct kset *k); kobject被创建或者删除时会产生时间（event），kobject所属的kset会过滤事件或者为用户空间添加信息，每个kset能支持一些特定的事件变量，在热插拔事件发生时，kset的成员函数可以设置一些事件变量，这些变量将被导出到用户空间。kset的uevent_ops成员是执行该kset事件操作集的指针。 struct kset_uevent_ops { int (* const filter)(struct kset *kset, struct kobject *kobj);//用与过滤掉不需要导出的事件 const char *(* const name)(struct kset *kset, struct kobject *kobj);//用于导出一些环境变量给用户空间的热插拔处理程序。用户空间的热插拔脚本根据传入的参数，以及内核导出便来给你采取行动。 int (* const uevent)(struct kset *kset, struct kobject *kobj, struct kobj_uevent_env *env); }; kset和kobject的关系 subsystem 貌似是老版本的内核代码中有的东西，在linux 3.0.8中找不到相关代码。 在linux 2.6版本中此结构封装了struct kset device 系统中任一设备在设备模型中都由一个struct device对象描述。 #include /** * struct device - The basic device structure * @parent: The device's \"parent\" device, the device to which it is attached. * In most cases, a parent device is some sort of bus or host * controller. If parent is NULL, the device, is a top-level device, * which is not usually what you want. * @p: Holds the private data of the driver core portions of the device. * See the comment of the struct device_private for detail. * @kobj: A top-level, abstract class from which other classes are derived. * @init_name: Initial name of the device. * @type: The type of device. * This identifies the device type and carries type-specific * information. * @mutex: Mutex to synchronize calls to its driver. * @bus: Type of bus device is on. * @driver: Which driver has allocated this * @platform_data: Platform data specific to the device. * Example: For devices on custom boards, as typical of embedded * and SOC based hardware, Linux often uses platform_data to point * to board-specific structures describing devices and how they * are wired. That can include what ports are available, chip * variants, which GPIO pins act in what additional roles, and so * on. This shrinks the \"Board Support Packages\" (BSPs) and * minimizes board-specific #ifdefs in drivers. * @power: For device power management. * See Documentation/power/devices.txt for details. * @pwr_domain: Provide callbacks that are executed during system suspend, * hibernation, system resume and during runtime PM transitions * along with subsystem-level and driver-level callbacks. * @numa_node: NUMA node this device is close to. * @dma_mask: Dma mask (if dma'ble device). * @coherent_dma_mask: Like dma_mask, but for alloc_coherent mapping as not all * hardware supports 64-bit addresses for consistent allocations * such descriptors. * @dma_parms: A low level driver may set these to teach IOMMU code about * segment limitations. * @dma_pools: Dma pools (if dma'ble device). * @dma_mem: Internal for coherent mem override. * @archdata: For arch-specific additions. * @of_node: Associated device tree node. * @devt: For creating the sysfs \"dev\". * @devres_lock: Spinlock to protect the resource of the device. * @devres_head: The resources list of the device. * @knode_class: The node used to add the device to the class list. * @class: The class of the device. * @groups: Optional attribute groups. * @release: Callback to free the device after all references have * gone away. This should be set by the allocator of the * device (i.e. the bus driver that discovered the device). * * At the lowest level, every device in a Linux system is represented by an * instance of struct device. The device structure contains the information * that the device model core needs to model the system. Most subsystems, * however, track additional information about the devices they host. As a * result, it is rare for devices to be represented by bare device structures; * instead, that structure, like kobject structures, is usually embedded within * a higher-level representation of the device. */ struct device { struct device *parent; struct device_private *p; struct kobject kobj; // 内嵌一个kobject对象 const char *init_name; /* initial name of the device */ const struct device_type *type; struct mutex mutex; /* mutex to synchronize calls to its driver.*/ struct bus_type *bus; /* type of bus device is on */ struct device_driver *driver; /* which driver has allocated this device */ void *platform_data; /* Platform specific data, device core doesn't touch it */ /* 省略 */ struct device_node *of_node; /* associated device tree node */ dev_t devt; /* dev_t, creates the sysfs \"dev\" */ spinlock_t devres_lock; struct list_head devres_head; struct klist_node knode_class; struct class *class; const struct attribute_group **groups; void (*release)(struct device *dev); }; device结构体用于描述设备有关信息，设备之间的层次关系，以及设备与总线驱动的关系，通常device结构体不单独使用，而是嵌入在更大的结构体中，内核提供了很多操作device的方法。 int __must_check device_register(struct device *dev); //此函数调用device_add()函数，将一个新的device对象插入设备模型，并自动在/sys/devices下创建一个对应的目录 void device_unregister(struct device *dev); //执行与device_register()函数相反的操作 driver 系统中每个驱动程序都由一个struct device_driver对象描述。 #include /** * struct device_driver - The basic device driver structure * @name: Name of the device driver. * @bus: The bus which the device of this driver belongs to. * @owner: The module owner. * @mod_name: Used for built-in modules. * @suppress_bind_attrs: Disables bind/unbind via sysfs. * @of_match_table: The open firmware table. * @probe: Called to query the existence of a specific device, * whether this driver can work with it, and bind the driver * to a specific device. * @remove: Called when the device is removed from the system to * unbind a device from this driver. * @shutdown: Called at shut-down time to quiesce the device. * @suspend: Called to put the device to sleep mode. Usually to a * low power state. * @resume: Called to bring a device from sleep mode. * @groups: Default attributes that get created by the driver core * automatically. * @pm: Power management operations of the device which matched * this driver. * @p: Driver core's private data, no one other than the driver * core can touch this. * * The device driver-model tracks all of the drivers known to the system. * The main reason for this tracking is to enable the driver core to match * up drivers with new devices. Once drivers are known objects within the * system, however, a number of other things become possible. Device drivers * can export information and configuration variables that are independent * of any specific device. */ struct device_driver { const char *name; struct bus_type *bus; struct module *owner; const char *mod_name; /* used for built-in modules */ bool suppress_bind_attrs; /* disables bind/unbind via sysfs */ const struct of_device_id *of_match_table; int (*probe) (struct device *dev); int (*remove) (struct device *dev); void (*shutdown) (struct device *dev); int (*suspend) (struct device *dev, pm_message_t state); int (*resume) (struct device *dev); const struct attribute_group **groups; const struct dev_pm_ops *pm; struct driver_private *p; }; 内核中提供操作struct device_driver的函数 int __must_check driver_register(struct device_driver *drv); void driver_unregister(struct device_driver *drv); bus 系统中的总线都由struct bus_type描述， 每个bus_type对象都对应/sys/bus目录下的一个子目录，每个子目录下又都存在devices和drivers。 #include /** * struct bus_type - The bus type of the device * * @name: The name of the bus. * @bus_attrs: Default attributes of the bus. * @dev_attrs: Default attributes of the devices on the bus. * @drv_attrs: Default attributes of the device drivers on the bus. * @match: Called, perhaps multiple times, whenever a new device or driver * is added for this bus. It should return a nonzero value if the * given device can be handled by the given driver. * @uevent: Called when a device is added, removed, or a few other things * that generate uevents to add the environment variables. * @probe: Called when a new device or driver add to this bus, and callback * the specific driver's probe to initial the matched device. * @remove: Called when a device removed from this bus. * @shutdown: Called at shut-down time to quiesce the device. * @suspend: Called when a device on this bus wants to go to sleep mode. * @resume: Called to bring a device on this bus out of sleep mode. * @pm: Power management operations of this bus, callback the specific * device driver's pm-ops. * @p: The private data of the driver core, only the driver core can * touch this. * * A bus is a channel between the processor and one or more devices. For the * purposes of the device model, all devices are connected via a bus, even if * it is an internal, virtual, \"platform\" bus. Buses can plug into each other. * A USB controller is usually a PCI device, for example. The device model * represents the actual connections between buses and the devices they control. * A bus is represented by the bus_type structure. It contains the name, the * default attributes, the bus' methods, PM operations, and the driver core's * private data. */ struct bus_type { const char *name; struct bus_attribute *bus_attrs; struct device_attribute *dev_attrs; struct driver_attribute *drv_attrs; int (*match)(struct device *dev, struct device_driver *drv); int (*uevent)(struct device *dev, struct kobj_uevent_env *env); int (*probe)(struct device *dev); int (*remove)(struct device *dev); void (*shutdown)(struct device *dev); int (*suspend)(struct device *dev, pm_message_t state); int (*resume)(struct device *dev); const struct dev_pm_ops *pm; struct subsys_private *p; }; 内核提供了一些bus_type的操作函数 int __must_check bus_register(struct bus_type *bus); void bus_unregister(struct bus_type *bus); class #include /** * struct class - device classes * @name: Name of the class. * @owner: The module owner. * @class_attrs: Default attributes of this class. * @dev_attrs: Default attributes of the devices belong to the class. * @dev_bin_attrs: Default binary attributes of the devices belong to the class. * @dev_kobj: The kobject that represents this class and links it into the hierarchy. * @dev_uevent: Called when a device is added, removed from this class, or a * few other things that generate uevents to add the environment * variables. * @devnode: Callback to provide the devtmpfs. * @class_release: Called to release this class. * @dev_release: Called to release the device. * @suspend: Used to put the device to sleep mode, usually to a low power * state. * @resume: Used to bring the device from the sleep mode. * @ns_type: Callbacks so sysfs can detemine namespaces. * @namespace: Namespace of the device belongs to this class. * @pm: The default device power management operations of this class. * @p: The private data of the driver core, no one other than the * driver core can touch this. * * A class is a higher-level view of a device that abstracts out low-level * implementation details. Drivers may see a SCSI disk or an ATA disk, but, * at the class level, they are all simply disks. Classes allow user space * to work with devices based on what they do, rather than how they are * connected or how they work. */ struct class { const char *name; struct module *owner; struct class_attribute *class_attrs; struct device_attribute *dev_attrs; struct bin_attribute *dev_bin_attrs; struct kobject *dev_kobj; int (*dev_uevent)(struct device *dev, struct kobj_uevent_env *env); char *(*devnode)(struct device *dev, mode_t *mode); void (*class_release)(struct class *class); void (*dev_release)(struct device *dev); int (*suspend)(struct device *dev, pm_message_t state); int (*resume)(struct device *dev); const struct kobj_ns_type_operations *ns_type; const void *(*namespace)(struct device *dev); const struct dev_pm_ops *pm; struct subsys_private *p; }; 属性 bus device、 driver和class层次上都分别定义了其属性结构体，包括 bus_attibute、device_attibute、driver_attibute 以及 class_attibute。都定义在include\\linux\\device.h。 struct bus_attribute { struct attribute attr; ssize_t (*show)(struct bus_type *bus, char *buf); ssize_t (*store)(struct bus_type *bus, const char *buf, size_t count); }; #define BUS_ATTR(_name, _mode, _show, _store) \\ struct bus_attribute bus_attr_##_name = __ATTR(_name, _mode, _show, _store) //创建初始化宏 int __must_check bus_create_file(struct bus_type *, struct bus_attribute *); void bus_remove_file(struct bus_type *, struct bus_attribute *); // xxx_create_file()函数会调用sysfs_create_file()函数创建对应的sys文件节点 // xxx_remove_file()函数会调用sysfs_remove_file()函数删除对应的sys文件节点 Copyright © Yuanye.Ma 2020-2021 all right reserved，powered by Gitbook文件修订时间： 2023-04-02 10:05:52 "},"_posts/LDD/2020-10-06-platform总线驱动.html":{"url":"_posts/LDD/2020-10-06-platform总线驱动.html","title":"2020-10-06-platform总线驱动","keywords":"","body":"Linux内核 platform总线驱动 platform总线驱动 在linux2.6以后的设备驱动模型中，需要关心总线、设备和驱动三个实体，总线将设备和驱动绑定。在系统中每注册一个设备时，总线会寻找与之匹配的驱动；相反的，在系统每注册一个驱动的时候，总线会寻找与之匹配的设备，而匹配绑定工作由总线完成。 platform总线是linux系统中的一种虚拟总线，相应的设备称为platform_device对应的驱动称为platfor_driver。 platform_device #include struct platform_device { const char * name; int id; struct device dev; // 在linux设备驱动模型文章中有所介绍，是linux中所有设备对象的抽象 u32 num_resources; // 设备对应的资源数量 struct resource * resource; // 设备资源数组 const struct platform_device_id *id_entry; //用于和platform_driver匹配 /* MFD cell pointer */ struct mfd_cell *mfd_cell; /* arch specific additions */ struct pdev_archdata archdata; }; int platform_device_register(struct platform_device *); //此函数调用platform_device_add(pdev)完成向platform总线注册设备 void platform_device_unregister(struct platform_device *); //此函数调用platform_device_del(pdev)完成从platform总线中删除设备 int platform_add_devices(struct platform_device **, int); //循环调用platform_device_register函数，批量注册platform_device //函数定义在 drivers/base/platform.c中 /** * platform_device_register - add a platform-level device * @pdev: platform device we're adding */ int platform_device_register(struct platform_device *pdev) { device_initialize(&pdev->dev); return platform_device_add(pdev); } EXPORT_SYMBOL_GPL(platform_device_register); /** * platform_device_unregister - unregister a platform-level device * @pdev: platform device we're unregistering * * Unregistration is done in 2 steps. First we release all resources * and remove it from the subsystem, then we drop reference count by * calling platform_device_put(). */ void platform_device_unregister(struct platform_device *pdev) { platform_device_del(pdev); platform_device_put(pdev); } EXPORT_SYMBOL_GPL(platform_device_unregister); /** * platform_add_devices - add a numbers of platform devices * @devs: array of platform devices to add * @num: number of platform devices in array */ int platform_add_devices(struct platform_device **devs, int num) { int i, ret = 0; for (i = 0; i = 0) platform_device_unregister(devs[i]); break; } } return ret; } EXPORT_SYMBOL_GPL(platform_add_devices); 在板文件中，platform_device通常被组织成一个数组，通过在板级初始化时调用platform_add_devices()函数统一注册，例如mach-smdkv210.c的smdkv210_machine_init()函数调用platform_add_devices(smdkv210_devices, ARRAY_SIZE(smdkv210_devices));就是采用这种统一注册多个设备的方法。 platform_driver #include struct platform_driver { int (*probe)(struct platform_device *); int (*remove)(struct platform_device *); void (*shutdown)(struct platform_device *); int (*suspend)(struct platform_device *, pm_message_t state); int (*resume)(struct platform_device *); struct device_driver driver; // 在linux设备驱动模型文章中有所介绍，是linux中所有驱动对象的抽象 const struct platform_device_id *id_table; }; // 操作方法如下 int platform_driver_register(struct platform_driver *drv); //初始化platform_driver结构，并向系统中注册struct driver void platform_driver_unregister(struct platform_driver *drv); //从系统中删除struct driver // drivers/base/platform.c中定义 /* * platform_driver_register - register a driver for platform-level devices * @drv: platform driver structure */ int platform_driver_register(struct platform_driver *drv) { drv->driver.bus = &platform_bus_type; if (drv->probe) drv->driver.probe = platform_drv_probe; if (drv->remove) drv->driver.remove = platform_drv_remove; if (drv->shutdown) drv->driver.shutdown = platform_drv_shutdown; return driver_register(&drv->driver); } /** * platform_driver_unregister - unregister a driver for platform-level devices * @drv: platform driver structure */ void platform_driver_unregister(struct platform_driver *drv) { driver_unregister(&drv->driver); } platform的bus_type定义 系统为platform总线定义了一个bus_type的实例，在drivers/base/platform.c中描述。 // drivers/base/platform.c struct device platform_bus = { .init_name = \"platform\", }; struct bus_type platform_bus_type = { .name = \"platform\", .dev_attrs = platform_dev_attrs, .match = platform_match, .uevent = platform_uevent, .pm = &platform_dev_pm_ops, }; int __init platform_bus_init(void) { int error; early_platform_cleanup(); error = device_register(&platform_bus); /* 注册了一个struct device对象作为，其他platform_device的parent 比如在platform_device_add(pdev)函数中 pdev->dev.parent = &platform_bus */ if (error) return error; error = bus_register(&platform_bus_type); /* 注册总线 在platform_device_add(pdev)函数中pdev->dev.bus = &platform_bus_type */ if (error) device_unregister(&platform_bus); return error; } 其中match()方法完成platform_device和platform_driver之间是如何进行匹配的。 static int platform_match(struct device *dev, struct device_driver *drv) { struct platform_device *pdev = to_platform_device(dev); struct platform_driver *pdrv = to_platform_driver(drv); /* Attempt an OF style match first */ if (of_driver_match_device(dev, drv)) //设备树匹配方式 return 1; /* Then try to match against the id table */ if (pdrv->id_table) return platform_match_id(pdrv->id_table, pdev) != NULL; /* fall-back to driver name match */ return (strcmp(pdev->name, drv->name) == 0); } //其中 #define to_platform_driver(drv) (container_of((drv), struct platform_driver, driver)) #define to_platform_device(x) container_of((x), struct platform_device, dev) static const struct platform_device_id *platform_match_id( const struct platform_device_id *id, struct platform_device *pdev) { while (id->name[0]) { if (strcmp(pdev->name, id->name) == 0) { pdev->id_entry = id; return id; } id++; } return NULL; } struct platform_device_id { char name[PLATFORM_NAME_SIZE]; kernel_ulong_t driver_data __attribute__((aligned(sizeof(kernel_ulong_t)))); }; 下边是一个platform_device和platform_driver匹配的实例。 // arch/arm/mach-smdkv210.c static struct resource s3c_i2c_resource[] = { [0] = { .start = S3C_PA_IIC, .end = S3C_PA_IIC + SZ_4K - 1, .flags = IORESOURCE_MEM, }, [1] = { .start = IRQ_IIC, .end = IRQ_IIC, .flags = IORESOURCE_IRQ, }, }; struct platform_device s3c_device_i2c0 = { .name = \"s3c2410-i2c\", .id = 0, .num_resources = ARRAY_SIZE(s3c_i2c_resource), .resource = s3c_i2c_resource, }; // drivers/i2c/busses/i2c-s3c2410.c中关于platform_driver的定义 /* device driver for platform bus bits */ static struct platform_device_id s3c24xx_driver_ids[] = { { .name = \"s3c2410-i2c\", .driver_data = TYPE_S3C2410, }, { .name = \"s3c2440-i2c\", .driver_data = TYPE_S3C2440, }, { }, // platform_device_id是一个数组,最后以空元素结尾 }; MODULE_DEVICE_TABLE(platform, s3c24xx_driver_ids); static struct platform_driver s3c24xx_i2c_driver = { .probe = s3c24xx_i2c_probe, .remove = s3c24xx_i2c_remove, .id_table = s3c24xx_driver_ids, // 用于和platform_device中的name字段匹配 .driver = { .owner = THIS_MODULE, .name = \"s3c-i2c\", .pm = S3C24XX_DEV_PM_OPS, }, }; 关于资源 #include struct resource { resource_size_t start; resource_size_t end; const char *name; unsigned long flags; // IORESOURCE_IO IORESOURCE_MEM IORESOURCE_IRQ等 在include /linux/ioport.h中有描述 struct resource *parent, *sibling, *child; }; #include /** * platform_get_resource - get a resource for a device * @dev: platform device * @type: resource type * @num: resource index */ struct resource *platform_get_resource(struct platform_device *, unsigned int, unsigned int); /** * platform_get_irq - get an IRQ for a device * @dev: platform device * @num: IRQ number index */ int platform_get_irq(struct platform_device *, unsigned int); 定义资源以及获取资源的实例 // arch/arm/mach-at91/board-sam9261ek.c static struct resource dm9000_resource[] = { [0] = { .start = AT91_CHIPSELECT_2, .end = AT91_CHIPSELECT_2 + 3, .flags = IORESOURCE_MEM }, [1] = { .start = AT91_CHIPSELECT_2 + 0x44, .end = AT91_CHIPSELECT_2 + 0xFF, .flags = IORESOURCE_MEM }, [2] = { .start = AT91_PIN_PC11, .end = AT91_PIN_PC11, .flags = IORESOURCE_IRQ | IORESOURCE_IRQ_LOWEDGE | IORESOURCE_IRQ_HIGHEDGE, } }; // 获取资源实例 res_mem = platform_get_resource(pdev, IORESOURCE_MEM, 0); port->membase = ioremap(res_mem, ALTERA_JTAGUART_SIZE); res_irq = platform_get_resource(pdev, IORESOURCE_IRQ, 0); request_irq(res_irq, ....) platform_match()什么时候被谁调用？ 参考文献：platform_driver_register()--如何match之后调用probe platform_driver_register | driver_register | bus_add_driver | driver_attach(drv) int driver_attach(struct device_driver *drv) { return bus_for_each_dev(drv->bus, NULL, drv, __driver_attach); } | __driver_attach | driver_match_device(drv, dev) static inline int driver_match_device(struct device_driver *drv,struct device *dev) { return drv->bus->match ? drv->bus->match(dev, drv) : 1; } | driver_probe_device | really_probe | if (dev->bus->probe) { ret = dev->bus->probe(dev); } else if (drv->probe) { ret = drv->probe(dev); } /* 总结： bus_for_each_dev遍历总线drv->bus上的每个设备，并对每一个设备执行__driver_attach()函数; __driver_attach()函数又调用driver_match_device()函数匹配pdev和pdrv, 而driver_match_device()函数会调用总线的match函数，对于platform总线来说match函数即platform_match(); 匹配成功后首先看总线有没有probe函数，若有则调用，否则调用驱动自己的probe函数, 而总线没有probe函数 */ Copyright © Yuanye.Ma 2020-2021 all right reserved，powered by Gitbook文件修订时间： 2023-04-02 10:05:52 "},"_posts/LDD/2020-10-09-loop设备的使用.html":{"url":"_posts/LDD/2020-10-09-loop设备的使用.html","title":"2020-10-09-loop设备的使用","keywords":"","body":"loop设备的使用 以下引自zh.wikipedia.org /dev/loop（或称vnd (vnode disk)、lofi（循环文件接口））在类Unix系统中是一种伪设备，这种设备使得文件可以如同块设备一般被访问。 在使用之前，循环设备必须与现存文件系统上的文件相关联。这种关联将提供给用户一个应用程序接口，接口将允许文件视为块特殊文件（参见设备文件系统）使用。因此，如果文件中包含一个完整的文件系统，那么这个文件就能如同磁盘设备一般被挂载。 用法 在目录上挂载包含文件系统的文件一般需要两步： 用一个循环设备节点连接文件。 在目录上挂载该循环设备 方法一 losetup /dev/loop0 example.img mount /dev/loop0 /home/you/dir 方法二 mount -o loop example.img /home/you/dir 设备卸载 之后设备便能用下列命令实现卸载： umount /home/you/dir # 或者通过诸如 mount | grep \"/home/you/dir\" # 或是 losetup -a | grep example.img 的查找找到与文件相关联的loop设备号码 # 并执行下列命令：（代表设备号） umount /dev/loop 总结 将文件挂载为loop设备，前提是要挂载的文件内包含完整的文件系统。 实例 $ sudo mount -o rootfs.cramfs /mnt/ #rootfs.cramfs是自己用busybox制作的cramfs格式的根文件系统 $ ls /mnt # 可以看到根文件系统中的内容 $ losetup -a /dev/loop10: []: (/home/kevin/rootfs.cramfs) # 可以看到设备loop10和rootfs.cramfs文件系统绑定了 此方法可以用于调试根文件系统，以及挂载本地的iso光盘镜像 mount -o loop -t iso9660 /usr/local/tooldisk/mydisk4.iso /mnt/vcdrom Copyright © Yuanye.Ma 2020-2021 all right reserved，powered by Gitbook文件修订时间： 2023-04-02 10:05:52 "},"_posts/LDD/2020-10-10-设备驱动基础.html":{"url":"_posts/LDD/2020-10-10-设备驱动基础.html","title":"2020-10-10-设备驱动基础","keywords":"","body":"1.2 设备驱动基础 驱动基本结构 // hello_drv.c #include #include static int __init hello_drv_init(void) { printk(KERN_ERR\"-----------from hello.ko : %s %s---------\\n\", __FILE__, __FUNCTION__); return 0; } static void __exit hello_drv_exit(void) { printk(\"-----------from hello.ko : %s %s---------\\n\", __FILE__, __FUNCTION__); } module_init(hello_drv_init); module_exit(hello_drv_exit); MODULE_LICENSE(\"GPL\"); 基本Makefile结构 # 内核源码路径 KERNEL_DIR = # 驱动源码所在目录 CUR_DIR = $(shell pwd) # 指定编译哪些源文件 obj-m = hello_drv.o all : make -C $(KERNEL_DIR) M=$(CUR_DIR) modules clean ： make -C $(KERNEL_DIR) M=$(CUR_DIR) clean 运行/装载驱动模块 inmod hello_drv.ko #插入内核模块 rmmod hello_drv #移除内核模块 lsmod #查看当前已经插入的内核模块 其他特性 模块传参 // $insmod hello.ko number=250 name=\"ruhua\" module_param(参数名， 参数类型， 权限) //例： module_param(number, int, 666) 模块符号导出 EXPORT_SYMBOL(符号名) 装载的时候先装载被调用的模块 一个真正的设备驱动需要一些元素 设备号 register_chrdev(unsigned int major, const char * name , const struct file_operations * fops); /* * 参数1 --- 指定一个主设备号，填0表示由系统自动分配 * 参数2 --- 字符串， 描述设备驱动信息，自定义 * 参数3 --- 文件操作对象 * 如果参数1为0，则返回值是一个int型的主设备号，否则返回负数为错误号， generic */ unregister_chrdev(unsigned int major, const char * name) //--- 释放已经注册的主设备号 设备文件 手动创建: 每次重启都得手动创建 mknod /dev/hello c 254 0 自动创建 #include struct class * class_create(THIS_MODULE, “led_cls”) /* * 参数一： THIS_MODULE * 参数二 ： 字符串，表示类的名字 * 返回值 struct class 指针类型 */ struct device * device_create(struct class * cls, struct device * parent, dev_t devt, void * drvdata, const char * fmt, ...) /* * 参数一： class_create()返回的指针 * 参数二： 该设备的父类 * 参数三： 设备号， 包含主设备号和次设备号，MKDEV(major, minor) * 参数四： 私有数据指针，可以为NULL * 参数五： 设备节点名字 * 返回值： struct device * */ void device_destory(struct device * dev, dev_t devt); void class_destory(struct class * cls); 设备的操作方法 /* * NOTE: * all file operations except setlease can be called without * the big kernel lock held in all filesystems. */ struct file_operations { struct module *owner; loff_t (*llseek) (struct file *, loff_t, int); ssize_t (*read) (struct file *, char __user *, size_t, loff_t *); ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *); unsigned int (*poll) (struct file *, struct poll_table_struct *); long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long); int (*mmap) (struct file *, struct vm_area_struct *); int (*open) (struct inode *, struct file *); int (*flush) (struct file *, fl_owner_t id); int (*release) (struct inode *, struct file *); /*省略其他不常用的*/ }; /* * 设备操作命令如何定义： 由程序员定义，一定是一个整数 * 1. 直接用整数 --- 有可能会和系统中已经有的命令冲突 * #define LED_ALL_ON 0x2222 * 2. 用内核提供的接口来定义 #include _IO(type, nr) //参数一 ：魔幻数---字符，参数二：唯一的数字 __IOW(type, nr, size) __IOR(type, nr, size) __IOWR(type, nr, size) */ /* 原型如下 */ #define _IO(type,nr) _IOC(_IOC_NONE,(type),(nr),0) #define _IOR(type,nr,size) _IOC(_IOC_READ,(type),(nr),sizeof(size)) #define _IOW(type,nr,size) _IOC(_IOC_WRITE,(type),(nr),sizeof(size)) #define _IOWR(type,nr,size) _IOC(_IOC_READ|_IOC_WRITE,(type),(nr),sizeof(size)) /* ------------------ 例 ----------------*/ #define LED_NUM_ON _IOW('L', 0x3456, int) #define LED_NUM_OFF _IOW('L', 0x3457, int) #define LED_ALL_ON _IOW('L', 0x3458) xxx_ioctl(int fd, int cmd, unsigned long args) { int num = args; switch(cmd) { case LED_NUM_ON： xxx break; case LED_NUM_OFF： xxx break; case LED_ALL_ON: xxx break; } } 内存映射与映射 #include /** * kzalloc - allocate memory. The memory is set to zero. * @size: how many bytes of memory are required. * @flags: the type of memory to allocate (see kmalloc). */ static inline void *kzalloc(size_t size, gfp_t flags) //flags: GFP_KERNEL 如果当前暂时没有内存，会尝试等待（阻塞） kfree() #include #define ioremap(cookie, size) __uc32_ioremap(cookie, size) /* * 参数一：物理地址 * 参数二：映射的长度 * 返回值：映射之后的虚拟地址 */ /* ------------------ 例 ----------------*/ gpc0_conf = ioremap(0xE020060, 8); gpc0_data = gpc0_conf+1; //配置输出 *gpc0_conf &= ~(0xff 数据在内核空间和用户空间拷贝的方法 #include unsigned long copy_from_user(void * to, void __user * from, unsigned long n); unsigned long copy_to_user(void __user * to, const void * from, unsigned long n); Copyright © Yuanye.Ma 2020-2021 all right reserved，powered by Gitbook文件修订时间： 2023-04-02 10:05:52 "},"_posts/LDD/2020-10-11-linux驱动之LED驱动.html":{"url":"_posts/LDD/2020-10-11-linux驱动之LED驱动.html","title":"2020-10-11-linux驱动之LED驱动","keywords":"","body":"linux驱动之LED驱动 试验平台： NanoPi M1 全志H3 寄存器地址在全志H3的Datasheet 4.23节有介绍。 /* * led.h : 定义ioctl的命令 */ #ifndef __LED_H #define __LED_H #include #define LED_NUM_ON _IOW('L',0x3456, int) #define LED_NUM_OFF _IOW('L',0x3457, int) #endif /* * led_drv.c ： 实现led的驱动 */ #include #include #include // struct file_operations #include // kzalloc #include // class_create和device_create #include // ioremap #include // copy_from_user #include \"led.h\" /* 自定义设备结构体，用于存储设备相关的信息 */ struct led_device { int dev_major; struct class *cls; struct device * dev; int value; }; /* 全局变量 */ static struct led_device *led_dev; volatile unsigned long * gpl10_conf; volatile unsigned long * gpl10_data; volatile unsigned long * gpa10_conf; volatile unsigned long * gpa10_data; /* 自定义函数 */ static int led_drv_open(struct inode *inode, struct file *filp) { printk(\"-------^_^ %s-------\\n\", __FUNCTION__); *gpl10_conf &= (0x1value, buf, count); if (led_dev->value) { *gpl10_data |= (0x1dev_major = 240; ret = register_chrdev(led_dev->dev_major, \"led_drv\", &led_drv_fops); if (ret cls = class_create(THIS_MODULE,\"led_cls\"); if(IS_ERR(led_dev->cls)) { printk(KERN_ERR\"class_create error\\n\"); ret = PTR_ERR(led_dev->cls); goto err_unregister; } led_dev->dev = device_create(led_dev->cls, NULL,MKDEV(led_dev->dev_major, 0), NULL, \"led\"); if(IS_ERR(led_dev->dev)) { printk(\"device_create error\\n\"); ret = PTR_ERR(led_dev->dev); goto err_class_destroy; } gpl10_conf = ioremap(0x01F02C04, 4); gpl10_data = ioremap(0x01F02C10, 4); gpa10_conf = ioremap(0x01C20804, 4); gpa10_data = ioremap(0x01C20810, 4); return 0; err_class_destroy: class_destroy(led_dev->cls); err_unregister: unregister_chrdev(led_dev->dev_major, \"led_drv\"); err_free: kfree(led_dev); return ret; } static void __exit led_drv_exit(void) { printk(\"-----------from led.ko : %s %s---------\\n\", __FILE__, __FUNCTION__); iounmap(gpl10_conf); iounmap(gpl10_data); iounmap(gpa10_conf); iounmap(gpa10_data); device_destroy(led_dev->cls, MKDEV(led_dev->dev_major, 0)); class_destroy(led_dev->cls); unregister_chrdev(led_dev->dev_major, \"led_drv\"); kfree(led_dev); } module_init(led_drv_init); module_exit(led_drv_exit); MODULE_LICENSE(\"GPL\"); /* * led_app.c ： 测试led驱动的应用程序 */ #include #include #include #include #include \"led.h\" int main(void) { int fd = open(\"/dev/led\", O_RDWR); if (fd linux驱动程序开发步骤总结 实例化全局的设备对象 -- kzalloc 注册设备号 -- register_chrdev 创建设备节点 -- class_create, device_create 映射内存资源 -- ioremap 实现 file_operations gpio操作方法: 1, 直接操作gpio口对应的寄存器地址(看原理图---数据手册---地址--ioremap) *gpc0_conf &= ~(0xff视频中gpio操作方法是基于S5PV210的，全志H3暂时还不知道怎么操作。 Copyright © Yuanye.Ma 2020-2021 all right reserved，powered by Gitbook文件修订时间： 2023-04-02 10:05:52 "},"_posts/LDD/2020-10-27-linux驱动之中断（按键驱动）.html":{"url":"_posts/LDD/2020-10-27-linux驱动之中断（按键驱动）.html","title":"2020-10-27-linux驱动之中断（按键驱动）","keywords":"","body":"Linux设备驱动开发--中断用法 [TOC] 1. linux中file cdev inode之间的关系； struct file对象 ： 描述进程中打开文件的信息，包括文件名、读写标志、文件的当前偏移指针等。 #include struct file { /* * fu_list becomes invalid after file_free is called and queued via * fu_rcuhead for RCU freeing */ union { struct list_head fu_list; struct rcu_head fu_rcuhead; } f_u; struct path f_path; /* 略 */ const struct file_operations *f_op; // 文件操作接口 spinlock_t f_lock; /* f_ep_links, f_flags, no IRQ */ /* 略 */ loff_t f_pos; // 文件偏移 struct fown_struct f_owner; const struct cred *f_cred; struct file_ra_state f_ra; /* 略 */ void *private_data; // 万能指针，可以用来存储私有的数据地址 /* 略 */ }; struct cdev对象： 描述一个字符设备对象，任何一个字符设备驱动都应该有此对象； #include struct cdev { struct kobject kobj; struct module *owner; const struct file_operations *ops; struct list_head list; dev_t dev; // 设备号 unsigned int count; }; struct inode对象：描述文件系统中某个文件的信息； #include struct inode { /* RCU path lookup touches following: */ umode_t i_mode; uid_t i_uid; gid_t i_gid; /* 省略众多暂时无关的成员 */ const struct file_operations *i_fop; /* former ->i_op->default_file_ops */ struct file_lock *i_flock; struct address_space *i_mapping; struct address_space i_data; #ifdef CONFIG_QUOTA struct dquot *i_dquot[MAXQUOTAS]; #endif struct list_head i_devices; union { struct pipe_inode_info *i_pipe; struct block_device *i_bdev; struct cdev *i_cdev; }; /* 略 */ }; 字符设备通过register_chrdev(设备号, fops)将cdev结构体挂接在内核中cdev的链表上。 用户空间mknod的时候，会在/dev/下创建设备文件，该文件在内存中对应一个inode对象，mknod的设备号赋给inode. 用户空间open()的时候，通过inode中的i_cdev找到对应的cdev，将cdev->ops赋值给struct file的f_op，执行f_op->open()； /* 通过inode获得主次设备号*/ int minor = iminot(const struct inode * inode); int major = imajor(const struct inode * inode); /* 通过filp找到inode */ struct inode * node = filp->f_path.dentry->d_inode; 2. 注册字符设备的方式 /*1.两种方式申请设备号*/ /* 1.1 静态申请设备号--仅仅得到设备号，注册设备*/ dev_t devno = MKDEV(260, 0); register_chrdev_region(devno, 1, “key_new_drv”); int register_chrdev_region(dev_t from, unsigned count, const char * name); // 参数一： 设备号 // 参数二： 设备的个数 // 参数三： 描述字符串 --- /proc/devices // 返回值： 0 成功， -1 失败 /* 1.2 动态分配设备号*/ int alloc_chrdev_region(dev_t * dev, unsigned baseminor, unsigned count, const char * name); // 参数一： 保存主设备号的变量地址 // 参数二： 次设备号的起始地址 // 参数三： 设备的个数 // 参数四： 描述字符串 --- /proc/devices // 返回值： 0 成功， -1 失败 /*2.动态分配一个cdev结构对象*/ cdev_alloc(void); /*3.初始化cdev对象*/ cdev_init(struct cdev * cdev, const struct file_operations * fops); /*4.将当前的cdev注册到系统中*/ cdev_add(struct cdev * p, dev_t dev, unsigned count); // 参数二：设备号 // 参数三：设备的个数，一般都填1 /* 以上1、2、3、4步骤等同于用 int register_chrdev(unsigned int major, const char *name, const struct file_operations *fops) 此函数内部会创建并初始化cdev对象， 当第一个参数为0时，自动分配设备号。 */ cdev_del(); unregister_chrdev(); unregister_chrdev_region 3. 申请中断 // 注册中断的处理方法 static inline int __must_check request_irq(unsigned int irq, irq_handler_t handler, unsigned long flags, const char *name, void *dev) //参数一： 中断号， IRQ_EINT(x) x为外部中断号 arch/../mach/irqs.h中有枚举 //参数二： 中断处理函数 typedef irqreturn_t (*irq_handler_t)(int, void *); //参数三： 中断的触发方式，include/linux/interrupt.h文件中定义 #define IRQF_TRIGGER_NONE 0x00000000 #define IRQF_TRIGGER_RISING 0x00000001 #define IRQF_TRIGGER_FALLING 0x00000002 #define IRQF_TRIGGER_HIGH 0x00000004 #define IRQF_TRIGGER_LOW 0x00000008 #define IRQF_TRIGGER_MASK (IRQF_TRIGGER_HIGH | IRQF_TRIGGER_LOW | \\ IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING) #define IRQF_TRIGGER_PROBE 0x00000010 //参数四： /proc/interrupts中显示的字符串 //参数五： 传递给中断处理函数的参数 //返回值： // irq_handler_t的原型 typedef irqreturn_t (*irq_handler_t)(int, void *); //返回值如下 /** * enum irqreturn * @IRQ_NONE interrupt was not from this device * @IRQ_HANDLED interrupt was handled by this device * @IRQ_WAKE_THREAD handler requests to wake the handler thread */ enum irqreturn { IRQ_NONE = (0 4. 文件io模型实现之阻塞和非阻塞 实现阻塞 /*实现阻塞的步骤*/ /* 1 将当前进程状态设置为TASK_INTERRUPTIBLE : 可以被信号唤醒 */ set_current_state(TASK_INTERRUPTIBLE); /* 2 将当前进程加入到一个等待队列 */ add_wait_queue(wait_queue_head_t * q, wait_queue_t * wait)； /* 3 让出调度权 */ schedule(); /* 以上三个函数等同于wait_event_interruptible */ wait_event_interruptible(struct wait_queue_head_t wq, int condition); //参数一： 等待队列头 //参数二： 条件，如果为假，就休眠，否则继续执行 /* 资源可达的时候需要唤醒进程 */ wake_up_interruptible(x) /* 定义一个等待队列头 */ struct wait_queue_head_t wq_head; /* 初始化等待队列 */ init_waitqueue_head(wq_head); 实现非阻塞 //在应用程序中设定非阻塞模式 int fd = open(\"/dev/key0\", O_RDWR|O_NOBLOCK); // 有数据就得到数据，没有数据就得到一个出错码 -EAGAIN //在驱动xxx_read中要区分是阻塞还是非阻塞 if ( (filp->f_flags & O_NONBLOCK) && 没有数据) //非阻塞且没有数据，就返回出错码 { return -EAGAIN; } 5. 按键驱动 v1版本 实现按键触发中断 #include #include #include #include #include #include #include #define IR_GPIO GPIOH(8) #define USE_STATIC_MAJOR 1 #define KEY_MAJOR 260 struct s5pv210_key { dev_t devno; int dev_major; int irqno; struct cdev *cdev; struct class *cls; struct device *dev; }; struct s5pv210_key *key_dev; static int key_drv_open(struct inode *inode, struct file *filp) { return 0; } static int key_drv_close(struct inode *inode, struct file *filp) { printk(\"-------^_^ %s-------\\n\", __FUNCTION__); return 0; } struct file_operations key_fops = { .open = key_drv_open, .release = key_drv_close, }; irqreturn_t key_irq_svc(int irqno, void *dev_id) { printk(\" --------- ^-^ ---------%s \\n\", __FUNCTION__); return IRQ_HANDLED; } static int __init key_drv_init(void) { int ret; key_dev = kzalloc(sizeof(struct s5pv210_key), GFP_KERNEL); if (key_dev == NULL) { printk(KERN_ERR\"kzalloc error\\n\"); return -ENOMEM; } #ifdef USE_STATIC_MAJOR key_dev->devno = MKDEV(KEY_MAJOR, 32); ret = register_chrdev_region(key_dev->devno, 1, \"key\"); /*申请设备号*/ if (ret devno, 32, 1, \"key\"); if (ret != 0) { /* 出错 */ printk(KERN_ERR\"register chrdev failed\\n\"); goto err_free; } #endif key_dev->cdev = cdev_alloc(); /*动态分配一个struct cdev对象*/ cdev_init(key_dev->cdev, &key_fops); /*初始化cdev的fops*/ cdev_add(key_dev->cdev, key_dev->devno, 1); /*将cdev注册到系统中*/ /* 自动创建设备节点 */ key_dev->cls = class_create(THIS_MODULE, \"key_cls\"); if (IS_ERR(key_dev->cls)) { printk(KERN_ERR\"class create error\\n\"); ret = PTR_ERR(key_dev->cls); goto err_unregister; } key_dev->dev = device_create(key_dev->cls, NULL, MKDEV(key_dev->dev_major, 0), NULL, \"key%d\", 0); if (IS_ERR(key_dev->dev)) { printk(KERN_ERR\"device create error\\n\"); ret = PTR_ERR(key_dev->dev); goto err_class_destory; } /* 初始化硬件 */ // 中断号获取 IRQ_EINT(x); irqs.h //key_dev->irqno = IRQ_EINT(1); key_dev->irqno = gpio_to_irq(IR_GPIO); ret = request_irq(key_dev->irqno, key_irq_svc, IRQF_TRIGGER_FALLING|IRQF_TRIGGER_RISING, \"KEY\", NULL); if (ret != 0) { printk(KERN_ERR\"request irq error\\n\"); ret = -EBUSY; goto err_device_destory; } err_device_destory: device_destroy(key_dev->cls, key_dev->devno); err_class_destory: class_destroy(key_dev->cls); err_unregister: cdev_del(key_dev->cdev); unregister_chrdev_region(key_dev->devno, 1); err_free: kfree(key_dev); return ret; } static void __exit key_drv_exit(void) { class_destroy(key_dev->cls); cdev_del(key_dev->cdev); unregister_chrdev_region(key_dev->devno, 1); kfree(key_dev); } module_init(key_drv_init); module_exit(key_drv_exit); MODULE_LICENSE(\"GPL\"); 基于linux操作系统下s5pv210板子的按键中断实验 NanoPi—M1(H3)———基于该平台的一个内核中的按键中断程序开发历程 v2版本 识别按键 #include // KEY_DOWN //设计一个按键数据包 struct key_event { int code; //按键的名字 --- 例如：下键、回车键 int value; //按键的状态 --- 按下和抬起 1/0 }; struct s5pv210_key { dev_t devno; int dev_major; int irqno; struct cdev *cdev; struct class *cls; struct device *dev; struct key_event evnet; }; struct s5pv210_key *key_dev; irqreturn_t key_irq_svc(int irqno, void *dev_id) { printk(\" --------- ^-^ ---------%s \\n\", __FUNCTION__); int value = gpio_get_value(S5PV210_GPH0(1)); if (value) { /* 抬起 */ printk(\" key up \\n\"); key_dev->evnet.code = KEY_DOWN; //#include key_dev->event.value = 0; } else { printk(\" key down \\n\"); key_dev->evnet.code = KEY_DOWN; key_dev->event.value = 1; } return IRQ_HANDLED; } ssize_t key_drv_read(struct file (filp, char __user *buf, size_t count, loff_t *fpos) { int ret = copy_to_user(buf, &key_dev->event, count); if (ret > 0){ printk(\"copy_to_user error\\n\"); return -EFAULT; } memset(&key_dev->event, 0, sizeof(struct key_event)); return count; } 应用程序 #include // KEY_DOWN grep -nHr \"KEY_DOWN\" /usr/include/ int fd = open(\"/dev/key0\", O_RDWR); if (fd v3版本 v2版本的应用程序在运行时不停的读取按键状态，非常耗费CPU资源。考虑使用阻塞方式将读不到内容时将进程挂起。 在按键中断程序中使用阻塞方式。 #include // #include struct s5pv210_key { dev_t devno; int dev_major; int irqno; struct cdev *cdev; struct class *cls; struct device *dev; struct key_event evnet; struct wait_queue_head_t wq_head; int have_data; // 一个标志，表示是否有数据，在open函数中将此标志置为0 }; struct s5pv210_key *key_dev; /*在key_drv_init函数中初始化等待队列*/ static int __init key_drv_init(void) { init_waitqueue_head(key_dev->wq_head); } /*在read函数中如果读不到数据就将进程休眠*/ ssize_t key_drv_read(struct file (filp, char __user *buf, size_t count, loff_t *fpos) { int ret = 0； /*判断是否有资源*/ wait_event_interruptible(key_dev->wq_head, key_dev->have_data); /**/ ret = copy_to_user(buf, &key_dev->event, count); if (ret > 0){ printk(\"copy_to_user error\\n\"); return -EFAULT; } /* 清空缓冲区 为下一次读取操作做准备 */ memset(&key_dev->event, 0, sizeof(struct key_event)); /* 同时也要清空标志 */ key_dev->have_data = 0; return count; } /* 在中断服务函数中唤醒挂起的进程 */ irqreturn_t key_irq_svc(int irqno, void *dev_id) { printk(\" --------- ^-^ ---------%s \\n\", __FUNCTION__); int value = gpio_get_value(S5PV210_GPH0(1)); if (value) { /* 抬起 */ printk(\" key up \\n\"); key_dev->evnet.code = KEY_DOWN; //#include key_dev->event.value = 0; } else { printk(\" key down \\n\"); key_dev->evnet.code = KEY_DOWN; key_dev->event.value = 1; } /* 此时有数据可以读写了 */ key_dev->have_data = 1; /* 唤醒等待队列 */ wake_up_interruptible(&key_dev->wq_head); return IRQ_HANDLED; } 再看看驱动中区分是否阻塞需要注意的地方 /* 在本例中 */ ssize_t key_drv_read(struct file (filp, char __user *buf, size_t count, loff_t *fpos) { int ret = 0; /* 区分阻塞还是非阻塞 */ if ((filp->f_flags & O_NONBLOCK) && !key_dev->have_data) { return -EAGAIN; } /*判断是否有资源*/ wait_event_interruptible(key_dev->wq_head, key_dev->have_data); /**/ ret = copy_to_user(buf, &key_dev->event, count); if (ret > 0){ printk(\"copy_to_user error\\n\"); return -EFAULT; } /* 清空缓冲区 为下一次读取操作做准备 */ memset(&key_dev->event, 0, sizeof(struct key_event)); /* 同时也要清空标志 */ key_dev->have_data = 0; return count; } 手头只有NanoPi M1的板子，试验暂时还没做，加入TODO。 Copyright © Yuanye.Ma 2020-2021 all right reserved，powered by Gitbook文件修订时间： 2023-04-02 10:05:52 "},"_posts/LDD/input子系统.html":{"url":"_posts/LDD/input子系统.html","title":"input子系统","keywords":"","body":"[toc] input子系统特性、用途 1， input子系统是用来解决输入问题的，所谓输入，即驱动为应用层提供数据。 2， 使用字符设备的read或者ioctl也可以实现输入操作，这种方式的弊端在于：驱动程序员自己定义数据格式，导致数据格式不统一，比如同样是按键输入，不同人实现的方式不一样，有人定义key=‘1’，有的人定义key='key1'。导致应用层程序调用驱动时传参不一致。此外，字符设备驱动框架提供数据的双向交流，input子系统只处理输入数据。 3， input子系统的好处： 为输入数据提供统一规范，驱动程序遵循填充该标准，应用程序遵循调用该标准。 4， 在文件系统中查看input设备 myye@myye-vm:~$ ls /dev/input/event* /dev/input/event0 /dev/input/event1 /dev/input/event2 /dev/input/event3 /dev/input/event4 myye@myye-vm:~$ sudo cat /dev/input/event0 # 查看键盘的事件，按下键盘按键，终端会打印相应的信息 input子系统的框架结构 对于驱动开发来说，只需要实现 事件处理层和设备驱动层， 其中设备驱动层是关键，事件处理层内核也有通用事件处理的代码，可以更具需要进行修改。 相关头文件 #include 核心数据结构 要遵循的规范结构 struct input_event 驱动核心数据结构 struct input_dev , struct input_id input_event /* include/linux/input.h */ /* * The event structure itself */ struct input_event { struct timeval time; /* 事件产生的时间戳 */ __u16 type; /* 事件类型 */ __u16 code; /* 键码， 和type有关 */ __s32 value; /* 键值， 和code有关 */ }; 此结构用于设备驱动上报事件 type /* * Event types */ #define EV_SYN 0x00 /* 同步事件 */ #define EV_KEY 0x01 /* 按键事件 */ #define EV_REL 0x02 /* 相对事件 */ #define EV_ABS 0x03 /* 绝对事件 */ #define EV_MSC 0x04 #define EV_SW 0x05 #define EV_LED 0x11 #define EV_SND 0x12 #define EV_REP 0x14 #define EV_FF 0x15 #define EV_PWR 0x16 #define EV_FF_STATUS 0x17 #define EV_MAX 0x1f #define EV_CNT (EV_MAX+1) 每种输入设备，最后都必须有一个同步事件，按键事件指的是类似按钮或者键盘类的键值事件；绝对事件指的是产生的数据有最大值和最小值，比如重力传感器，陀螺仪之类的；相对事件指的是产生的数据是相对数值，比如鼠标产生的数据：下一个坐标是相对于之前的坐标的。 code 键码，数值与事件类型有关，如果是按键事件，键码就表示是哪一个按键；如果是绝对事件，键码就表示哪个坐标轴（ABS_X, ABS_Y）。 /* key类型code举例 */ #define KEY_RESERVED 0 #define KEY_ESC 1 #define KEY_1 2 #define KEY_2 3 #define KEY_3 4 #define KEY_4 5 #define KEY_5 6 #define KEY_6 7 #define KEY_7 8 #define KEY_8 9 #define KEY_9 10 #define KEY_0 11 #define KEY_MINUS 12 #define KEY_EQUAL 13 #define KEY_BACKSPACE 14 /* 相对事件类型code举例 */ /* * Relative axes */ #define REL_X 0x00 #define REL_Y 0x01 #define REL_Z 0x02 #define REL_RX 0x03 #define REL_RY 0x04 #define REL_RZ 0x05 #define REL_HWHEEL 0x06 #define REL_DIAL 0x07 /* 绝对事件类型code举例 */ /* * Absolute axes */ #define ABS_X 0x00 #define ABS_Y 0x01 #define ABS_Z 0x02 #define ABS_RX 0x03 #define ABS_RY 0x04 #define ABS_RZ 0x05 #define ABS_THROTTLE 0x06 #define ABS_RUDDER 0x07 /* 类似的 还有 Misc events LEDs etc.*/ value 键值，与事件类型以及键码有关，如果是按键事件，键码确定哪个按键，键值确定是按下还是抬起；如果是绝对事件，键码确定是哪个坐标轴，键值确定值是多少。 input_dev 在Linux内核中，input设备用input_dev结构体描述，定义在input.h中。 /* include/linux/input.h */ struct input_dev { const char *name; const char *phys; const char *uniq; struct input_id id; unsigned long evbit[BITS_TO_LONGS(EV_CNT)]; unsigned long keybit[BITS_TO_LONGS(KEY_CNT)]; unsigned long relbit[BITS_TO_LONGS(REL_CNT)]; unsigned long absbit[BITS_TO_LONGS(ABS_CNT)]; unsigned long mscbit[BITS_TO_LONGS(MSC_CNT)]; unsigned long ledbit[BITS_TO_LONGS(LED_CNT)]; unsigned long sndbit[BITS_TO_LONGS(SND_CNT)]; unsigned long ffbit[BITS_TO_LONGS(FF_CNT)]; unsigned long swbit[BITS_TO_LONGS(SW_CNT)]; unsigned int keycodemax; unsigned int keycodesize; void *keycode; int (*setkeycode)(struct input_dev *dev, int scancode, int keycode); int (*getkeycode)(struct input_dev *dev, int scancode, int *keycode); struct ff_device *ff; unsigned int repeat_key; struct timer_list timer; int sync; int abs[ABS_MAX + 1]; int rep[REP_MAX + 1]; unsigned long key[BITS_TO_LONGS(KEY_CNT)]; unsigned long led[BITS_TO_LONGS(LED_CNT)]; unsigned long snd[BITS_TO_LONGS(SND_CNT)]; unsigned long sw[BITS_TO_LONGS(SW_CNT)]; int absmax[ABS_MAX + 1]; int absmin[ABS_MAX + 1]; int absfuzz[ABS_MAX + 1]; int absflat[ABS_MAX + 1]; int (*open)(struct input_dev *dev); void (*close)(struct input_dev *dev); int (*flush)(struct input_dev *dev, struct file *file); int (*event)(struct input_dev *dev, unsigned int type, unsigned int code, int value); struct input_handle *grab; spinlock_t event_lock; struct mutex mutex; unsigned int users; int going_away; struct device dev; struct list_head h_list; struct list_head node; }; 注意： 一般不直接填充该结构，一个位表示一种功能，通常采用set_bit()函数间接填充。 例 /* 1. 动态分配核心数据结构*/ struct input_dev * My_input_dev = input_allocate_device(); /* 2. 填充事件 */ // 按键事件 set_bit(EV_KEY, My_input_dev->evbit); // 字母Q键 set_bit(KEY_Q, My_input_dev->keybit); /* 3. 向内核注册一个input_dev */ input_register_device(My_input_dev); /* 4. 在MODULE_EXIT中释放核心数据结构 */ input_unregister_device(My_input_dev); input_free_device(My_input_dev); /* 5. 在中断服务函数中 上报事件 */ input_report_key(My_input_dev, code, value); /* 此外还有类似的 input_report_rel() , input_report_abs()等函数。 */ input_sync(My_input_dev); /* 6. 在应用程序中接收事件 */ fd = open(\"/dev/input/event1\", O_RDWR); read(fd, &My_event, siezeof(My_event)); switch(My_event.type) { case EV_KEY: switch(My_event.code) { case KEY_Q: ... } } 编程实例 一个简单的按键驱动实例代码 /* simple_input_btn.c */ #include #include #include #include #include struct input_dev *btn_input; static int irqno ; irqreturn_t button_interrupt(int irq, void *dev_id) { printk(\"--------%s-----------\\n\", __FUNCTION__); // 获取数据 int value = gpio_get_value(S5PV210_GPH0(1)); if(value) { //抬起 //将数据上报给用户 //参数1---哪个设备上报的 //参数2---上报那种数据类型 //参数3---上报码值 //参数4--按键的状态/值 //input_report_key(btn_input, KEY_DOWN, 0); input_event(btn_input, EV_KEY, KEY_DOWN, 0); //最后要有一个结束/同步 input_sync(btn_input); }else{ //按下 input_event(btn_input, EV_KEY, KEY_DOWN, 1); input_sync(btn_input); } return IRQ_HANDLED; } static int __init simple_btn_input_init(void) { int ret; /* a, 分配一个input device对象 b, 初始化input device对象 c, 注册input device对象 d, 硬件初始化 */ //a, 分配一个input device对象 btn_input = input_allocate_device(); if(btn_input == NULL) { printk(\"input_allocate_device error\\n\"); return -ENOMEM; } //b, 初始化input device对象 //该设备能够产生哪种数据类型---EV_KEY表示产生按键数据 //btn_input->evbit[0] |= BIT_MASK(EV_KEY); set_bit(EV_KEY, btn_input->evbit); //能够产生哪个按键---比如能够产生下键 KEY_DOWN, KEY_ESC // btn_input->keybit[108/32] |= 1keybit[BIT_WORD(KEY_DOWN)] |= BIT_MASK(KEY_DOWN); set_bit(KEY_DOWN, btn_input->keybit); //c, 注册input device对象 ret = input_register_device(btn_input); if(ret != 0) { printk(\"input_register_device error\\n\"); goto err_free_input; } //d, 硬件初始化--申请中断 irqno = IRQ_EINT(1); ret = request_irq(irqno, button_interrupt, IRQF_TRIGGER_FALLING|IRQF_TRIGGER_RISING, \"key_input_eint1\", NULL); if(ret != 0) { printk(\"request_irq error\\n\"); goto err_unregister; } return 0; err_unregister: input_unregister_device(btn_input); err_free_input: input_free_device(btn_input); return ret; } static void __exit simple_btn_input_exit(void) { free_irq(irqno, NULL); input_unregister_device(btn_input); input_free_device(btn_input); } module_init(simple_btn_input_init); module_exit(simple_btn_input_exit); MODULE_LICENSE(\"GPL\"); 对应的应用测试程序 #include struct input_event key_event; int main(int argc, char ** argv) { int fd = open(argv[1], O_RDWR); while(1) { read(fd, &key_event, siezeof(struct input_event)); switch(key_event.type) { case EV_KEY: switch(key_event.code) { case KEY_DOWN: if (key_event.value) printf(\"key DOWN press\\n\"); else printf(\"key DOWN release\\n\"); break; } break; } } return 0; } Copyright © Yuanye.Ma 2020-2021 all right reserved，powered by Gitbook文件修订时间： 2023-04-02 10:05:52 "},"_posts/LDD/Kobject和sysfs.html":{"url":"_posts/LDD/Kobject和sysfs.html","title":"Kobject和sysfs","keywords":"","body":"Kobject和sysfs kobject、ktype、kset 以及其相互关系 kobject /* include/linux/kobject.h */ struct kobject { const char *name; struct list_head entry; struct kobject *parent; // 指向kobject的父对象，这样一来kobject就会在内核中构造一个对**象层次结构** struct kset *kset; // kset可以把kobject集中到一个集合里， struct kobj_type *ktype; // ktype可以描述集合中kobject所共有的特性； struct kernfs_node *sd; // 指向sysfd_dirent结构体，该结构体在sysfs内部就是一个表示kobject的inode结构体 struct kref kref; // 提供引用计数 #ifdef CONFIG_DEBUG_KOBJECT_RELEASE struct delayed_work release; #endif unsigned int state_initialized:1; unsigned int state_in_sysfs:1; unsigned int state_add_uevent_sent:1; unsigned int state_remove_uevent_sent:1; unsigned int uevent_suppress:1; }; ktype ktype用于描述一族kobject所具有的普遍特性 /* include/linux/kobject.h */ struct kobj_type { void (*release)(struct kobject *kobj); // 指向在kobject引用计数减至零时，要被调用的析构函数 const struct sysfs_ops *sysfs_ops; // 指向sysfs_ops结构体，描述了sysfs文件读写时操作。 struct attribute **default_attrs; // 指向attribute结构体数组，这些结构体定义了该kobject的默认属性，这些属性就是sysfs中的文件，数组中的最后一项为NULL const struct attribute_group **default_groups; const struct kobj_ns_type_operations *(*child_ns_type)(struct kobject *kobj); const void *(*namespace)(struct kobject *kobj); void (*get_ownership)(struct kobject *kobj, kuid_t *uid, kgid_t *gid); }; kset kset表示很多kobject的集合，而ktype描述kset中kobject所共有的特性。具有相同ktype的kobject可以被分组到不同的kset。 linux内核中，只有少数一些的ktype，却有多个kset。 /* include/linux/kobject.h */ /** * struct kset - a set of kobjects of a specific type, belonging to a specific subsystem. * * A kset defines a group of kobjects. They can be individually * different \"types\" but overall these kobjects all want to be grouped * together and operated on in the same manner. ksets are used to * define the attribute callbacks and other common events that happen to * a kobject. * * @list: the list of all kobjects for this kset * @list_lock: a lock for iterating over the kobjects * @kobj: the embedded kobject for this kset (recursion, isn't it fun...) * @uevent_ops: the set of uevent operations for this kset. These are * called whenever a kobject has something happen to it so that the kset * can add new environment variables, or filter out the uevents if so * desired. */ struct kset { struct list_head list; // 连接集合中所有的kobject对象 spinlock_t list_lock; // 用于保护链表元素的自旋锁 struct kobject kobj; // 内嵌一个kobject对象，作为集合中其他kobject的基类 const struct kset_uevent_ops *uevent_ops; // 指向一个结构体，用于处理集合中kobject对象的热插拔操作 } __randomize_layout; 基本操作 kobject基本操作 void kobject_init(struct kobject *kobj, struct kobj_type *ktype); // 用例 struct kobject * kobj; kobj = kmalloc(sizeof(kobj), GFP_KERNEL); if (!kobj) return -ENOMEM; memset(kobj, 0, sizeof(kobj)); kobj->kset = my_kset; kobject_init(kobj, my_ktype); 更简单的接口 struct kobject *kobject_create(void); 引用计数基本操作 struct kobject * kobject_get(struct kobject *kobj); // 增加引用计数 void kobject_put(struct kobject *kobj); // 减少引用计数 sysfs sysfs文件系统是一个位于内存中的虚拟文件系统，它提供了kobject对象层次结构的视图。帮助用户能以一个简单文件系统的方式来观察系统中各种设备的拓扑结构。借助属性对象，kobject可以以文件的形式，导出内核变量提供给用户读取或者写入。 sysfs中添加和删除目录（kobject） 仅仅初始化kobject是不能自动将其导出到sysfs中的，需要调用以下函数才行。 #include int kobject_add(struct kobject *kobj, struct kobject *parent, const char *fmt, ...); // kobj : 要导出到sysfs的kobject对象 // parent : 其父对象，即sysfs中的父目录 // fmt : kobj在sysfs中的目录名，支持printf标准格式 struct kobject * kobject_create_and_add(const char *name, struct kobject *parent); // 直接接受字符串指针作为目录名 void kobject_del(struct kobject *kobj); // 从sysfs中删除指定的kobj //函数都定义在lib/kobject.c中 kobject在sysfs中的位置，取决于kobject在对象层次结构中的位置。 如果kobject的父指针被设置，则sysfs中kobject将被映射为其父目录下的子目录； 如果parent指针没有设置，则kobject将被映射为kset-kobj中的子目录； 如果给定的kobject中parent和kset字段都没有被设置，则认为kobject没有父对象，会映射为sysfs根目录的子目录。 向sysfs中添加文件 默认属性 默认文件由kobject和kset中的ktype字段提供。因此所有具有相同类型的kobject在sysfs中对应的目录下都有相同的默认文件集合。 /* include/linux/kobject.h */ struct kobj_type { void (*release)(struct kobject *kobj); // 指向在kobject引用计数减至零时，要被调用的析构函数 const struct sysfs_ops *sysfs_ops; // 指向sysfs_ops结构体，描述了sysfs文件读写时操作。 struct attribute **default_attrs; // 指向attribute结构体数组，这些结构体定义了该kobject的默认属性，这些属性就是sysfs中的文件，数组中的最后一项为NULL }; kobj_type结构体有一个default_attrs, 它是一个attribute结构体数组，这些属性负责将内核数据映射城sysfs中的文件。 /* linux/sysfs.h */ struct attribute { const char *name; /* 属性名字，及sysfs中文件名字 */ umode_t mode; /* 文件对应的权限 */ #ifdef CONFIG_DEBUG_LOCK_ALLOC bool ignore_lockdep:1; struct lock_class_key *key; struct lock_class_key skey; #endif }; default_attrs列出了默认属性，sysfs_ops字段则描述了如何使用他们。 struct sysfs_ops { ssize_t (*show)(struct kobject *, struct attribute *, char *); /* 读取sysfs文件时调用该函数 */ ssize_t (*store)(struct kobject *, struct attribute *, const char *, size_t); /*写入sysfs文件时调用该函数*/ }; 创建/删除新属性 /* fs/sysfs/file.c */ int sysfs_create_file(struct kobject *kobj, const struct attribute *attr); int sysfs_remove_file(struct kobject *kobj, const struct attribute *attr); /* fs/sysfs/symlink.c */ int sysfs_create_link(struct kobject *kobj, struct kobject *target, char *name); int sysfs_remove_link(struct kobject *kobj, char *name); 内核事件 int kobject_uevent(struct kobject *kobj, enum kobject_action action); // kobj : 发送信号的kobject对象 // 事件类型 enum kobject_action { KOBJ_ADD, KOBJ_REMOVE, KOBJ_CHANGE, KOBJ_MOVE, KOBJ_ONLINE, KOBJ_OFFLINE, KOBJ_BIND, KOBJ_UNBIND, }; Copyright © Yuanye.Ma 2020-2021 all right reserved，powered by Gitbook文件修订时间： 2023-04-02 10:05:52 "},"_posts/LDD/关于设备树.html":{"url":"_posts/LDD/关于设备树.html","title":"关于设备树","keywords":"","body":"Linux驱动之设备树（华清创客学院） Open Firmware Device Tree -- 开发固件设备树 描述包括CPU的数量、类别、内存基地址和大小、总线和桥、外设连接、中断控制器、GPIO控制器、Clock等。 ARM Linux中，一个.dts文件对应一个ARM的machine，放置在内核的arch/arm/boot/dts/。 Device Tree由一系列节点（node）和其属性（property）组成，而节点本身可以包含子节点，属性是由成对的（key-value）构成。 DTS源文件由DTC编译为DTB文件，由Bootloader传递给内核，对其进行解析展开(Flattened)，从而产生硬件的拓扑图，在编程的过程中，可以直接通过系统提供的接口，获取设备树中的节点和属性信息。 Device Tree解决的问题 在Linux 2.6中arch/arm/plat-xxx和arch/arm/mach-xxx中充斥着大量垃圾代码。如，板上的platform设备，resource i2c_board_info spi_board_info 以及各种硬件platform_data。这些描述板级细节的代码对内核而言都是垃圾。 编译设备树 DTC是编译设备树源文件.dts编译为.dtb的工具。 DTC的源码位于scripts/dtc/,在Linux内核使能了Device Tree的情况下编译内核时，dtc会被编译出来。 在arch/arm/boot/dts/Makefile中，描述了当某种SOC被选中后，哪些.dtb文件会被编译出来。 例 dtb-$(CONFIG_ARCH_EXYNOS)+=exynos4412-smdk4412.dtb exynos4412-tiny4412.dtb make dtbs 缩写名词解释 DT : Device Tree FDT : Flattened Device Tree OF : Open Firmware DTS : Device Tree Source DTSI : Device Tree Source Include DTB : Device Tree Blob DTC : Device Tree Compiler 设备树语法 节点 属性 根节点 compatible属性 指定了系统的名称，是一个字符串列表，实际在代码中可以用于进行匹配，至少包含一个，形式的字符串，重要的是要指定一个确切的设备，并且包括制造商的名字，以避免命名空间冲突。例如：compatible= \"acme, coyotes-revenge;\" reg属性 reg的组织形式为 reg = 其中每一组address length表明了设备使用的一个地址范围。 #address-cells和#size-cells属性 #address-cells = ; 表示address字段的长度为1 #size-cells = ; 表示length字段的长度为1 external-bus{ #address-cells = #size-cells = ; ethernet@0,0{ compatible = \"smc, smc91c111\"; reg = ; // address占两个cells, length占1个cells }; } 模板 /{ node1{ a-string-property = \"A String\"; a-string-list-property = \"first string\", \"second string\"; a-byte-data-property = [0x01 0x02 0x03 0x04]; child-node1 { dirst-child-property; second-child-property=; a-string-property=\"Hello, world\"; }; child-node2{ }; }; node2{ an-empty-property; a-cell-property=; /* each number (cell) is a uint32 */ child-node1{ mixed-property = \"a string\", [01 23 45 67], ; }; }; } 中断信息 interrupt-controller : 一个空的属性，定义该节点作为一个接受中断信号的设备 #interrupt-cells : 中断控制器的属性，声明该控制器下中断的cell个数 interrupt-parent : 设备节点属性，包含一个中断控制器的phandle，没有该属性的节点从父节点继承。 interrupts : 设备节点属性，包含一个中断指示符列表，对应每个中断信号。 例 /{ compatible = \"acme, coyotes-revenge\"; #address-cells = ; #size-cells = ; interrupt-parent=; /* 声明此节点以及所有子节点的中断控制器节点 */ serial@101f0000{ compatible = \"arm, pl011\"; reg = ; interrupts = ; /* 对于arm架构，标志位具体含义Documentation/devicetree/bindings/arm/gic.txt */ }; intc： interrupt-controller@10140000{ compatible = \"arm, pl190\"; reg = ; interrupt-controller; /* 声明此节点是一个interrupt-controller */ #interrupt-cells = ; }; } 对于arm架构，标志位具体含义/Documentation/devicetree/bindings/interrupt-controller/arm,gic.txt,例如 - interrupt-controller : Identifies the node as an interrupt controller - #interrupt-cells : Specifies the number of cells needed to encode an interrupt source. The type shall be a and the value shall be 3. The 1st cell is the interrupt type; 0 for SPI interrupts, 1 for PPI interrupts. The 2nd cell contains the interrupt number for the interrupt type. SPI interrupts are in the range [0-987]. PPI interrupts are in the range [0-15]. The 3rd cell is the flags, encoded as follows: bits[3:0] trigger type and level flags. 1 = low-to-high edge triggered 2 = high-to-low edge triggered (invalid for SPIs) 4 = active high level-sensitive 8 = active low level-sensitive (invalid for SPIs). bits[15:8] PPI interrupt cpu mask. Each bit corresponds to each of the 8 possible cpus attached to the GIC. A bit set to '1' indicated the interrupt is wired to that CPU. Only valid for PPI interrupts. Also note that the configurability of PPI interrupts is IMPLEMENTATION DEFINED and as such not guaranteed to be present (most SoC available in 2014 seem to ignore the setting of this flag and use the hardware default value). 常用OF API OF提供的函数主要集中在drivers/of/目录下，有address.c base.c device.c fdt.c irq.c platform.c等等 #include /*根据device_node结构的full_name参数，在全局链表of_allnodes中，查找合适的device_node*/ struct device_node *of_find_node_by_path(const char *path); /*根据property结构的name参数，在指定的device_node中查找合适的property*/ struct property *of_find_property(const struct device_node *np, const char *name, int *lenp); /*根据compat参数与device node的compatible匹配，返回匹配度*/ int of_device_is_compatible(const struct device_node *device, const char *compat) /*获得父节点的device node*/ struct device_node *of_get_parent(const struct device_node *node); /*根据属性名propname, 读出该属性的数组中sz个属性值给out_values*/ int of_property_read_u32_arry(const struct device_node *np, const char *propname, u8 *out_values, size_t sz); /*读取该设备的第index个irq号*/ #include unsigned int irq_of_parse_and_map(struct device_node *dev, int index); 设备树实战 // 将以下内容插入到dts文件中，比如 arch/arm/boot/dts/exynos4412-fs4412.dts test_node@12345678 { compatible = \"test, farsight\"; reg = ; testprop, mytest; // 空属性 test_list_string = \"red fish\", \"bule fish\"; interrupt-parent = ; interrupts = ; }; // 编译dts $ make dtbs // 拷贝到开发板，并由uboot加载后 $ cd /proc/device-tree $ ls test_node@12345678 //可以看到设备树中的每一个属性都是一个文件， 属性值是文件内容 通过代码获得节点的信息 static irqreturn_t key_irq_handler(int irqno, void * data) { return IRQ_HANDLED; } # include static int __init led_drv_init(void) { /*获取节点的所有信息*/ /*a.获取节点*/ struct devoce_node *np = NULL; np = of_find_node_by_path(\"/test_node@12345678\"); if (np) { printk(\"find test node ok\\n\"); } else { printk(\"find test node failed!\\n\"); } /* 还可以查看node的其他信息 struct device_node { const char *name; const char *type; phandle phandle; char *full_name; struct property *properties; struct property *deadprops; /* removed properties */ struct device_node *parent; struct device_node *child; struct device_node *sibling; struct device_node *next; /* next device of same type */ struct device_node *allnext; /* next in list of all nodes */ struct proc_dir_entry *pde; /* this node's proc directory */ struct kref kref; unsigned long _flags; void *data; #if defined(CONFIG_SPARC) char *path_component_name; unsigned int unique_id; struct of_irq_controller *irq_trans; #endif }; */ /*b.获取节点的属性*/ struct property *prop = NULL; prop = of_find_property(np, \"compatible\", NULL); if (prop) { printk(\"find compatible ok : %s\\n\", prop->value); } else { printk(\"find test node failed!\\n\"); } /*c.读取属性中的整数数组*/ #define U32_DATA_LEN 4 u32 regdata[U32_DATA_LEN] = {0}; int ret = 0; ret = of_property_read_u32_array(np, \"reg\", regdata, U32_DATA_LEN); if (!ret) { int i; for (i=0; i int irqno = irq_of_parse_and_map(np, 0); request_irq(irqno, key_irq_handler, IRQF_TRIGGER_FALLING, \"key_irq\", NULL); } module_init(led_drv_init); struct of_device_id of_match_id[] = { {.compatible = \"test, farsight\"} // 和设备树中节点的compatible保持一致 }; struct platform_driver led_pdrv = { .probe = led_pdrv_probe, .remove = led_pdrv_remove, .driver = { .name = \"samsung led_drv\", .of_match_table = of_match_id,// 设备树用此方法匹配设备和驱动，不再用.id_table }, // .id_table = led_id_table, }; 韦东山讲设备树 此部分是对前边华清创客学院所讲内容的一个补充，重点内容有 内核启动时对设备树的解析； dtb文件转换为device_node以及device_node转换为 platform_device的过程； 平台设备和平台驱动的匹配在其他文章中有总结过，这里主要需要注意platform_match函数中关于设备树匹配的方法； 目前只是简单听了一遍视频课，后续抽时间对照代码再仔细研究以上内容。 韦东山设备树的第四课是u-boot对设备树的支持，留到研究u-boot时再细究；第五课是中断系统中的设备树这一部分涉及到内核处理中断的方式，比较复杂，也留到以后再研究。 第二课 设备树的规范【dts和dtb】 DTS文件布局 / { [property devinitions] [child nodes] }; Property格式：[label:] property_name = property_value; //也可以没有值，为空属性 value 有三种类型 ： 32位的数组 “hello” : 字符串 [0x11 0x22 0x33] : byte string, 十六进制表示一个或者多个byte，一个byte用2位十六进制表示，byte之间的空格可以省略 三种类型可以随意组合为属性的值，不同类型之间用逗号隔开 Devicetree node格式 [label:] node-name[@unit-address] { [properties definitions] [chile nodes] } 特殊的、默认的属性： a. 根节点 ​ #address-cells : 在它的子节点的reg属性中，使用多少个u32整数来描述地址（address） ​ #size-cells :在它的子节点的reg属性中，使用多少个u32整数来描述地址长度(length) ​ compatible : 定义一些列的字符串，用来指定内核中哪个machine_desc可以支持本设备，即这个板子兼容哪些平台 ​ model : 如果两款板子配置基本一致，他们的compatible是一样的，那么就通过model来分辨这两块板子 b. /memory ​ device_type=\"memory\"; ​ reg : 用来指定内存的 c. /chosen ​ bootargs 内核command line参数，跟u-boot中设置的bootargs作用一样。 d. /cpu/cpu* ​ device_type=\"cpu\" ​ reg : 表明自己是哪一个cpu 引用其他节点 a. phandle: // 节点的phandle属性，它的取值必须是唯一的（不能和其他phandle值一样） ​ pic@10000000 { ​ phandle = ; ​ interrupt-controller; // 声明自己是一个中断控制器 ​ }; ​ another_device_node{ ​ interrupt-parent = ; //使用phandler值为1来引用上述节点 ​ }; b. label: ​ PIC: pic@10000000 { ​ phandle = ; ​ interrupt-controller; // 声明自己是一个中断控制器 ​ }; ​ another_device_node{ ​ interrupt-parent = ; //引用lable为PIC的节点作为中断控制器 ​ }; 如果dtsi中声明的某节点属性不满足需求，可以直接在dts文件中覆盖声明 如在 dtsi文件中声明了LED节点，但是管角和实际使用不同，可以直接引用LED的label并覆盖声明 &LED { // LED为dtsi文件中的一个节点label pin = ; }; //这种方法不能写在根节点下 第二种覆盖声明的方法是直接在/根节点下重新覆盖声明节点 /{ led{ pin= ; }; }; DTB格式 内核文档：/Documentation/devicetree/booting-without-of.txt /* ------------------------------ ---- base -> | struct boot_param_header | // 指示各个段的偏移地址 ------------------------------ | (alignment gap) (*) | ------------------------------ | memory reserve map | // ------------------------------ | (alignment gap) | ------------------------------ | | | device-tree structure | | | ------------------------------ | (alignment gap) | ------------------------------ | | | device-tree strings | | | -----> ------------------------------ | | --- (base + totalsize) */ struct boot_param_header { u32 magic; /* magic word OF_DT_HEADER 0xd00dfeed */ u32 totalsize; /* total size of DT block */ u32 off_dt_struct; /* offset to structure */ u32 off_dt_strings; /* offset to strings */ u32 off_mem_rsvmap; /* offset to memory reserve map*/ u32 version; /* format version */ u32 last_comp_version; /* last compatible version */ /* version 2 fields below */ u32 boot_cpuid_phys; /* Which physical CPU id we're booting on */ /* version 3 fields below */ u32 size_dt_strings; /* size of the strings block */ /* version 17 fields below */ u32 size_dt_struct; /* size of the DT structure block */ }; Along with the constants: /* Definitions used by the flattened device tree */ #define OF_DT_HEADER 0xd00dfeed /* 4: version, 4: total size */ #define OF_DT_BEGIN_NODE 0x1 /* Start node: full name*/ #define OF_DT_END_NODE 0x2 /* End node */ #define OF_DT_PROP 0x3 /* Property: name off, size, content */ #define OF_DT_END 0x9 /* 整个structure block结束*/ All values in this header are in big endian format(大端方式), the various fields in this header are defined more precisely below. All \"offset\" values are in bytes from the start of the header; that is from the physical base address of the device tree block. Here's the basic structure of a single node: * token OF_DT_BEGIN_NODE (that is 0x00000001) // + 节点名字，表示节点开始 * for version 1 to 3, this is the node full path as a zero terminated string, starting with \"/\". For version 16 and later, this is the node unit name only (or an empty string for the root node) * [align gap to next 4 bytes boundary] * for each property: * token OF_DT_PROP (that is 0x00000003) //属性开始 * 32-bit value of property value size in bytes (or 0 if no value) // value长度，字节 * 32-bit value of offset in string block of property name // 属性名字在string block中的偏移 * property value data if any // 属性的值 * [align gap to next 4 bytes boundary] //4字节对齐 * [child nodes if any] * token OF_DT_END_NODE (that is 0x00000002) ​ Device tree \"strings\" block ​ In order to save space, property names, which are generally redundant, are stored separately in the \"strings\" block. This block is simply the whole bunch of zero terminated strings for all property names concatenated together. The device-tree property definitions in the structure block will contain offset values from the beginning of the strings block. 尝试自己分析dtb文件。 第三课 内核对设备树的处理 1. 从源头分析：内核head.S文件对dtb文件的简单处理 bootloader启动内核时，会设置r0, r1, r2三个寄存器 r0 设置为0 r1 设置machine_id , 使用设备树时该参数没有被使用, 传递给了__machine_arch_type r3 设置ATAGS或者DTB的启始地址 , 传递给了__atags_pointer a.__lookup_process_type ： 使用汇编指令读取CPUID根据该ID找到对应的proc_info_list结构体，该结构体种含有这类CPU的初始化函数和信息； b. __vet_atags ： 判断是否存在可用的ATAGS或者DTB； c. __create_page_tables : 创建页表，即创建虚拟地址和物理地址的映射关系； d. __enable_mmu : 使能MMU e. __mmap_switched ：切换物理地址为虚拟地址 f. 把bootloader传入的r2寄存器中的参数，保存到变量__atags_pointer中 g. 调用C函数start_kernel 2. 对设备树中平台信息的处理 dts文件中“根节点”会声明兼容什么样的machine_desc /{ model = \"SMDK2440\"; compatible = \"samsung, smdk2440\", \"samsung, smdk2410\" //声明一系列兼容的单板，依兼容性高低排列。 } 内核中的每一个machine_desc，同样也用字符串表明自己支持哪些单板 static const char *const smdk2440_dt_compt[] __initconst = { \"samsung, smdk2440\", NULL }; MACHINE_START(S3C2440, \"smdk2440\") ... .dt_compat = smdk2440_dt_compt, //这也是一个字符串数组 ... MACHINE_END 假设有多个machine_desc和dts符合，该选择哪一个? 看看代码执行过程 start_kernel // init/main.c setup_arch(&command_line); // arch/arm/kernel/setup.c mdesc = setup_machine_fdt(__atags_pointer); // arch/arm/kernel/devtree.c early_init_dt_verify(phys_to_virt(dt_phys)) //此函数检查__atags_pointer是否有DTB头 init_boot_params = params; //如果是DTB，则将DTB虚拟地址保存为全局变量 mdesc = of_flat_dt_match_machine(mdesc_best, arch_get_next_mach); //找到最匹配的mdesc, arch_get_next_mach是一个函数指针，此函数会依次取出mdesc并返回m->dt_compat while((data==get_next_compat())) { score = of_flat_dt_match(); if (score>0 && score 3. 对设备树运行时配置信息的处理 在上一节中找到最匹配的mdesc后early_init_dt_scan_nodes()函数中，处理以下内容。 a. /chosen中的bootargs属性值，存入全局变量boot_command_line : b. 确定根节点的#address-cells 和#size-cells存入全局变量dt_root_addr_cells和dt_root_size_cells; c. 解析/memory中的reg属性，提取出base,size最终调用memblock_add(base,size); 4. dtb文件转换为device_node 内存中如何保留DTB区域 start_kernel(); setup_arch(); arm_memblock_init(); early_init_fdt_reserve_self(); /* 把DTB所占区域保留下来，即调用 memblock_reserve() */ early_init_dt_reserve_memory_arch(); /* 根据dtb中的memreserve信息调用memblock_reserve() */ early_init_fdt_scan_reserved_mem(); 设备树节点展开的样子 struct device_node { const char *name; // 来自节点中的name属性，如果没有该属性，则设为NULL const char *type; // 来自节点中的device_type属性，如果没有该属性，则设为NULL }; struct property{ char *name; int length; value; next; }; // 画一下 结构之间的关系 unflatten_device_tree(void) // arch/arm/kernel/setup.c a. 在DTB文件中 ​ 每一个节点都以TAG(FDT_BEGIN_NODE, 0x00000001)开始，节点内部可以嵌套其他节点； ​ 每一个属性都以TAG(FDT_PROP, 0x00000003)开始； b. 每一个节点都转换为struct device_node结构体， 每一个属性都转换为struct property结构体； 函数调用过程 5. device_node转换为platform_device dts->dtb->device_node->platform_device 两个问题： a. 哪些device_node可以转换成platform_device ​ 必须包含compatible属性 b. 怎么转换？ ​ platform_device结构体中的resource数组，表示设备所需的资源，它来自于device_node的reg和interrupts属性。 platform_device.dev.of_node指向device_node可以通过它来获取其他属性。 ​ 函数调用过程 of_platform_default_populate_init 此函数被编译到initcall3段，在内核启动时被调用 start_kernel reset_init(); pid = kernel_thread(kernel_init, NULL, CLONEFS) kernel_init kernel_init_freeable(); do_basic_setup(); do_initcalls(); for (level=0; level 6. 平台设备和平台驱动的匹配 匹配函数是platform_bus_type.match即platform_match a. 比较platform_devive.driver_override和platform_driver.drv->name b. 比较platform_device.dev.of_node的compatible属性和platform_driver.drv->of_match_table c. 比较platform_device.name和platform_driver.id_table d. 比较platform_device.name和platform_driver.drv->name 有一个匹配成功，则匹配成功。 Copyright © Yuanye.Ma 2020-2021 all right reserved，powered by Gitbook文件修订时间： 2023-04-02 10:05:52 "},"_posts/OS/2019-07-05-X86汇编.html":{"url":"_posts/OS/2019-07-05-X86汇编.html","title":"2019-07-05-X86汇编","keywords":"","body":"X86汇编 在网上无意间看到“编程达人”的一个讲汇编的视频，觉得讲的挺好的，刚好我也一直没学明白这个东西，然后就花了半天时间看完了，看到头昏脑涨就记住了下边这些东西。 通用寄存器 32位 16位 8位 EAX AX AL EBX BX BL ECX CX CL EDX DX DL ESP SP AH EBP BP CH ESI SI DH EDI DI BH mov eax, 1 使用内存 1.把立即数写入内存 mov byte ptr ds:[0018FFF0], 1 # 将立即数1 写入内存地址[0018FFF0]中，写入长度为一个字节 2.把寄存器的值写入内存 mov DWORD ptr ds:[0018FFF0], eax # 将立即数1 写入内存地址[0018FFF0]中，写入长度为一个字节 3.把内存中的值写入寄存器 mov EAX, BWORD PTR DS:[0018FFF0] 4.内存到内存需要特殊的指令后边会有 内存地址的五种表示形式 形式一： [立即数] 形式二： [reg] reg代表八个通用寄存器中的任何一个 mov dword ptr ds:[eax], 12345678 # 其中eax中保存内存的地址 形式三：[reg+立即数] mov dword ptr ds:[eax+4], 12345678 # 其中eax+4中保存内存的地址 形式四：[reg+reg*{1,2,4,8}] mov eax, 13ffc4 mov ecx, 2 mov dword ptr ds:[eax+ecx*4] 形式五：[reg+reg*{1,2,4,8}+立即数] 存储模式 大端模式：数据高位在低地址，数据低位在高地址 小端模式：数据低位在低地址 0x1A2C3E4F的小端模式 地址 数字 0x00 4F 0x01 3E 0x02 2C 0x03 1A 80x86一般都是小端模式 汇编指令 基础指令 1.mov 格式 解释 mov r/m8, r8 r代表通用寄存器，8代表是8位的 mov r/m16, r16 m代表内存 mov r/m32, r32 mov r8, r/m8 mov r16, r/m16 mov r32, r/m32 mov r8, imm8 imm8 代表8位立即数 mov r16, imm16 mov r32, imm32 2.ADD 格式 解释 ADD r/m8, imm8 中间那个表示目的地址 ADD r/m32, r32 ADD r32, r/m32 3.SUB和add指令类似 4.AND 5.OR 6.XOR 7.NOT 连续复制数据指令 8.MOVS 移动数据， 内存-内存 指令 简写 MOVS BYTE PTR ES:[EDI], BYTE PTR DS:[ESI] MOVSB MOVS WORD PTR ES:[EDI], WORD PTR DS:[ESI] MOVSW MOVS DWORD PTR ES:[EDI], DWORD PTR DS:[ESI] MOVSD EDI：存储一个地址，目标地址 ESI：存储的是一个地址，源数据的地址 EDI和ESI内的地址会根据EFI的第十位DF的值改变，0 ：自增， 1：自减。 9.STOS： 将AL/AX/EAX的值存储到[EDI]指定的内存单元 格式 解释 简写 STOS BYTE PTR ES:[EDI] 将AL中的内容写到[EDI]指向的内存空间，EDI内的地址+1/-1(由DF位确定) STOSB STOS WORD PTR ES:[EDI] STOSW STOS DWORD PTR ES:[EDI] STOSD 10.REP : 按照计数寄存器（ECX）中指定的次数重复执行字符串指令 MOV ECX, 10 REP MOVS DWORD PTR ES:[EDI], DWORD PTR DS:[ESI] #或者 REP MOVSD 堆栈操作 ESP寄存器存储栈顶指针，从大地址逐渐减小，向低地址生长。 11.push : 向堆栈中压入数据，并修改esp的值。 格式 同义 PUSH r32 PUSH r16 PUSH m32 PUSH DWORD PTR DS:[18FFA4] PUSH m16 PUSH imm8/imm16/imm32 12.pop： 格式 同义 POP r32 POP r16 POP m32 POP m16 修改EIP的指令 EIP寄存器里边存储的是CPU下一时刻应该执行的指令。 13.jmp ：寄存器/立即数/内存地址14.call : 先push下一行地址，然后jmp，15.ret ： ADD ESP, 4; MOV EIP, [ESP-4]; 函数 函数调用 jmp 来执行函数 call 来调用函数 ret 返回call调用的函数 参数传递 寄存器传参：ecx,edx存储参数，eax存储返回值。 堆栈传参：先将参数压入堆栈，然后call调用函数，eax存储返回值。 push 1 push 2 call 41840d add esp, 8 #外平栈 41840d: mov eax, dword ptr ds:[esp+8] mov eax, dword ptr ds:[esp+4] ret # ret 8 内平栈 堆栈平衡： 如果要返回父程序，则当我们在堆栈中进行堆栈操作的时候，一定要保证在RET指令前，ESP指向的是我们压入栈中的地址。 如果通过堆栈传递参数，那么在函数执行完毕后，要平衡参数导致的堆栈变化。 ESP寻址 调用函数的时候要保存现场，函数返回前要恢复现场。 EBP寻址 EBP寄存器保存的是栈底的地址。 PUSH 1 PUSH 2 CALL 4183EE 4183EE: # 保存 PUSH EBP MOV EBP, ESP # 执行函数 MOV EAX, DWORD PTR SS:[EBP+8] ADD EAX, DWORD PTR SS:[EBP+C] # 准备返回 MOV ESP, EBP POP EBP # 返回 ret 8 JCC指令 标志寄存器EFL 31-12 11 10 9 8 7 6 5 4 3 2 1 0 OF DF IF TF SF ZF 0 AF 0 PF 1 CF 溢出 方向 中断使能 单步 符号 零 0 辅助进位 0 奇偶 1 进位 CF (Carry flag)：若算术操作产生的结果在最高有效位发生进位或者借位将其置1，反之清零。 PF（parity flag）: 如果结果的最低有效字节（最低位的一个字节）包含偶数个1，则置1，否则清零。 AF (Auxiliary Carry Flag):如果算术操作在结果的第三位发生进位或者借位则将该标志置1，主要应用于BCD运算。 ZF (Zero Flag): 如果运算的结果为0，则设置为1，否则清零，经常和cmp或者test等指令一起使用 mov eax, 100 mov ecx, 100 cmp eax, ecx # cmp指令相当于SUB指令，但是相减的结果不保存到第一个操作数中 test eax, eax # test指令相当于AND指令，但是与的结果并不保存在第一个操作数中 SF (Sign Flag): 该标志被设置为有符号整数的最高有效位，0为正，反之为负 OF (Overflow flag) ：溢出标志用于反映有符号数加减运算所得出结果是否溢出。 如果是无符号数运算，是否溢出看CF位； 有符号数看OF DF （Direction Flag）：这个方向标志控制串指令（MOVS, CMPS, SCAS, LODS以及STOS）。设置DF标志使得串指令自动递减，清除该标志则使得串指令自动递增。STD和CLD指令分别用于设置以及清除DF标志。 指令 意义 标志位 JE, JZ 结果为零则跳转（相等时跳转） ZF=1 JNE, JNZ 结果不为零则跳转（不相等时跳转） ZF=0 JS 结果为负则跳转 SF=1 ... ... ... 清华大学-汇编语言程序设计 基础知识 各类指令集初步 数制与整数表示 浮点数表示 X86汇编（AT&T风格） AT&T风格的汇编 movl source, dist 其中mov后边的l表示操作的字长， AT&T先原地址后目标地址 80x86计算机组成与保护模式 ​ 80386有三种工作模式： - 实模式：操作相当于一个可进行32位快速运算的8086 - 保护模式：是80x86设计目标全部达到的工作模式，通过对程序使用的存储区采用分段、分页的存储管理机制，以达到分级使用、互不干扰的保护目的。能为每个任务提供一台虚拟处理器，使每个任务单独执行，快速切换。 - 虚拟8086模式：保护模式下同时模拟多个8086处理器 X86指令系统与寻址方式 间接寻址 （R）: Mem[Reg[R]] 表示寄存器R指定内存的地址，例：movl (%ecx), %eax 基址+偏移量 寻址 D(R) : Mem[Reg[R]+D] 寄存器R指定内存起始地址，常数D给出偏移量， 例， movl 8(%ebp), %edx 表示把%ebp中取出一个数加上8作为内存的地址。 变址寻址 D(Rb, Ri, S) : Mem[Reg[Rb] + S* Reg[Ri] +D], 常量D给出地址偏移量，基址寄存器Rb是8个通用寄存器之一，索引寄存器Ri，S是比例因子，取值为1，2，4，8。 leal src, dist 指令将src表示的地址计算出来并传递给dist。 比如：leal (%edx, %edx, 2), %edx C与x86汇编 x86汇编语言程序格式与基本编程 AT&T和Intel汇编格式主要区别 在Intel格式中大多使用大写字母，而AT&T格式中都使用小写字母 在AT&T格式中，寄存器名上要加上“%”作为前缀，而Intel格式则不带前缀。 在AT&T格式中，指令的源操作数在前，目标在后，恰好和Intel格式完全相反。 在AT&T格式中，访问内存指令的操作数大小由操作码后缀来决定。用作操作码后缀的字母有b(表示8位)，w(表示16位), l(32位)。而在Intel格式中，则是在表示内存单元的操作数前面加上“BYTE PTR” , \"WORD PTR\", \"DWORD PTR\"来表示的。 AT&T中的立即数要加上\"$\"作为前缀，Intel格式不带前缀。 AT&T格式中，绝对转移或者调用指令jump/call的操作数，要加上\"*\"作为前缀。Intel格式不用。 间接寻址的一般格式：Intel格式：SECTION:[BASE + INDEX*SCALE+DISP];AT&T格式：section:disp(base, index, scale) 远程的转移指令和子程序调用指令的操作码名称，在AT&T中为\"ljmp\"和\"lcall\"，而在Intel格式中为“JMP FAR”和\"CALL FAR\"。 linux内核中的汇编语言规则 哈工大李治军操作系统 linux内核中使用了三种汇编 as86汇编：能产生16位代码的Intel 8086汇编。 主要构成了bootsect, setup代码。 GNU as汇编：能产生32位代码的AT&T系统V语法。主要构成保护模式代码。 GNU内嵌汇编：进程调度代码。 Copyright © Yuanye.Ma 2020-2021 all right reserved，powered by Gitbook文件修订时间： 2023-04-02 10:05:52 "},"_posts/OS/2020-01-15-x86汇编从实模式到保护模式实验.html":{"url":"_posts/OS/2020-01-15-x86汇编从实模式到保护模式实验.html","title":"2020-01-15-x86汇编从实模式到保护模式实验","keywords":"","body":"x86汇编从实模式到保护模式实验 实验一 实验环境：MacOS High Sierra 安装nasm nasm是一个开源的汇编语言编译器，可以将汇编代码编程成x86平台可以执行的二进制代码 # 安装homebrew ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" /dev/null # 安装nasm brewinstall nasm Vim 编辑器--用于编辑代码 xxd 命令可以以二进制或者十六进制的形式查看二进制文件，配合vim可以当做十六进制查看器使用。 vim test.bin # 输入 :%!xxd 可以十六进制形式查看 # xxd -r 可以写二进制文件 写入代码，并编译 vim test.asm # 粘贴写入代码 nasm -f bin -o test.bin test.asm # 编译生成二进制文件 创建虚拟机镜像，并启动虚拟机查看实验结果 # 创建软盘镜像 dd if=./test.bin of=os.img count=1 bs=1440k # bs：一个块多少个字节 count：多少个块 软盘大小1.44MB 打开virtualbox->创建虚拟机->操作系统类型：Other->Other unknow -> 不要硬盘。 设置虚拟机->存储->注册->选中上边创建的os.img。开启虚拟机。引导设置为软盘 此外可以通过以下方式将img转换为vdi的硬盘 qemu-img convert -f raw -O vpc ./test.img ./test.vdi # 此时需要将虚拟机的引导方式修改为硬盘启动 # 也可以通过以下命令转换，但是磁盘文件太小是会出错 VBoxManage convertdd test.img os.vdi # convertdd指将raw硬盘转换为vdi硬盘 创建一个虚拟硬盘，并写入MBR dd if=./test.bin of=./os.img bs=512 count=1 dd if=/dev/zero of=./os.img seek=1 bs=512 count=2000000 # 创建了一个大小为1G的硬盘，seek是跳过多少块再开始写 VBoxManage convertdd os.img os.vdi 然后将此硬盘镜像设置为虚拟机的启动硬盘，可以得到和上边实验相同的结果。 Bochs bochs是一个开源的x86模拟器，可以单步调试，可以查看CPU的寄存器值。各个版本的下载链接 # 下载Bochs代码 wget https://sourceforge.net/projects/bochs/files/bochs/2.6.11/bochs-2.6.11.tar.gz/download # 解压并进入代码目录 tar -zxvf ./download && cd ./bochs-2.6.11 # 配置编译环境 brew install sdl # 依赖项 chmod u+x ./configure ./configure --enable-ne2000 \\ --enable-all-optimizations \\ --enable-cpu-level=6 \\ --enable-x86-64 \\ --enable-vmx=2 \\ --enable-pci \\ --enable-usb \\ --enable-usb-ohci \\ --enable-e1000 \\ --enable-debugger \\ --enable-disasm \\ --disable-debugger-gui \\ --with-sdl \\ --prefix=$HOME/opt/bochs # 编译安装 # 报错 eth_socket.cc:98:10: fatal error: 'linux/types.h' file not found 参考1参考2 bochs在macos上编译的时候遇到fatal error: 'linux/types.h' file not found错误，暂时不知道怎么解决。 代码解释 ;代码清单5-1 mov ax,0xb800 ;指向文本模式的显示缓冲区 mov es,ax ;以下显示字符串\"Label offset:\" mov byte [es:0x00],'L' mov byte [es:0x01],0x07 ;黑底白字 mov byte [es:0x02],'a' mov byte [es:0x03],0x07 mov byte [es:0x04],'b' mov byte [es:0x05],0x07 mov byte [es:0x06],'e' mov byte [es:0x07],0x07 mov byte [es:0x08],'l' mov byte [es:0x09],0x07 mov byte [es:0x0a],' ' mov byte [es:0x0b],0x07 mov byte [es:0x0c],\"o\" mov byte [es:0x0d],0x07 mov byte [es:0x0e],'f' mov byte [es:0x0f],0x07 mov byte [es:0x10],'f' mov byte [es:0x11],0x07 mov byte [es:0x12],'s' mov byte [es:0x13],0x07 mov byte [es:0x14],'e' mov byte [es:0x15],0x07 mov byte [es:0x16],'t' mov byte [es:0x17],0x07 mov byte [es:0x18],':' mov byte [es:0x19],0x07 mov ax,number ;取得标号number的偏移地址 mov bx,10 ; 除数 ;设置数据段的基地址 mov cx,cs mov ds,cx ;求个位上的数字 mov dx,0 ; 被除数是DX:AX 32位 div bx ; 除数是BX 16位， 商在AX，余数在DX mov [0x7c00+number+0x00],dl ; dl中保存的是余数的低8位 ;保存个位上的数字 ;求十位上的数字 xor dx,dx ; 清空dx寄存器的值 div bx mov [0x7c00+number+0x01],dl ;保存十位上的数字 ;求百位上的数字 xor dx,dx div bx mov [0x7c00+number+0x02],dl ;保存百位上的数字 ;求千位上的数字 xor dx,dx div bx mov [0x7c00+number+0x03],dl ;保存千位上的数字 ;求万位上的数字 xor dx,dx div bx mov [0x7c00+number+0x04],dl ;保存万位上的数字 ;以下用十进制显示标号的偏移地址 mov al,[0x7c00+number+0x04] add al,0x30 ; 要显示数字的ASCII mov [es:0x1a],al mov byte [es:0x1b],0x04 mov al,[0x7c00+number+0x03] add al,0x30 mov [es:0x1c],al mov byte [es:0x1d],0x04 ; 黑底红字，无闪烁，无加亮 mov al,[0x7c00+number+0x02] add al,0x30 mov [es:0x1e],al mov byte [es:0x1f],0x04 ; 设置显示模式 mov al,[0x7c00+number+0x01] add al,0x30 mov [es:0x20],al mov byte [es:0x21],0x04 mov al,[0x7c00+number+0x00] add al,0x30 mov [es:0x22],al mov byte [es:0x23],0x04 mov byte [es:0x24],'D' mov byte [es:0x25],0x07 ;无限循环 infi: jmp near infi number db 0,0,0,0,0 times 203 db 0 ; 重复定义203个0 db 0x55,0xaa div指令： 被除数是32位时存储在 （DX:AX） 除数是16位的跟在div指令后，商存在AX，余数在DX中 被除数是16位时存储在 AX中，除数是8位的跟在div指令后，商在AL,余数在AH中 DB是伪指令，即没有对应的机器码，只是给编译器用的。DB表示声明一个字节数据，此外还有DW(两个字),DD（双字）,DQ（四字） ;代码清单6-1 jmp near start mytext db 'L',0x07,'a',0x07,'b',0x07,'e',0x07,'l',0x07,' ',0x07,'o',0x07,\\ 'f',0x07,'f',0x07,'s',0x07,'e',0x07,'t',0x07,':',0x07 number db 0,0,0,0,0 start: mov ax,0x7c0 mov ds,ax ;设置数据段基地址 mov ax,0xb800 mov es,ax ;设置附加段基地址 cld ; 清除DF位，DF=0表示movsw为正方向， std指令设置DF=1 传送方向为从高地址到低地址 mov si,mytext ; movsw的源（source） mov di,0 ; movsw的目的（dist） mov cx,(number-mytext)/2 ; (numbner-mytext)/2是需要movsw的次数，cx是计数寄存器cx==0时rep结束 13 rep movsw ; 重复movsw，每次mov一个word及两个字节 起始DS:SI 目的ES:DI mov ax,number ;得到标号所代表的偏移地址 ;计算各个数位 mov bx,ax mov cx,5 mov si,10 ; 除数 digit: xor dx,dx ; 清空dx寄存器的值 div si mov [bx],dl ; 保存数位，保存位置为number inc bx ; bx值增加1 loop digit ; cx != 0 就跳转回digit标签处 ;显示各个数位 mov bx,number mov si,4 ; 显示位数 show: mov al,[bx+si] add al,0x30 mov ah,0x04 mov [es:di],ax add di,2 dec si ; si 自减1 jns show ; SF=0则跳转 SF（Sign Flag）如果前边dec执行后最高位为0则SF=0,否则置1 mov word [es:di],0x0744 ; 0x07 表示黑底白字 0x44是字母'D' jmp near $ ; 死循环 times 510-($-$$) db 0 ; 一个块512B，减去55aa还有510个块, $代表行首地址，$$代表当前段的起始地址 db 0x55,0xaa ; MBR分区标记 movsw指令 movsw和movsb指令执行时，原始数据串的地址由DS:SI指定，要传送的目的地址为ES:DI，传送次数为CX，movsb每次传送一个字节，movsw每次传送两个字节。 正向传送时，没传送一个字节（movsb）或者一个字（movsw）SI和DI加1或者2； 反向传送时，没传送一个字节（movsb）或者一个字（movsw）SI和DI减1或者2； 传送方向由标志寄存器（FLAGS）的DF位指定，0为正，1为负。cls清零DF位，std将DF位置1. 单纯的movsw或者movsb指令只能执行1此，需要加上rep前缀，只要CX不为0就一直执行movsw或者movsb。 Copyright © Yuanye.Ma 2020-2021 all right reserved，powered by Gitbook文件修订时间： 2023-04-02 10:05:52 "},"_posts/OS/submit-patch.html":{"url":"_posts/OS/submit-patch.html","title":"Submit Patch","keywords":"","body":"提交kernel patch 创建工作分支 # 添加linux-next远程分支 git remote add linux-next https://git.kernel.org/pub/scm/linux/kernel/git/next/linux-next.git git fetch --tags linux-next # 基于next-20210112标签创建工作分支 git branch mybranch next-20210112 # 检出到分支mybranch git checkout mybranch 修改代码 提交修改 # 添加修改的文件 git add Documentation/fpga/dfl.rst # 查看log 学写 commit git log Documentation/fpga/dfl.rst # 提交 git commit 制作patch # 针对最近1个commit制作patch git format-patch -s -1 # 检查patch是否符合要求 ./scripts/checkpatch.pl 0001-Documentation-fpga-dfl-fix-syntax-errors-for-dfl.patch # 如果不符合要求就撤销commit，重新修改。 git reset HEAD~1 发送patch 配置msmtp sudo apt install msmtp vim ~/.msmtprc 写入以下内容 # default account gmail protocol smtp host smtp.gmail.com from xxxxxx@gmail.com user xxxxxx@gmail.com password xxxxxxx port 587 auth on tls on tls_trust_file /etc/ssl/certs/ca-certificates.crt syslog LOG_MAIL # set a default account account default : gmail 此外，还需在 Google账号->安全性->安全性较低的应用的访问权限->启用 发送patch # 查找maintainer ./scripts/get_maintainer.pl 0001-Documentation-fpga-dfl-fix-syntax-errors-for-dfl.patch # 使用邮件发送patch git send-email -to xxx@xxx.com ./0001-Documentation-fpga-dfl-fix-syntax-errors-for-dfl.patch Copyright © Yuanye.Ma 2020-2021 all right reserved，powered by Gitbook文件修订时间： 2023-04-02 10:05:52 "},"_posts/OS/x86平台linux系统调用.html":{"url":"_posts/OS/x86平台linux系统调用.html","title":"x86平台linux系统调用","keywords":"","body":"x86平台linux系统调用分析 [toc] kernel version : linux 2.6.30.4 x86 系统调用整体流程 用户空间调用libc库的syscall函数，此函数内嵌汇编，汇编代码先将系统调用号写入eax寄存器，其他参数写入ebx ecx edx esi edi五个寄存器，若参数总个数超过五个，则应该用一个单独的寄存器存放指向所有这些参数在用户空间地址的指针。然后调用int 0x80指令陷入内核。 CPU从IDTR中得到IDT（中断向量表）地址，并根据中断号(0x80)找到IDT下标为0x80的元素，即门描述符，检查CPL=3, 门描述符DPL=0，不相符，发生栈切换。 CPU根据寄存器TR的内容找到当前TSS,并根据目标代码段的DPL，从TSS结构中取出新的堆栈指针（SS和ESP），并装入其堆栈段寄存器SS和堆栈指针ESP中，达到更换堆栈的目的。这种情况下CPU不但要将EFLAGS、返回地址以及出错代码压入堆栈，还要先将原来的堆栈指针也压入新堆栈中。 栈切换完成后，CPU从陷阱门描述符中找到中断服务程序所在内存段的段选择子和地址偏移，根据段选择子去GDT或者LDT中找到对应的段描述符，装入CS段选择寄存器，找到段基地址，并加上地址偏移后找到中断服务程序入口地址，跳转过去运行。 中断向量表IDT的初始化 基于linux 2.6.30.4 /* \"arch/x86/kernel/traps.c\" */ void __init trap_init(void) { set_intr_gate(0, &divide_error); set_intr_gate_ist(1, &debug, DEBUG_STACK); set_intr_gate_ist(2, &nmi, NMI_STACK); /* int3 can be called from all */ set_system_intr_gate_ist(3, &int3, DEBUG_STACK); /* int4 can be called from all */ set_system_intr_gate(4, &overflow); set_intr_gate(5, &bounds); set_intr_gate(6, &invalid_op); set_intr_gate(7, &device_not_available); set_task_gate(8, GDT_ENTRY_DOUBLEFAULT_TSS); set_intr_gate(9, &coprocessor_segment_overrun); set_intr_gate(10, &invalid_TSS); set_intr_gate(11, &segment_not_present); set_intr_gate_ist(12, &stack_segment, STACKFAULT_STACK); set_intr_gate(13, &general_protection); set_intr_gate(14, &page_fault); set_intr_gate(15, &spurious_interrupt_bug); set_intr_gate(16, &coprocessor_error); set_intr_gate(17, &alignment_check); set_system_trap_gate(SYSCALL_VECTOR, &system_call); /* SYSCALL_VECTOR arch/x86/include/asm/irq_vectors.h:36:# define SYSCALL_VECTOR 0x80 asmlinkage int system_call(void); */ cpu_init(); } 程序中首先设置中断向量表的头19个陷阱门，这些中断向量表都是CPU保留用于异常处理的。 set_intr_gate() 等函数都调用了_set_gate()函数设置门描述符，本文重点分析系统调用相关的内容，即 set_system_trap_gate()函数。 /*\"arch/x86/include/asm/desc.h\" */ /* set_system_trap_gate(SYSCALL_VECTOR, &system_call); 参数 n = SYSCALL_VECTOR = 0x80; addr = &system_call */ static inline void set_system_trap_gate(unsigned int n, void *addr) { BUG_ON((unsigned)n > 0xFF); _set_gate(n, GATE_TRAP, addr, 0x3, 0, __KERNEL_CS); } _set_gate()函数完成设置门描述符的工作。 /* _set_gate(n, GATE_TRAP, addr, 0x3, 0, __KERNEL_CS); \"arch/x86/include/asm/desc_defs.h\" enum { GATE_INTERRUPT = 0xE, GATE_TRAP = 0xF, GATE_CALL = 0xC, GATE_TASK = 0x5, }; arch/x86/include/asm/segment.h #define __KERNEL_CS (GDT_ENTRY_KERNEL_CS * 8) #define GDT_ENTRY_KERNEL_CS 2 */ static inline void _set_gate(int gate, unsigned type, void *addr, unsigned dpl, unsigned ist, unsigned seg) { /* 参数如下： gate = n = SYSCALL_VECTOR = 0x80; type = GATE_TRAP = 0xF; addr = &system_call; dpl = 0x3; ist = 0; seg = __KERNEL_CS = 2*8; */ gate_desc s; pack_gate(&s, type, (unsigned long)addr, dpl, ist, seg); /* * does not need to be atomic because it is only done once at * setup time */ write_idt_entry(idt_table, gate, &s); } 先看看第一行gate_desc s;，主要分配了门描述符的结构。 /*gate_desc 结构 \"arch/x86/include/asm/desc_defs.h\" */ typedef struct desc_struct gate_desc; struct desc_struct { union { struct { unsigned int a; // 4字节 unsigned int b; // 4字节 }; struct { u16 limit0; // 2字节 位移的低16位 u16 base0; // 2字节 段选择码 unsigned base1: 8, type: 4, s: 1, dpl: 2, p: 1; // 2字节 unsigned limit: 4, avl: 1, l: 1, d: 1, g: 1, base2: 8; //2字节 }; }; } __attribute__((packed)); attribute ((packed)) 的作用就是告诉编译器取消结构在编译过程中的优化对齐,按照实际占用字节数进行对齐，是GCC特有的语法。这个功能是跟操作系统没关系，跟编译器有关，gcc编译器不是紧凑模式的，在windows下，用vc的编译器也不是紧凑的，用tc的编译器就是紧凑的。 例如： 在TC下：struct my{ char ch; int a;} sizeof(int)=2;sizeof(my)=3;（紧凑模式）在GCC下：struct my{ char ch; int a;} sizeof(int)=4;sizeof(my)=8;（非紧凑模式）在GCC下：struct my{ char ch; int a;}attrubte ((packed)) sizeof(int)=4;sizeof(my)=5 struct desc_struct包含一个联合体，可以用其中任何一种类型，后边可以看到pack_gate()函数使用联合体中的第一种，即struct {unsigned int a; unsigned int b};。 /* 参数 gate = n = SYSCALL_VECTOR = 0x80; type = GATE_TRAP = 0xF; addr = &system_call; dpl = 0x3; ist = 0; seg = __KERNEL_CS = 2*8; */ static inline void pack_gate(gate_desc *gate, unsigned char type, unsigned long base, unsigned dpl, unsigned flags, unsigned short seg) { gate->a = (seg b = (base & 0xffff0000) | (((0x80 | type | (dpl pack_gate()此函数包装一个陷阱门描述符。gate->a在低地址。 /* gate->a = (seg a = ((2*8)b = (base & 0xffff0000) | (((0x80 | type | (dpl b = (&system_call & 0xffff0000) | (((0x80 | 0xF | (0x3 #define write_idt_entry(dt, entry, g) \\ native_write_idt_entry(dt, entry, g) /* 参数 idt = idt_table; entry = gate = n = SYSCALL_VECTOR = 0x80;; gate = &s； 其中 gate_desc idt_table[256] __attribute__((__section__(\".data.idt\"))) = { { { { 0, 0 } } }, }; typedef struct desc_struct gate_desc; */ static inline void native_write_idt_entry(gate_desc *idt, int entry, const gate_desc *gate) { memcpy(&idt[entry], gate, sizeof(*gate)); } native_write_idt_entry()此函数将pack_gate()函数封装的陷阱门描述符拷贝进idt的0x80位置。 系统调用的中断服务程序分析 /*arch/x86/kernel/entry_32.S*/ # system call handler stub ENTRY(system_call) RING0_INT_FRAME # can't unwind into user space anyway pushl %eax # save orig_eax CFI_ADJUST_CFA_OFFSET 4 SAVE_ALL GET_THREAD_INFO(%ebp) # system call tracing in operation / emulation testl $_TIF_WORK_SYSCALL_ENTRY,TI_flags(%ebp) jnz syscall_trace_entry cmpl $(nr_syscalls), %eax jae syscall_badsys syscall_call: call *sys_call_table(,%eax,4) movl %eax,PT_EAX(%esp) # store the return value syscall_exit: LOCKDEP_SYS_EXIT DISABLE_INTERRUPTS(CLBR_ANY) # make sure we don't miss an interrupt # setting need_resched or sigpending # between sampling and the iret TRACE_IRQS_OFF movl TI_flags(%ebp), %ecx testl $_TIF_ALLWORK_MASK, %ecx # current->work jne syscall_exit_work 先将%eax（系统调用号）压入栈，然后调用SAVE_ALL保存中断现场，检查系统调用号，跳转到相应的而系统调用函数去执行call *sys_call_table(,%eax,4)，sys_call_table定义如下，是一个函数指针列表。 /*arch/x86/kernel/syscall_table_32.S*/ ENTRY(sys_call_table) .long sys_restart_syscall /* 0 - old \"setup()\" system call, used for restarting */ .long sys_exit .long ptregs_fork .long sys_read .long sys_write .long sys_open /* 5 */ .long sys_close .long sys_waitpid .long sys_creat .long sys_link .long sys_unlink /* 10 */ .long ptregs_execve .long sys_chdir .long sys_time /* 略 */ 关于SAVE_ALL .macro SAVE_ALL cld PUSH_GS pushl %fs CFI_ADJUST_CFA_OFFSET 4 # 这些宏暂时不知道干啥的 /*CFI_REL_OFFSET fs, 0;*/ pushl %es CFI_ADJUST_CFA_OFFSET 4 /*CFI_REL_OFFSET es, 0;*/ pushl %ds CFI_ADJUST_CFA_OFFSET 4 /*CFI_REL_OFFSET ds, 0;*/ pushl %eax CFI_ADJUST_CFA_OFFSET 4 CFI_REL_OFFSET eax, 0 pushl %ebp CFI_ADJUST_CFA_OFFSET 4 CFI_REL_OFFSET ebp, 0 pushl %edi CFI_ADJUST_CFA_OFFSET 4 CFI_REL_OFFSET edi, 0 pushl %esi CFI_ADJUST_CFA_OFFSET 4 CFI_REL_OFFSET esi, 0 pushl %edx CFI_ADJUST_CFA_OFFSET 4 CFI_REL_OFFSET edx, 0 pushl %ecx CFI_ADJUST_CFA_OFFSET 4 CFI_REL_OFFSET ecx, pushl %ebx CFI_ADJUST_CFA_OFFSET 4 CFI_REL_OFFSET ebx, 0 movl $(__USER_DS), %edx movl %edx, %ds movl %edx, %es movl $(__KERNEL_PERCPU), %edx movl %edx, %fs SET_KERNEL_GS %edx .endm 穿插一些宏暂时不知道干什么的，先不管。主要看一下寄存器的压栈顺序：%es %ds %eax %ebp %edi %esi %edx %ecx %ebx 系统调用的定义 /* include/linux/syscalls.h */ #define SYSCALL_DEFINE0(sname) \\ static const struct syscall_metadata __used \\ __attribute__((__aligned__(4))) \\ __attribute__((section(\"__syscalls_metadata\"))) \\ __syscall_meta_##sname = { \\ .name = \"sys_\"#sname, \\ .nb_args = 0, \\ }; \\ asmlinkage long sys_##sname(void) #else #define SYSCALL_DEFINE0(name) asmlinkage long sys_##name(void) #endif #define SYSCALL_DEFINE1(name, ...) SYSCALL_DEFINEx(1, _##name, __VA_ARGS__) #define SYSCALL_DEFINE2(name, ...) SYSCALL_DEFINEx(2, _##name, __VA_ARGS__) #define SYSCALL_DEFINE3(name, ...) SYSCALL_DEFINEx(3, _##name, __VA_ARGS__) #define SYSCALL_DEFINE4(name, ...) SYSCALL_DEFINEx(4, _##name, __VA_ARGS__) #define SYSCALL_DEFINE5(name, ...) SYSCALL_DEFINEx(5, _##name, __VA_ARGS__) #define SYSCALL_DEFINE6(name, ...) SYSCALL_DEFINEx(6, _##name, __VA_ARGS__) /* 其中 SYSCALL_DEFINEx*/ #ifdef CONFIG_FTRACE_SYSCALLS /*ftrace是内核提供的一种调试工具*/ #define SYSCALL_DEFINEx(x, sname, ...) \\ static const char *types_##sname[] = { \\ __SC_STR_TDECL##x(__VA_ARGS__) \\ }; \\ static const char *args_##sname[] = { \\ __SC_STR_ADECL##x(__VA_ARGS__) \\ }; \\ SYSCALL_METADATA(sname, x); \\ __SYSCALL_DEFINEx(x, sname, __VA_ARGS__) #else #define SYSCALL_DEFINEx(x, sname, ...) \\ __SYSCALL_DEFINEx(x, sname, __VA_ARGS__) #endif #ifdef CONFIG_HAVE_SYSCALL_WRAPPERS #define SYSCALL_DEFINE(name) static inline long SYSC_##name #define __SYSCALL_DEFINEx(x, name, ...) \\ asmlinkage long sys##name(__SC_DECL##x(__VA_ARGS__)); \\ static inline long SYSC##name(__SC_DECL##x(__VA_ARGS__)); \\ asmlinkage long SyS##name(__SC_LONG##x(__VA_ARGS__)) \\ { \\ __SC_TEST##x(__VA_ARGS__); \\ return (long) SYSC##name(__SC_CAST##x(__VA_ARGS__)); \\ } \\ SYSCALL_ALIAS(sys##name, SyS##name); \\ static inline long SYSC##name(__SC_DECL##x(__VA_ARGS__)) #else /* CONFIG_HAVE_SYSCALL_WRAPPERS */ #define SYSCALL_DEFINE(name) asmlinkage long sys_##name #define __SYSCALL_DEFINEx(x, name, ...) \\ asmlinkage long sys##name(__SC_DECL##x(__VA_ARGS__)) #endif /* CONFIG_HAVE_SYSCALL_WRAPPERS */ /* 后边是所有系统调用的函数声明 */ asmlinkage long sys_time(time_t __user *tloc); 系统调用的定义分布在内核源代码多个源文件中find . -type f -name \"*.c\" | xargs grep SYSCALL_DEFINE | wc -l 系统调用号 每个系统调用xxx都对应着一个系统调用号__NR_xxx。当应用程序调用某系统调用时，寄存器eax中保存该系统调用对应的系统调用号。系统调用号定义于如下头文件中： include/linux/unistd.h +- arch/x86/include/asm/unistd.h +- arch/x86/include/asm/unistd_32.h | +- ... | +- #define __NR_process_vm_writev 348 | +- #define NR_syscalls 349 +- arch/x86/include/asm/unistd_64.h +- ... +- #define __NR_process_vm_writev 311 +- __SYSCALL(__NR_process_vm_writev, sys_process_vm_writev) 在应用程序中仅需包含头文件#include 即可。 #ifndef _LINUX_UNISTD_H_ #define _LINUX_UNISTD_H_ /* * Include machine specific syscall numbers */ #include #endif /* _LINUX_UNISTD_H_ */ 对于x86而言，asm/unistd.h即为arch/x86/include/asm/unistd.h: #ifdef __KERNEL__ # ifdef CONFIG_X86_32 # include \"unistd_32.h\" # else # include \"unistd_64.h\" # endif #else # ifdef __i386__ # include \"unistd_32.h\" # else # include \"unistd_64.h\" # endif #endif 对于x86 32-bit而言，unistd_32.h即为arch/x86/include/asm/unistd_32.h: #define __NR_restart_syscall 0 #define __NR_exit 1 #define __NR_fork 2 #define __NR_read 3 #define __NR_write 4 #define __NR_open 5 #define __NR_close 6 ... #define __NR_process_vm_readv 347 #define __NR_process_vm_writev 348 #ifdef __KERNEL__ #define NR_syscalls 349 #endif 系统调用的返回值 如果系统调用执行失败，系统调用并不直接返回错误码，而是将错误码保存到全局变量errno中，因而可根据errno的值来确定错误类型。错误码定义于如下头文件中： include/linux/errno.h // 错误码512-530 -> arch/x86/include/asm/errno.h // 仅包含asm-generic/errno.h，未新增错误码 -> include/asm-generic/errno.h // 错误码35-133 -> include/asm-generic/errno-base.h // 错误码1-34 也可以执行man errno查询到。 新增系统调用 通过修改内核代码 确定新增的系统调用号 修改arch/x86/include/asm/unistd_32.h，为新增的系统调用定义的系统调用号#define _NR_testsyscall 350 修改arch/x86/kernel/syscall_table_32.S，将新增的系统调用加入到系统调用表，即数组sys_call_table中写入：long sys_testsyscall /* 350 */ 编写新增的系统调用 编写一个系统调用意味着要给内核增加一个函数，将该函数写入文件kernel/sys.c中，代码如下：SYSCALL_DEFINE0(testsyscall) { console_print(\"hello world\\n\"); return 0; } 使用新增的系统调用 因为C库中没有新增的系统调用的程序段，必须自己建立其代码，如下：#inculde SYSCALL_DEFINE0(testsyscall) void main() { tsetsyscall(); } 通过编写插入内核模块 编写系统调用内核模块 #inculde #inculde #inculde #inculde #inculde #define _NR_testsyscall 350 extern void *sys_call_table[]; asmlinkage long testsyscall() { printf(\"hello world\\n\"); return 0; } int syscall_test_init() { sys_call_table[_NR_tsetsyscall] = testsyscall; printf(\"system call testsyscall() loaded success\\n\"); return 0; } module_init(syscall_test_init); void syscall_test_exit() { } module_exit(syscall_test_exit) 编写使用新增的系统调用的代码 编译内核模块并插入内核模块 从用户空间直接访问系统调用 方式一：通过C库函数，C库函数封装了所有的系统调用。 方式二：2.6.18版本之前的内核可以使用_syscall宏。但是自2.6.19版本开始，_syscall宏被废除，我们需要使用syscall函数，通过指定系统调用号和一组参数来调用系统调用。 #include #include #include #define __NR_gettid 224 int main(int argc, char *argv[]) { pid_t tid; tid = syscall(__NR_gettid); //括号内参数直接写224也可以 /*也可以写成tid = syscall(SYS_gettid);*/ } 参考 注： syscall()函数是glibc中的一个用户空间函数，可以通过man syscall命令查看，函数声明在/usr/include/unistd.h中，对应系统调用号在/usr/include/asm-generic/unistd.h中声明。 Copyright © Yuanye.Ma 2020-2021 all right reserved，powered by Gitbook文件修订时间： 2023-04-02 10:05:52 "},"_posts/OS/x86平台通用中断.html":{"url":"_posts/OS/x86平台通用中断.html","title":"x86平台通用中断","keywords":"","body":"x86平台Linux中断机制 [toc] 基础知识 NMI不能被IF禁止，其中断向量号由系统固定分配。 外部中断一般可分为非屏蔽中断和可屏蔽中断。对于非屏蔽中断，cpu直接在对应的中断向量表中取得中断入口地址，执行中断处理程序。而对于可屏蔽中断，一般是用8259A等中断管理器来管理。cpu从中断管理器中得到一个中断请求时，会去检查一下中断允许标志IF，若IF为1则取出中断类型码，从中断向量表中取得中断入口地址，执行中断处理程序。若IF为0，cpu将不响应外部提出的中断请求。 IRQ : Interrupt ReQuest PIC : Programmable Interrupt Controller 可编程中断控制器 向量：每个中断和异常，由0-255之间的数来标识，Intel把这个无符号的整数叫做向量（vector） PIC的作用： 监视IRQ线，检查产生的信号。 如果有引发信号出现在IRQ线上： a. 把接收到的引发信号转换成对应的向量。 b. 把这个向量存放在中断控制器的一个I/O端口，从而允许CPU通过数据总线读取此向量。 c. 把引发信号发送到处理器的INTR引脚，即产生一个中断。 d. 等待，直到CPU通过把这个中断信号写进可编程中断控制器的一个I/O端口来确认，这种情况发生时，清INTR线。 返回第1步。 IRQ线从0开始编号，因此IRQn关联的Intel的缺省向量是n+32(CPU保留了一部分向量来处理异常)。可以通过向中断控制器端口发布合适的指令，修改IRQ和向量之间的映射，以及有选择的禁止或者激活相应的IRQ，此禁止只是告诉PIC暂时不向CPU发布此IRQ中断，而一旦此IRQ被再次激活，PIC又会发送此IRQ给CPU 。可屏蔽中断的全局屏蔽或者非屏蔽，由CPU的eflags寄存器的IF标志位决定，cli和sti指令分别清楚和设置该标志。 传统的PIC由两片8259A外部芯片级联组成，只能作为单处理器的PIC。在SMP体系结构中，中断需要传递给系统中的每个CPU，为此Intel从Pentiun III开始引入I/O高级可编程控制器（I/O Advanded Programmable Interrupt Controller, I/O APIC）用以代替老式的8259A PIC。 多APIC结构：APIC总线把“前端”I/O APIC连接到本地APIC。来自设备的IRQ线连接到I/O APIC，相对于本地APIC来说，I/O APIC起路由作用。 I/O APIC中的中断重定向表将每个外部IRQ信号转换为一条消息，然后，通过APIC总线发送给一个或多个CPU的本地APIC单元。多APIC系统还允许CPU产生处理器间中断（interprocessor interrupt, 简称IPI）。 目前大部分单处理器系统都包含一个I/O APIC芯片，可以用以下两种方式进行配置： 作为一种标准的8259A方式的外部PIC连接到CPU。本地APIC被禁止，LINT0和LINT1本地IRQ线分别配置为INTR和NMI引脚。 作为一种标准的I/O APIC。本地APIC被激活，且所有的外部中断都通过I/O APIC接收。 中断请求队列 由于硬件的限制，很多外部设备不得不共享中断线，例如，一些PC配置可以把同一条中断线分配给网卡和图形卡。由此看来，让每个中断源都必须占用一条中断线是不现实的。所以，仅仅中断描述符表并不能提供中断产生的所有信息，内核必须对中断线给出进一步的描述。在Linux设计中，专门为每个中断请求IRQ设置了一个队列，这就是我们所说的中断请求队列。 关于I/O APIC的一些更详细的资料 PIC 、APIC(IOAPIC LAPIC) 1. IO APIC Linux kernel version : linux 2.6.30.4 基本数据结构 由于通用中断门是让多个中断源共享的，而且允许这种公用的结构在系统运行的过程中动态地变化，所以IDT的初始化阶段只是为每个中断向量，也即每个表项准备一个“中断请求队列”， 从而形成一个中断请求队列的数组，这就是数组irq_desc[]。 每个队列头部中除了action用来维持一个由中断服务程序描述项目构成的单链队列外，还有个指针handler指向另一个数据结构，即hw_interrupt_type数据结构，此结构主要是一些函数指针，用于该队列，或者该共用“中断通道”的控制，并不对具体的中断源服务。具体的函数取决于所用的中断控制器(比如 i8259A)。其中，函数指针enable和disable用于开启和关闭其所属的通道，ack用于对中断控制器的相应，而end则用于每次中断服务返回的前夕，这些函数都是在init_IRQ()函数中调用init_ISA_irqs()设置好的。 [这两段摘自《Linux内核源代码情景分析》3.3小节] irq_desc_t 每个中断向量都有自己的irq_desc_t描述符，所有这些描述符组织在一起形成了irq_desc数组。 根据前一段书中的描述，irq_desc数组应该就是作者所说的中断请求队列数组，数组中的每一项即每一个struct irq_desc结构都描述一个“中断请求队列”，struct irqaction即中断服务程序构成的队列，队列中每一项都对应一个中断服务程序。hw_interrupt_type在较新版本的内核中被struct irq_chip取代，指代此中断通道的操作函数。 /*include/linux/irq.h*/ /** * struct irq_desc - interrupt descriptor * @irq: interrupt number for this descriptor * @timer_rand_state: pointer to timer rand state struct * @kstat_irqs: irq stats per cpu * @irq_2_iommu: iommu with this irq * @handle_irq: highlevel irq-events handler [if NULL, __do_IRQ()] * @chip: low level interrupt hardware access * @msi_desc: MSI descriptor * @handler_data: per-IRQ data for the irq_chip methods * @chip_data: platform-specific per-chip private data for the chip * methods, to allow shared chip implementations * @action: the irq action chain * @status: status information * @depth: disable-depth, for nested irq_disable() calls * @wake_depth: enable depth, for multiple set_irq_wake() callers * @irq_count: stats field to detect stalled irqs * @last_unhandled: aging timer for unhandled count * @irqs_unhandled: stats field for spurious unhandled interrupts * @lock: locking for SMP * @affinity: IRQ affinity on SMP * @cpu: cpu index useful for balancing * @pending_mask: pending rebalanced interrupts * @threads_active: number of irqaction threads currently running * @wait_for_threads: wait queue for sync_irq to wait for threaded handlers * @dir: /proc/irq/ procfs entry * @name: flow handler name for /proc/interrupts output */ struct irq_desc { unsigned int irq; struct timer_rand_state *timer_rand_state; unsigned int *kstat_irqs; #ifdef CONFIG_INTR_REMAP struct irq_2_iommu *irq_2_iommu; #endif irq_flow_handler_t handle_irq; struct irq_chip *chip; /*指向描述PIC对象的描述符*/ struct msi_desc *msi_desc; void *handler_data; void *chip_data; /* 指向PIC对象方法所使用的的数据 */ struct irqaction *action; /* IRQ action list */ unsigned int status; /* IRQ status */ unsigned int depth; /* nested irq disables */ unsigned int wake_depth; /* nested wake enables */ unsigned int irq_count; /* For detecting broken IRQs */ unsigned long last_unhandled; /* Aging timer for unhandled count */ unsigned int irqs_unhandled; spinlock_t lock; #ifdef CONFIG_SMP cpumask_var_t affinity; unsigned int cpu; #ifdef CONFIG_GENERIC_PENDING_IRQ cpumask_var_t pending_mask; #endif #endif atomic_t threads_active; wait_queue_head_t wait_for_threads; #ifdef CONFIG_PROC_FS struct proc_dir_entry *dir; #endif const char *name; } ____cacheline_internodealigned_in_smp; extern struct irq_desc irq_desc[NR_IRQS]; /* include/linux/cache.h */ #if !defined(____cacheline_internodealigned_in_smp) #if defined(CONFIG_SMP) #define ____cacheline_internodealigned_in_smp \\ __attribute__((__aligned__(1 lock), } }; irq_desc_t描述的depth字段和IRQ_DISABLED标志表示IRQ线是否被禁用。每次调用disable_irq()或者disale_irq_nosync()函数，depth字段的值增加，如果depth等于0，函数禁用IRQ线并设置它的IRQ_DISABLED标志相反，每当调用enable_irq()函数，depth字段的值减少，如果depth变为0，函数激活IRQ线并清除IRQ_DISABLED标志。 irq_chip Linux支持多种PIC，为了以统一的方式处理所有这样的设备，Linux用了一个PIC对象，由PIC名字和七个PIC标准方法组成。定义PIC对象的数据结构叫做hw_interrupt_type（也叫作hw_irq_controller），后来被irq_chip取代，并添加了很多新的底层硬件操作函数。 /*include/linux/irq.h*/ /** * struct irq_chip - hardware interrupt chip descriptor * * @name: name for /proc/interrupts * @startup: start up the interrupt (defaults to ->enable if NULL) * @shutdown: shut down the interrupt (defaults to ->disable if NULL) * @enable: enable the interrupt (defaults to chip->unmask if NULL) * @disable: disable the interrupt (defaults to chip->mask if NULL) * @ack: start of a new interrupt * @mask: mask an interrupt source * @mask_ack: ack and mask an interrupt source * @unmask: unmask an interrupt source * @eoi: end of interrupt - chip level * @end: end of interrupt - flow level * @set_affinity: set the CPU affinity on SMP machines * @retrigger: resend an IRQ to the CPU * @set_type: set the flow type (IRQ_TYPE_LEVEL/etc.) of an IRQ * @set_wake: enable/disable power-management wake-on of an IRQ * * @release: release function solely used by UML * @typename: obsoleted by name, kept as migration helper */ struct irq_chip { const char *name; unsigned int (*startup)(unsigned int irq); void (*shutdown)(unsigned int irq); void (*enable)(unsigned int irq); void (*disable)(unsigned int irq); void (*ack)(unsigned int irq); void (*mask)(unsigned int irq); void (*mask_ack)(unsigned int irq); void (*unmask)(unsigned int irq); void (*eoi)(unsigned int irq); void (*end)(unsigned int irq); void (*set_affinity)(unsigned int irq, const struct cpumask *dest); int (*retrigger)(unsigned int irq); int (*set_type)(unsigned int irq, unsigned int flow_type); int (*set_wake)(unsigned int irq, unsigned int on); /* Currently used only by UML, might disappear one day.*/ #ifdef CONFIG_IRQ_RELEASE_METHOD void (*release)(unsigned int irq, void *dev_id); #endif /* * For compatibility, ->typename is copied into ->name. * Will disappear. */ const char *typename; }; irqaction 多个设备能共享一个单独的IRQ，因此，内核要维护多个irqaction描述符，其中的每个描述符涉及一个特定的硬件设备和一个特定的中断。 /* include/linux/interrupt.h */ /** * struct irqaction - per interrupt action descriptor * @handler: interrupt handler function * @flags: flags (see IRQF_* above) * @mask: no comment as it is useless and about to be removed * @name: name of the device * @dev_id: cookie to identify the device * @next: pointer to the next irqaction for shared interrupts * @irq: interrupt number * @dir: pointer to the proc/irq/NN/name entry * @thread_fn: interupt handler function for threaded interrupts * @thread: thread pointer for threaded interrupts * @thread_flags: flags related to @thread */ struct irqaction { irq_handler_t handler; /* 指向一个I/O设备的中断服务例程 */ unsigned long flags; /* 描述IRQ和I/O设备之间的关系 */ cpumask_t mask; const char *name; /* I/O设备名，/proc/interrupts文件中显示 */ void *dev_id; /* I/O设备的私有字段，标识设备本身(设备号)或者其驱动程序 */ struct irqaction *next; /* 指向irqaction描述符链表的下一个元素，链表中的元素指向共享同一个IRQ的硬件设备 */ int irq; /* IRQ线 */ struct proc_dir_entry *dir; /* 指向IRQn相关的/proc/irq/n目录的描述符 */ irq_handler_t thread_fn; struct task_struct *thread; unsigned long thread_flags; }; /* 中断服务函数类型 */ typedef irqreturn_t (*irq_handler_t)(int, void *); 中断初始化 x86平台中断初始化共分为以下几步： 中断描述符表的初步初始化 中断描述符表的最终初始化 trap_init() early_irq_init() init_IRQ() IDT初步初始化 声明256个门描述符的IDT表空间 /* arch/x86/kernel/head_32.S */ idt_descr: .word IDT_ENTRIES*8-1 # idt contains 256 entries .long idt_table /* 这里相当于声明了一个结构体idt_descr，包含两个元素，一个数字和idt_table的地址 arch/x86/include/asm/desc.h:35:extern gate_desc idt_table[];声明idt_table是一个外部变量，即head_32.S中的idt_descr中的idt_table. idt_table表的内容被_set_gate() -> write_idt_entry()填充。 */ #define write_idt_entry(dt, entry, g) \\ native_write_idt_entry(dt, entry, g) static inline void native_write_idt_entry(gate_desc *idt, int entry, const gate_desc *gate) { memcpy(&idt[entry], gate, sizeof(*gate)); } /* _set_gate()函数被set_xxxintr_gate()调用，用以设置中断门，陷阱门等。 函数被set_xxxintr_gate()函数主要在 start_kernel() ->trap_init() ->init_IQR() 被调用 */ 设置IDTR is386: movl $2,%ecx # set MP 2: movl %cr0,%eax andl $0x80000011,%eax # Save PG,PE,ET orl %ecx,%eax movl %eax,%cr0 call check_x87 lgdt early_gdt_descr lidt idt_descr ljmp $(__KERNEL_CS),$1f 1: movl $(__KERNEL_DS),%eax # reload all the segment registers movl %eax,%ss # after changing gdt. 初始化256个门描述符 /* * setup_idt * * sets up a idt with 256 entries pointing to * ignore_int, interrupt gates. It doesn't actually load * idt - that can be done only after paging has been enabled * and the kernel moved to PAGE_OFFSET. Interrupts * are enabled elsewhere, when we can be relatively * sure everything is ok. * * Warning: %esi is live across this function. */ setup_idt: lea ignore_int,%edx movl $(__KERNEL_CS lea指令 ： load effective address 功能是取偏移地址。 mov是将数据从源传到目的 lea是将源的地址传到目的 例如： ​ movl 18(%eax), %ebx #是将内存中（%eax+18）的内容传入%ebx中； ​ leal 18(%eax), %ebx #是将（18+（%eax中的值））即地址，传入%ebx; 代码中，lea idt_table, %edi #即将idt_table表的地址传到%edi中。 IDT最终初始化 异常：由函数trap_init()实现，被系统初始化入口函数start_kernel()调用； 中断：由函数init_IRQ()实现，被系统初始化入口函数start_kernel()调用； trap_init() 此函数在x86平台linux系统调用章节已经分析过。 early_irq_init() 该函数用于初始化数组irq_desc[]； /* init/main.c->start_kernel()->early_irq_init() early_irq_init()定义在kernel/irq/handle.c中，且针对不同的controller有不同的实现。 */ /* * Linux has a controller-independent interrupt architecture. * Every controller has a 'controller-template', that is used * by the main code to do the right thing. Each driver-visible * interrupt source is transparently wired to the appropriate * controller. Thus drivers need not be aware of the * interrupt-controller. * * The code is designed to be easily extended with new/different * interrupt controllers, without having to do assembly magic or * having to touch the generic code. * * Controller mappings for all interrupt sources: */ int nr_irqs = NR_IRQS; EXPORT_SYMBOL_GPL(nr_irqs); #ifdef CONFIG_SPARSE_IRQ /*CONFIG_SPARSE_IRQ=y支持稀有的中断号*/ /* 暂时不看 */ #else struct irq_desc irq_desc[NR_IRQS] __cacheline_aligned_in_smp = { [0 ... NR_IRQS-1] = { .status = IRQ_DISABLED, .chip = &no_irq_chip, .handle_irq = handle_bad_irq, .depth = 1, .lock = __SPIN_LOCK_UNLOCKED(irq_desc->lock), } }; static unsigned int kstat_irqs_all[NR_IRQS][NR_CPUS]; int __init early_irq_init(void) { struct irq_desc *desc; int count; int i; init_irq_default_affinity(); printk(KERN_INFO \"NR_IRQS:%d\\n\", NR_IRQS); desc = irq_desc; count = ARRAY_SIZE(irq_desc); for (i = 0; i init_IRQ() init/main.c->start_kernel()->init_IRQ() /* early_irq_init()函数调用完紧接着就是init_IQR()函数 */ /*arch/x86/kernel/paravirt.c*/ void init_IRQ(void) { pv_irq_ops.init_IRQ(); } /*pv_irq_ops的定义在arch/x86/kernel/paravirt.c*/ struct pv_irq_ops pv_irq_ops = { .init_IRQ = native_init_IRQ, .save_fl = __PV_IS_CALLEE_SAVE(native_save_fl), .restore_fl = __PV_IS_CALLEE_SAVE(native_restore_fl), .irq_disable = __PV_IS_CALLEE_SAVE(native_irq_disable), .irq_enable = __PV_IS_CALLEE_SAVE(native_irq_enable), .safe_halt = native_safe_halt, .halt = native_halt, #ifdef CONFIG_X86_64 .adjust_exception_frame = paravirt_nop, #endif }; /* 这里的调用关系搞不清楚是通过paravirt.c中的init_IRQ还是直接调用的irqinit_32.c中的init_IRQ然后再调用的native_init_IRQ, 通过irqinit_32.c中的注释：Overridden in paravirt.c 推断应该是直接调用的irqinit_32.c中的代码*/ /*arch/x86/kernel/irqinit_32.c*/ /* Overridden in paravirt.c */ void init_IRQ(void) __attribute__((weak, alias(\"native_init_IRQ\"))); void __init native_init_IRQ(void) { int i; /* Execute any quirks before the call gates are initialised: */ x86_quirk_pre_intr_init(); /* * Cover the whole vector space, no vector can escape * us. (some of these will be overridden and become * 'special' SMP interrupts) */ for (i = FIRST_EXTERNAL_VECTOR; i _attribute_((weak, alias(\"native_init_IRQ\"))); weak 和 alias 分别是GNU扩展的两个属性。 weak 使得所修饰的符号在目标文件中作为 weak symbol 而不是 global symbol。用 nm 命令查看编译生成的目标文件可用看到所修饰的符号是一个 weak symbol，它前面的标记是 W。给函数加上weak属性时，即使函数没定义，函数被调用也可以编译成功。 若两个或两个以上全局符号（函数或变量名）名字一样，而其中之一声明为weak symbol（弱符号），则这些全局符号不会引发重定义错误。链接器会忽略弱符号，去使用普通的全局符号来解析所有对这些符号的引用，但当普通的全局符号不可用时，链接器会使用弱符号。当有函数或变量名可能被用户覆盖时，该函数或变量名可以声明为一个弱符号。 而 alias 为所修饰的符号定义一个别名，前边代码中init_IRQ是native_init_IRQ的一个别名，所定义的别名和原符号名必须在同一个编译单元中定义，如native_init_IRQ和init_IRQ在同一个.c文件中，否则会编译出错。 参考 其中x86_quirk_pre_intr_init函数定义在arch/x86/kernel/setup.c中，主要调用了init_ISA_irqs函数完成中断控制器8259A的初始化。 /** * x86_quirk_pre_intr_init - initialisation prior to setting up interrupt vectors * * Description: * Perform any necessary interrupt initialisation prior to setting up * the \"ordinary\" interrupt call gates. For legacy reasons, the ISA * interrupts should be initialised here if the machine emulates a PC * in any way. **/ void __init x86_quirk_pre_intr_init(void) { if (x86_quirks->arch_pre_intr_init) { if (x86_quirks->arch_pre_intr_init()) return; } init_ISA_irqs(); } /* init_ISA_irqs函数定义在arch/x86/kernel/irqinit_32.c中 */ void __init init_ISA_irqs(void) { int i; #ifdef CONFIG_X86_LOCAL_APIC init_bsp_APIC(); #endif init_8259A(0); // 完成8259A中断控制器的初始化 /* * 16 old-style INTA-cycle interrupts: */ for (i = 0; i status = IRQ_DISABLED; desc->action = NULL; desc->depth = 1; set_irq_chip_and_handler_name(i, &i8259A_chip, handle_level_irq, \"XT\"); } /* for循环中初始化了16个 irq_desc_t描述符，*/ } /* 其中 */ struct irq_chip i8259A_chip = { .name = \"XT-PIC\", .mask = disable_8259A_irq, .disable = disable_8259A_irq, .unmask = enable_8259A_irq, .mask_ack = mask_and_ack_8259A, }; handle_level_irq() 定义在 /kernel/irq/chip.c /* /kernel/irq/chip.c\" */ void set_irq_chip_and_handler_name(unsigned int irq, struct irq_chip *chip, irq_flow_handler_t handle, const char *name) { set_irq_chip(irq, chip); /* 设置chip */ __set_irq_handler(irq, handle, 0, name); /* 设置handle desc->handle_irq = handle; desc->name = name; */ } /* /kernel/irq/chip.c */ /** * set_irq_chip - set the irq chip for an irq * @irq: irq number * @chip: pointer to irq chip description structure */ int set_irq_chip(unsigned int irq, struct irq_chip *chip) { struct irq_desc *desc = irq_to_desc(irq); unsigned long flags; if (!desc) { WARN(1, KERN_ERR \"Trying to install chip for IRQ%d\\n\", irq); return -EINVAL; } if (!chip) chip = &no_irq_chip; spin_lock_irqsave(&desc->lock, flags); irq_chip_set_defaults(chip); desc->chip = chip; spin_unlock_irqrestore(&desc->lock, flags); return 0; } 之后循环调用set_intr_gate函数，完成中断门的初始化。循环中的几个宏定义如下。 /*arch/x86/include/asm/irq_vectors.h*/ /* * IDT vectors usable for external interrupt sources start * at 0x20: */ #define FIRST_EXTERNAL_VECTOR 0x20 #define NR_VECTORS 256 # define SYSCALL_VECTOR 0x80 即初始化IDT从0x20开始的256个中断门，并跳过0x80。set_intr_gate函数定义在arch/x86/include/asm/desc.h中，定义如下。 /* * This needs to use 'idt_table' rather than 'idt', and * thus use the _nonmapped_ version of the IDT, as the * Pentium F0 0F bugfix can have resulted in the mapped * IDT being write-protected. */ static inline void set_intr_gate(unsigned int n, void *addr) { BUG_ON((unsigned)n > 0xFF); _set_gate(n, GATE_INTERRUPT, addr, 0, 0, __KERNEL_CS); } /* 其中 GATE_INTERRUPT定义如下 arch/x86/include/asm/desc_defs.h\" enum { GATE_INTERRUPT = 0xE, GATE_TRAP = 0xF, GATE_CALL = 0xC, GATE_TASK = 0x5, }; */ 简单总结native_init_IRQ函数主要完成两个工作， 初始化中断控制器； 初始化struct desc主要是chip成员和handle_irq成员。 将interrupt[]数组中的中断服务程序地址写进了IDT中。 interrupt[]的定义 参考的第二项：中断之中断向量表IDT的初始化，有对这段代码的注释以及解释。 /*arch/x86/kernel/entry_32.S*/ /* * Build the entry stubs and pointer table with some assembler magic. * We pack 7 stubs into a single 32-byte chunk, which will fit in a * single cache line on all modern x86 implementations. */ .section .init.rodata,\"a\" ENTRY(interrupt) .text .p2align 5 .p2align CONFIG_X86_L1_CACHE_SHIFT ENTRY(irq_entries_start) RING0_INT_FRAME vector=FIRST_EXTERNAL_VECTOR .rept (NR_VECTORS-FIRST_EXTERNAL_VECTOR+6)/7 .balign 32 .rept 7 .if vector FIRST_EXTERNAL_VECTOR CFI_ADJUST_CFA_OFFSET -4 .endif 1: pushl $(~vector+0x80) /* Note: always in signed byte range */ CFI_ADJUST_CFA_OFFSET 4 .if ((vector-FIRST_EXTERNAL_VECTOR)%7) <> 6 jmp 2f .endif .previous .long 1b .text vector=vector+1 .endif .endr 2: jmp common_interrupt .endr END(irq_entries_start) .previous END(interrupt) .previous 主要包含两行代码pushl $(~vector+0x80)和jmp common_interrupt,即把中断号减去256的结果保存到栈中，然后调用通用中断处理程序。之所以要减去256，是因为内核用负数表示所有的中断，正数表示系统调用。 .rept语法 .rept count Repeat the sequence of lines between the .rept directive and the next .endr directive count times. For example, assembling .rept 3 .long 0 .endr is equivalent to assembling .long 0 .long 0 .long 0 参考 .IF、.ELSE、.ELSEIF 和 .ENDIF 伪指令使得程序员易于对多分支逻辑进行编码。它们让汇编器在后台生成 CMP 和条件跳转指令，这些指令显示在输出列表文件中。语法如下所示： .IF conditionl statements [.ELSEIF condition2 statements ] [.ELSE statements ] .ENDIF 方括号表示 .ELSEIF 和 .ELSE 是可选的，而 .IF 和 .ENDIF 则是必需的。condition（条件）是布尔表达式， 参考 数组中每个元素的初始值是标号1的地址。因此访问数组中的元素时，都会跳到标号1处，执行相应的指令。也就是，在除了0~19号和0x80号中断外，其余的所有中断在进入其自己的中断服务程序之前，必须是先条转执行common_interrupt的. common_interrupt的定义 /* * the CPU automatically disables interrupts when executing an IRQ vector, * so IRQ-flags tracing has to follow that: */ .p2align CONFIG_X86_L1_CACHE_SHIFT common_interrupt: addl $-0x80,(%esp) /* Adjust vector into the [-256,-1] range */ SAVE_ALL TRACE_IRQS_OFF movl %esp,%eax call do_IRQ jmp ret_from_intr ENDPROC(common_interrupt) CFI_ENDPROC 保存寄存器的值以后，栈顶的地址被存放到eax寄存器，然后中断处理程序调用do_IRQ()函数，执行do_IRQ()的ret指令时，控制跳转到ret_from_intr()。 do_IRQ函数 /* arch/x86/kernel/irq.c */ /* * do_IRQ handles all normal device IRQ's (the special * SMP cross-CPU interrupts have their own specific * handlers). */ unsigned int __irq_entry do_IRQ(struct pt_regs *regs) { struct pt_regs *old_regs = set_irq_regs(regs); /* high bit used in ret_from_ code */ unsigned vector = ~regs->orig_ax; // 取得对应的中断向量 unsigned irq; exit_idle(); irq_enter(); irq = __get_cpu_var(vector_irq)[vector]; if (!handle_irq(irq, regs)) { //调用中断处理句柄，对8259，就是handle_level_irq #ifdef CONFIG_X86_64 if (!disable_apic) ack_APIC_irq(); #endif if (printk_ratelimit()) printk(KERN_EMERG \"%s: %d.%d No irq handler for vector (irq %d)\\n\", __func__, smp_processor_id(), vector, irq); } irq_exit(); set_irq_regs(old_regs); return 1; } handle_irq 搜索发现此函数在arch/x86/kernel/irq_32.c\"中定义 bool handle_irq(unsigned irq, struct pt_regs *regs) { struct irq_desc *desc; int overflow; overflow = check_stack_overflow(); desc = irq_to_desc(irq); if (unlikely(!desc)) return false; if (!execute_on_irq_stack(overflow, desc, irq)) { if (unlikely(overflow)) print_stack_overflow(); desc->handle_irq(irq, desc); /* 在这里调用了之前注册的handler_irq函数 init_ISA_irqs() -> set_irq_chip_and_handler_name(i, &i8259A_chip, handle_level_irq, \"XT\"); -> __set_irq_handler(irq, handle, 0, name); -> desc->handle_irq = handle; 即handle_level_irq -> handle_IRQ_event(irq, action); -> do { ret = action->handler(irq, action->dev_id); action = action->next; } while (action); */ } return true; } 注册中断 在Linux内核申请中断的函数是request_irq(),函数原型定义在include/linux/interrupt.h中， request_irq(unsigned int irq, irq_handler_t handler, unsigned long flags, const char *name, void *dev); /* irq : 要申请的硬件中断号； handler : 中断服务函数指针； flags: 中断处理的属性， 若设置了IRQF_DISABLED则表示是快速中断，快速中断在处理过程中会屏蔽其他中断。 若设置了IRQD_SHARED则表示多个设备共享此中断。 若设置了IRQF_SAMPLE_RANDOM则表示对系统产生随机数有作用。 IRQF_TRIGGER_* 其中*可以是中断触发方式，定义在include/linux/interrupt.h中。 name : 中断名字，/proc/interrupts文件系统中显示； dev : 中断共享时可以用到，一般设置为这个设备的设备结构体或者NULL 返回值： 0 : 成功 ； -INVAL : 表示中断号无效或处理函数指针为NULL ； -EBUSY : 表示中断已经被占用且不能共享。 */ 关于request_irq()的最后一个参数dev 中断发生时，内核并不判断是共享中断线上的哪个设备产生了中断，它会循环执行所有该中断线上注册的所有中断服务函数（irqaction->handler函数）。因此irqaction->handler函数需要自己判断具体的中断源。很多资料都建议将设备结构指针作为此参数的值，当中断发生时，迅速根据硬件寄存器中的信息比照传入的dev参数判断是否是本设备发出的中断。而且free_irq()函数也需要据此判断从共享中断线上移除哪一个irqaction 代码流程 /*include/linux/interrupt.h*/ static inline int __must_check request_irq(unsigned int irq, irq_handler_t handler, unsigned long flags, const char *name, void *dev) { return request_threaded_irq(irq, handler, NULL, flags, name, dev); } extern void exit_irq_thread(void); #else extern int __must_check request_irq(unsigned int irq, irq_handler_t handler, unsigned long flags, const char *name, void *dev); 主要调用了request_threaded_irq()函数，此函数定义在kernel/irq/manage.c中， /** * request_threaded_irq - allocate an interrupt line * @irq: Interrupt line to allocate * @handler: Function to be called when the IRQ occurs. * Primary handler for threaded interrupts * @thread_fn: Function called from the irq handler thread * If NULL, no irq thread is created * @irqflags: Interrupt type flags * @devname: An ascii name for the claiming device * @dev_id: A cookie passed back to the handler function * * This call allocates interrupt resources and enables the * interrupt line and IRQ handling. From the point this * call is made your handler function may be invoked. Since * your handler function must clear any interrupt the board * raises, you must take care both to initialise your hardware * and to set up the interrupt handler in the right order. * * If you want to set up a threaded irq handler for your device * then you need to supply @handler and @thread_fn. @handler ist * still called in hard interrupt context and has to check * whether the interrupt originates from the device. If yes it * needs to disable the interrupt on the device and return * IRQ_THREAD_WAKE which will wake up the handler thread and run * @thread_fn. This split handler design is necessary to support * shared interrupts. * * Dev_id must be globally unique. Normally the address of the * device data structure is used as the cookie. Since the handler * receives this value it makes sense to use it. * * If your interrupt is shared you must pass a non NULL dev_id * as this is required when freeing the interrupt. * * Flags: * * IRQF_SHARED Interrupt is shared * IRQF_DISABLED Disable local interrupts while processing * IRQF_SAMPLE_RANDOM The interrupt can be used for entropy * IRQF_TRIGGER_* Specify active edge(s) or level * */ int request_threaded_irq(unsigned int irq, irq_handler_t handler, irq_handler_t thread_fn, unsigned long irqflags, const char *devname, void *dev_id) { struct irqaction *action; struct irq_desc *desc; int retval; /* * handle_IRQ_event() always ignores IRQF_DISABLED except for * the _first_ irqaction (sigh). That can cause oopsing, but * the behavior is classified as \"will not fix\" so we need to * start nudging drivers away from using that idiom. */ if ((irqflags & (IRQF_SHARED|IRQF_DISABLED)) == (IRQF_SHARED|IRQF_DISABLED)) { pr_warning( \"IRQ %d/%s: IRQF_DISABLED is not guaranteed on shared IRQs\\n\", irq, devname); } /*省略一些状态检查的代码*/ desc = irq_to_desc(irq); if (!desc) return -EINVAL; action = kzalloc(sizeof(struct irqaction), GFP_KERNEL); if (!action) return -ENOMEM; action->handler = handler; /* 注册中断服务函数 */ action->thread_fn = thread_fn; action->flags = irqflags; action->name = devname; action->dev_id = dev_id; retval = __setup_irq(irq, desc, action); if (retval) kfree(action); /* 省略一部分 */ return retval; } EXPORT_SYMBOL(request_threaded_irq); 首先从irq拿到struct desc，然后初始化了struct desc结构的action结构，最后调用了__setup_irq()函数。 __setup_irq()函数还调用了内核线程的创建kthread_create()等等，暂时不做分析。 中断处理流程 注册流程： 系统初始化时 : 调用init_IRQ()， 此函数间接调用init_ISA_irq()函数，初始化PIC以及struct irq_desc数组，填充了struct irq_desc元素的handler_irq和chip结构。之后调用set_intr_gate()将interrupts数组设置到系统的IDT中。 在内核代码中调用request_irq()函数，将中断服务程序注册到irqaction结构中，调用__setup_irq()函数。 中断发生时：先去IDT表中找到相应的中断门描述符，根据中断门描述符找到GDTR中相应的代码段，再根据中断门描述符中代码偏移，到相应代码段中找到中断服务程序入口，即common_interrupt，此函数先保存现场，然后将中断号压入栈，调用do_IRQ()函数，此函数调用desc->handle_irq即handle_level_irq，又调用了handle_IRQ_event()，此函数中循环调用action->handler()，间接调用到request_irq()函数注册的回调函数。 小结 本文主要基于x86平台对应linux 2.6.30.4版本的内核源码，对linux中断的初始化过程进行简单分析。还有一些东西没有弄懂，留待以后分析。 __setup_irq()函数； 中断发生时代码执行到action->handler()的过程； free_irq()的执行流程； 从中断中返回； 软中断及tasklet； 一些其他细节； 参考 x86体系结构下Linux-2.6.26的中断处理 中断之中断向量表IDT的初始化 Copyright © Yuanye.Ma 2020-2021 all right reserved，powered by Gitbook文件修订时间： 2023-04-02 10:05:52 "},"_posts/OS/编译内核文档.html":{"url":"_posts/OS/编译内核文档.html","title":"编译内核文档","keywords":"","body":"$ make htmldocs Documentation/Makefile:39: The 'sphinx-build' command was not found. Make sure you have Sphinx installed and in PATH, or set the SPHINXBUILD make variable to point to the full path of the 'sphinx-build' executable. Detected OS: Ubuntu 20.04.1 LTS. Warning: better to also install \"convert\". Warning: better to also install \"dot\". Warning: better to also install \"dvipng\". ERROR: please install \"ensurepip\", otherwise, build won't work. Warning: better to also install \"latexmk\". Warning: better to also install \"rsvg-convert\". Warning: better to also install \"xelatex\". You should run: sudo apt-get install imagemagick graphviz dvipng python3-venv latexmk librsvg2-bin texlive-xetex Warning: It is recommended at least Sphinx version 1.7.9. If you want pdf, you need at least 2.4.4. Note: It is recommended at least Sphinx version 2.4.4 if you need PDF support. /usr/bin/python3 -m venv sphinx_2.4.4 . sphinx_2.4.4/bin/activate pip install -r ./Documentation/sphinx/requirements.txt If you want to exit the virtualenv, you can use: deactivate Can't build as 2 mandatory dependencies are missing at ./scripts/sphinx-pre-install line 855. Documentation/Makefile:39: The 'sphinx-build' command was not found. Make sure you have Sphinx installed and in PATH, or set the SPHINXBUILD make variable to point to the full path of the 'sphinx-build' executable. Detected OS: Ubuntu 20.04.1 LTS. Warning: better to also install \"convert\". Warning: better to also install \"dot\". Warning: better to also install \"dvipng\". ERROR: please install \"ensurepip\", otherwise, build won't work. Warning: better to also install \"latexmk\". Warning: better to also install \"rsvg-convert\". Warning: better to also install \"xelatex\". You should run: sudo apt-get install imagemagick graphviz dvipng python3-venv latexmk librsvg2-bin texlive-xetex Warning: It is recommended at least Sphinx version 1.7.9. If you want pdf, you need at least 2.4.4. Note: It is recommended at least Sphinx version 2.4.4 if you need PDF support. /usr/bin/python3 -m venv sphinx_2.4.4 . sphinx_2.4.4/bin/activate pip install -r ./Documentation/sphinx/requirements.txt If you want to exit the virtualenv, you can use: deactivate Can't build as 2 mandatory dependencies are missing at ./scripts/sphinx-pre-install line 855. make[1]: *** [Documentation/Makefile:41：htmldocs] 错误 2 make: *** [Makefile:1669：htmldocs] 错误 2 # 安装依赖 $ sudo apt-get install imagemagick graphviz dvipng python3-venv latexmk librsvg2-bin texlive-xetex # make htmldocs Documentation/Makefile:39: The 'sphinx-build' command was not found. Make sure you have Sphinx installed and in PATH, or set the SPHINXBUILD make variable to point to the full path of the 'sphinx-build' executable. Detected OS: Ubuntu 20.04.1 LTS. Warning: It is recommended at least Sphinx version 1.7.9. If you want pdf, you need at least 2.4.4. Note: It is recommended at least Sphinx version 2.4.4 if you need PDF support. /usr/bin/python3 -m venv sphinx_2.4.4 . sphinx_2.4.4/bin/activate pip install -r ./Documentation/sphinx/requirements.txt If you want to exit the virtualenv, you can use: deactivate All optional dependencies are met. Can't build as 1 mandatory dependency is missing at ./scripts/sphinx-pre-install line 853. $ sudo apt install python3-pip $ /usr/bin/python3 -m venv sphinx_2.4.4 $ . sphinx_2.4.4/bin/activate $ pip3 install -r ./Documentation/sphinx/requirements.txt -i https://pypi.douban.com/simple $ make htmldocs #报错 htmldocs: @$(srctree)/scripts/sphinx-pre-install --version-check @+$(foreach var,$(SPHINXDIRS),$(call loop_cmd,sphinx,html,$(var),,$(var))) # commands; the 'cmd' from scripts/Kbuild.include is not *loopable* loop_cmd = $(echo-cmd) $(cmd_$(1)) || exit; # cmd_$(1) => cmd_sphinx # scripts/Kbuild.include # echo command. # Short version is used, if $(quiet) equals `quiet_', otherwise full one. echo-cmd = $(if $($(quiet)cmd_$(1)),\\ echo ' $(call escsq,$($(quiet)cmd_$(1)))$(echo-why)';) # $2 sphinx builder e.g. \"html\" # $3 name of the build subfolder / e.g. \"userspace-api/media\", used as: # * dest folder relative to $(BUILDDIR) and # * cache folder relative to $(BUILDDIR)/.doctrees # $4 dest subfolder e.g. \"man\" for man pages at userspace-api/media/man # $5 reST source folder relative to $(srctree)/$(src), # e.g. \"userspace-api/media\" for the linux-tv book-set at ./Documentation/userspace-api/media quiet_cmd_sphinx = SPHINX $@ --> file://$(abspath $(BUILDDIR)/$3/$4) # SPHINX htmldocs --> file:///home/myye/linux/Documentation/output # BUILDDIR = $(obj)/output cmd_sphinx = $(MAKE) BUILDDIR=$(abspath $(BUILDDIR)) $(build)=Documentation/userspace-api/media $2 && \\ PYTHONDONTWRITEBYTECODE=1 \\ BUILDDIR=$(abspath $(BUILDDIR)) SPHINX_CONF=$(abspath $(srctree)/$(src)/$5/$(SPHINX_CONF)) \\ $(PYTHON) $(srctree)/scripts/jobserver-exec \\ $(SHELL) $(srctree)/Documentation/sphinx/parallel-wrapper.sh \\ $(SPHINXBUILD) \\ -b $2 \\ -c $(abspath $(srctree)/$(src)) \\ -d $(abspath $(BUILDDIR)/.doctrees/$3) \\ -D version=$(KERNELVERSION) -D release=$(KERNELRELEASE) \\ $(ALLSPHINXOPTS) \\ $(abspath $(srctree)/$(src)/$5) \\ $(abspath $(BUILDDIR)/$3/$4) https://blog.csdn.net/yanlaifan/article/details/71402771 makefile foreach函数 https://blog.csdn.net/ly890700/article/details/52800734 makefile call函数 Copyright © Yuanye.Ma 2020-2021 all right reserved，powered by Gitbook文件修订时间： 2023-04-02 10:05:52 "},"_posts/others/2019-01-04-Git-tag常用命令.html":{"url":"_posts/others/2019-01-04-Git-tag常用命令.html","title":"2019-01-04-Git-tag常用命令","keywords":"","body":"Git-tag常用命令 列出标签 git tag 列出当前的所有taggit tag -l 'v0.1.*' 列出所有 v0.1.开头的标签 查看tag信息 git show 查看标签的版本信息 创建标签 创建附注标签 git tag -a v0.1.2 -m \"0.1.2版本\"-a 即 annotated的缩写，指定标签类型，后附注签名。git tag -s v0.1.2 -m \"0.1.2版本\"-s 即 signed的缩写，可以用 GPG 来签署标签。 验证标签：git tag -v [tag-name] （译注：取 verify 的首字母） 创建轻量级标签 git tag v1.4-lw 一般用于临时打标签。 后期添加标签 git tag -a v0.1.1 9fbc3d0后边的9fbc3d0是相应commit的校验和，通过git log 命令得到。 切换到标签 git checkout [tagname] 删除标签 git tag -d v0.1.2 标签发布 git push origin v0.1.2 将v0.1.2标签提交到git服务器git push origin --tags 将本地所有标签一次性提交到git服务器 得到tag的代码 git clone整个仓库； git checkout tag_name； 但是这个时候git处于“detached HEAD\" 状态，因为tag相当于一个快照，不能更改。如果需要在tag代码的基础上修改，需要先git checkout -b branch_name tag-name 创建一个分支，再在分支上进行修改。 Copyright © Yuanye.Ma 2020-2021 all right reserved，powered by Gitbook文件修订时间： 2023-04-02 10:05:52 "},"_posts/others/2019-01-04-Makefile中的一些神奇用法.html":{"url":"_posts/others/2019-01-04-Makefile中的一些神奇用法.html","title":"2019-01-04-Makefile中的一些神奇用法","keywords":"","body":"Makefile中的一些神奇用法 本文主要讲Makefile中的三个函数：1、wildcard : 扩展通配符2、notdir ： 去除路径3、patsubst ：替换通配符 前言 今天在读工程代码的时候无意间看到这样几行代码，大概意思猜出来了，但是说实话确实没注意过这样的用法，于是google一番，豁然开朗。 写一个例子看一下 先创建一下目录 .├── a│ ├── aa.c│ ├── ab.c│ └── ac.c├── a.c├── b.c└── c.c vim Makefile 并写入一下内容 1 SRC=$(wildcard *.c ./a/*.c) 2 DIR=$(notdir $(SRC)) 3 OBJ=$(patsubst %.c, %.o, $(SRC)) 4 5 all: 6 @echo $(SRC) 7 @echo $(DIR) 8 @echo $(OBJ) 执行make查看运行结果 a.c b.c c.c ./a/aa.c ./a/ab.c ./a/ac.ca.c b.c c.c aa.c ab.c ac.ca.o b.o c.o ./a/aa.o ./a/ab.o ./a/ac.o 分析执行过程 通过第一行的输出可以看出，wildcard的作用是用后边的通配符去匹配文件名。 通过第二行的输出可以看出，notdir的作用是省略掉文件名中的路径信息，只保留最后的文件名称。 通过第三行的输出可以看出，patsubst的作用是把$SRC中所有的.c文件名修改为.o ‘%’（百分号）表示匹配任意长度的子串 扩展 此外还有几种方法效果和OBJ=$(patsubst %.c, %.o, $(SRC))一样 Makefile中的变量替换引用 OBJ=$(SRC:.c=.o) Makefile中的自动推导规则 %.o:%.c gcc -c -o $@ $^ 最后给出全部代码 1 SRC=$(wildcard *.c ./a/*.c) 2 DIR=$(notdir $(SRC)) 3 #OBJ=$(patsubst %.c, %.o, $(SRC)) 4 OBJ=$(SRC:.c=.o) 5 6 %.o:%.c 7 @echo $@ 8 @echo $^ 9 @gcc -c -o $@ $^ 10 11 all:$(OBJ) 12 @echo $(SRC) 13 @echo $(DIR) 14 @echo $(OBJ) 15 16 clean: 17 rm -rf $(OBJ) 运行输出 a.oa.cb.ob.cc.oc.ca/aa.oa/aa.ca/ab.oa/ab.ca/ac.oa/ac.ca.c b.c c.c ./a/aa.c ./a/ab.c ./a/ac.ca.c b.c c.c aa.c ab.c ac.ca.o b.o c.o ./a/aa.o ./a/ab.o ./a/ac.o Copyright © Yuanye.Ma 2020-2021 all right reserved，powered by Gitbook文件修订时间： 2023-04-02 10:05:52 "},"_posts/others/2019-01-04-Shell中的source.html":{"url":"_posts/others/2019-01-04-Shell中的source.html","title":"2019-01-04-Shell中的source","keywords":"","body":"shell中fork、exec和source的区别 前言 在脚本中引用其他脚本有多种方式，直接执行./xx.sh，source xx.sh或者exec xx.sh,但是三种方式的本质是不通的。学过linux高级编程 或者对linux进程创建方式比较熟悉的理解起来可能比较容易一些。 简介 ./xx.sh fork 创建一个子进程（sub-shell），然后在子进程中运行调用的脚本，子进程继承父进程的资源（环境变量等等），在子进程中修改父进程的环境变量后，子进程退出后，并不影响父进程。写脚本的时候直接./xx.sh就是采用这种方式。 . ./xx.sh 或者 source xx.sh source 让 script 在当前 shell 内执行、 而不是产生一个 sub-shell 来执行。因此source执行的脚本中可以更改父进程的环境变量。 exec ./xx.sh exec 也是在原有进程中执行，但是，原有进程被终止。exec是用子进程替换父进程进行运行，所有父进程中exec后边的程序得不到运行。 注意 source和exec区别在于，原有进程是否被终止 实例分析 vim 1.sh 写入以下内容 1#!/bin/bash 2 A=B 3 echo \"PID for 1.sh before exec/source/fork:$$\" 4 export A 5 echo \"1.sh: \\$A is $A\" 6 case $1 in 7 exec) 8 echo \"using exec...\" 9 exec ./2.sh ;; 10 source) 11 echo \"using source...\" 12 #. ./2.sh ;; 13 source ./2.sh;; 14 *) 15 echo \"using fork by default...\" 16 ./2.sh ;; 17 esac 18 echo \"PID for 1.sh after exec/source/fork:$$\" 19 echo \"1.sh: \\$A is $A\" vim 2.sh 写入以下内容 1 #!/bin/bash 2 echo \"PID for 2.sh: $$\" 3 echo \"2.sh get \\$A=$A from 1.sh\" 4 A=C 5 export A 6 echo \"2.sh: \\$A is $A\" 分别运行./1.sh fork./1.sh source./1.sh exec运行结果 * ~/dep/selfcode * root→ # ./1.sh forkPID for 1.sh before exec/source/fork:310991.sh: $A is Busing fork by default...PID for 2.sh: 311002.sh get $A=B from 1.sh2.sh: $A is CPID for 1.sh after exec/source/fork:310991.sh: $A is B * ~/dep/selfcode * root→ # ./1.sh sourcePID for 1.sh before exec/source/fork:311051.sh: $A is Busing source...PID for 2.sh: 311052.sh get $A=B from 1.sh2.sh: $A is CPID for 1.sh after exec/source/fork:311051.sh: $A is C * ~/dep/selfcode * root→ # ./1.sh execPID for 1.sh before exec/source/fork:311101.sh: $A is Busing exec...PID for 2.sh: 311102.sh get $A=B from 1.sh2.sh: $A is C 注意：父进程后边的代码没有运行 以上除了fork，父进程和子进程的PID不同外，source和exec父进程和子进程的PID相同，但是，source相当于在父进程执行过程中插入了一段子进程的代码运行，而exec是用子进程的代码替换掉了父进程的空间。 Copyright © Yuanye.Ma 2020-2021 all right reserved，powered by Gitbook文件修订时间： 2023-04-02 10:05:52 "},"_posts/others/2019-01-04-Shell编程中变量引用方法.html":{"url":"_posts/others/2019-01-04-Shell编程中变量引用方法.html","title":"2019-01-04-Shell编程中变量引用方法","keywords":"","body":"Shell编程中$(())与$()还有${}的区别 先来看$() 在bash shell中, $()与``(反引号)都是用来做命令替换(command substitution)的。 例如 $ echo the last sunday is $(date -d \"last sunday\" +%Y-%m-%d) 在操作上， 用$()或``都无所谓,但在使用时有一些需要注意的地方。 反引号在多命令复合的时候需要加额外的转义， 即 command1 `command2 \\`command3\\` ` 要不然换成$()就没有问题了 command1 $(commmand2 $(command3)) 做多少层的替换都没有问题 ${} 接下来，再让我们看看${}吧...它其实就是用来做 变量替换用的啦。 一般情况下，$var与${var}并没有啥不一样。 但是用${}会比较精准的界定变量名称的范围，比方说: $ A=B $ echo $AB 原本是打算先将$A的结果替换出来， 然后在其后补一个字母B； 但命令行上， 真正的结果却是替换变量名称为AB的值出来... 若使用${}就没有问题了： $ A=B $ echo ${A}B #输出就是BB 例 #!/bin/bash A=B echo $A echo $AB echo $(A)B echo ${A}b 输出如下： B ./test.sh: line 6: A: command not foundBBb 此外${}还有更强大的功能 可以用${}分别替换获得不同的值 首先定义： file=/dir1/dir2/dir3/my.file.txt shell 字符串的非贪婪(最小匹配)左删除 ${file#*/} #其值为：dir1/dir2/dir3/my.file.txt 拿掉第一个/及其左边的字符串，其结果为：dir1/dir2/dir3/my.file.txt 。 ${file#*.} #其值为：file.txt 拿掉第一个.及其左边的字符串，其结果为： file.txt。 shell 字符串的贪婪(最大匹配)左删除 ${file##*/} #其值为：my.file.txt 拿掉最后一个/及其左边的字符串，其结果为：my.file.txt 。 ${file##*.} #其值为：.txt 拿掉最后一个.及其左边的字符串，其结果为： txt。 shell 字符串的非贪婪(最小匹配)右删除 ${file%/*} #其值为：/dir1/dir2/dir3 拿掉最后一个/及其右边的字符串，其结果为： /dir1/dir2/dir3。 ${file%.*} #其值为：/dir1/dir2/dir3/my.file 拿掉最后一个.及其右边的字符串，其结果为： /dir1/dir2/dir3/my.file。 shell 字符串的贪婪(最大匹配)右删除 ${file%%/*} #其值为：其值为空。 拿掉第一个/及其右边的字符串，其结果为： 空串。 ${file%%.*} #其值为：/dir1/dir2/dir3/my。 拿掉第一个.及其右边的字符串，其结果为： /dir1/dir2/dir3/my。 shell 字符串取子串 ${file:0:5} #提取最左边的5个字符：/dir1 ${file:5:5} #提取第5个字符及其右边的5个字符:/dir2 shell 字符串取子串的格式：${s:pos:length}, 取字符串 s 的子串：从 pos 位置开始的字符(包括该字符)的长度为 length 的的子串； 其中pos为子串的首字符，在 s 中位置； length为子串的长度； Note: 字符串中字符的起始编号为0 shell 字符串变量值的替换 ${file/dir/path} #将第一个dir替换为path：/path1/dir2/dir3/my.file.txt ${file//dir/path} #将全部的dir替换为path：/path1/path2/path3/my.file.txt shell 字符串变量值的替换格式： 首次替换： ${s/src_pattern/dst_pattern} 将字符串s中的第一个src_pattern替换为dst_pattern。全部替换： ${s//src_pattern/dst_pattern} 将字符串s中的所有出现的src_pattern替换为dst_pattern. 计算 shell 字符串变量的长度 ${#file} #其值为27, 因为/dir1/dir2/dir3/my.file.txt刚好为27个字符。 bash 数组(array)的处理方法 一般而言, A=\"a b c def\" 这样的变量只是将$A替换为一个字符串， 但是改为 A=(a b c def), 则是将$A定义为数组.... 数组替换方法可参考如下方法 ${A[@]} #方法一 ${A[*]} #方法二 以上两种方法均可以得到：a b c def, 即数组的全部元素。 访问数组的成员 ${A[0]}其中，${A[0]}可得到a, 即数组A的第一个元素， 而 ${A[1]}则为数组A的第二元素，依次类推。 数组的 length ${#A[@]} #方法一 ${#A[*]} #方法二 以上两种方法均可以得到数组的长度: 4, 即数组的所有元素的个数。 回忆一下，针对字符串的长度计算，使用${#str_var}； 我们同样可以将该方法应用于数组的成员: ${#A[0]}其中，${#A[0]}可以得到：1，即数组A的第一个元素(a)的长度； 同理，${#A[3]}可以得到: 3, 即数组A的第4个元素(def)的长度。 数组元素的重新赋值 A[3]=xyz $(())作用 $(())是用来作整数运算的。 在bash中， $(())的整数运算符号大致有这些： +- * / #分别为\"加、减、乘、除\"。 % #余数运算,(模数运算) & | ^ ! #分别为\"AND、OR、XOR、NOT\"运算。 例如： $ a=5; b=7; c=2; $ echo $(( a + b * c )) 19 $ echo $(( (a + b)/c )) 6 $ echo $(( (a * b) % c )) 1 在$(())中的变量名称， 可以在其前面加 $符号来替换， 也可以不用，如： $(( $a + $b * $c )) 也可以得到19的结果。 此外，$(())还可作不同进制(如二进制、八进制、十六进制)的运算， 只是输出结果均为十进制的。 echo $(( 16#2a )) 输出结果为：42，(16进制的2a) 以一个实用的例子来看看吧 : 假如当前的umask是022,那么新建文件的权限即为： $ umask 022 $ echo \"obase=8; $(( 8#666 & (8#777 ^ 8#$(umask)) ))\" | bc 644 事实上，单纯用(())也可以重定义变量值，或作 testing： a=5; ((a++)) #可将$a 重定义为6 a=5; ((a--)) #可将$a 重定义为4 a=5; b=7; ((a Note:使用(())作整数测试时， 请不要跟[]的整数测试搞混乱了。 Copyright © Yuanye.Ma 2020-2021 all right reserved，powered by Gitbook文件修订时间： 2023-04-02 10:05:52 "},"_posts/others/2019-07-20-tensorboardX的简单用法.html":{"url":"_posts/others/2019-07-20-tensorboardX的简单用法.html","title":"2019-07-20-tensorboardX的简单用法","keywords":"","body":"pytorch+tensorboardX 简单总结一下tensorboardX的用法。 import numpy as np from tensorboardX import SummaryWriter write = SummaryWriter() for epoch in range(100): write.add_scalar('scale/test', np.random.rand(), epoch) write.add_scalars('scale/scales_test', {'xsinx':epoch*np.sin(epoch), 'xcosx' : epoch*np.cos(epoch)}, epoch) write.close() 在终端中运行上边代码:python ./tensorboard_scales.py，查看代码目录下多了一个runs的目录，里边保存的就是代码运行时的数据。 再使用tensorboard --logdir runs,在浏览器地址栏输入ip_address:6006就能看到图像。 此时再次运行代码，再查看目录结构，会发现又多了一些目录，这是因为tensorboard会保存几个历史版本。这个功能很好用，可以通过点击左下角的复选框勾选要对比的曲线，进而对比模型的性能。 试试graph import torch import torch.nn as nn import torch.nn.functional as F from tensorboardX import SummaryWriter class Net1(nn.Module): def __init__(self): super(Net1, self).__init__() self.conv1 = nn.Conv2d(1, 10, kernel_size=5) self.conv2 = nn.Conv2d(10, 20, kernel_size=5) self.conv2_drop = nn.Dropout2d() self.fc1 = nn.Linear(320, 50) self.fc2 = nn.Linear(50, 10) self.bn = nn.BatchNorm2d(20) def forward(self, x): x = F.max_pool2d(self.conv1(x), 2) x = F.relu(x) + F.relu(-x) x = F.relu(F.max_pool2d(self.conv2_drop(self.conv2(x)), 2)) x = self.bn(x) x = x.view(-1, 320) x = F.relu(self.fc1(x)) x = F.dropout(x, training=self.training) x = self.fc2(x) x = F.softmax(x, dim=1) return x dummy_input = torch.rand(13, 1, 28, 28) model = Net1() with SummaryWriter(comment='Net1') as w: w.add_graph(model, (dummy_input,)) 在运行的时候报错了。 上网搜索了一番说是pytorch版本的问题，为了跑写好的强化学习的代码，我用的是比较老的0.4.0版本的，回头有机会测一下pytorch 1.0+的看可不可以用。 总结一下TensorboardX的用法 声明一个SummaryWriter()对象，log_dir参数能指定log文件保存的路径。 然后使用add_xxx()函数向log中添加内容，xxx可以是scalar, image, figure, histogram, audio, text, graph, onnx_graph, embedding, pr_curve, mesh, hyper-parameters and video，详情参见或者tensorboardX。 关闭SummaryWriter()对象 使用tensorboard --logdir命令启动tensorboard 在浏览器里查看输出。 TensorFlow+TensorBoard 参考这篇blog 总结一下使用的步骤 建立一个计算图（Graph） 确定要在Graph中的哪些节点放置summary operations（即要在tensorboard中观察哪些数据） tf.summary.scalar - 记录标量 tf.summary.histogram - 记录数据的直方图 tf.summary.image - 记录图片 tf.summary.audio - 记录音频 tf.summary.graph - 记录计算图结构 tf.summary.distribution - 记录数据分布 tf.summary.embeddings - 记录嵌入向量 tf.summary.text - 记录文本 使用tf.summary.merge_all将所有summary operations合并为一个operation 运行3中合并之后的operation:summary = sess.run(all_summary) 声明一个FileWriter对象：writer = tf.summary.FileWriter(\"./train\", graph) #如果有graph参数，可以在tensorboard中查看graph的结构。 使用tf.summary.FileWriter将数据写入本地磁盘: writer.add_summary(summary, steps) 运行程序后，使用tensorboard --logdir=logdir启动tensorboard,然后在浏览器中查看。 参考代码 import tensorflow as tf from tensorflow.examples.tutorials.mnist import input_data max_steps = 1000 # 最大迭代次数 learning_rate = 0.001 # 学习率 dropout = 0.9 # dropout时随机保留神经元的比例 data_dir = './' # 样本数据存储的路径 log_dir = './' # 输出日志保存的路径 mnist = input_data.read_data_sets(data_dir, one_hot=True) sess = tf.InteractiveSession() with tf.name_scope('input'): x = tf.placeholder(tf.float32, [None, 784], name='x-input') y_ = tf.placeholder(tf.float32, [None, 10], name='y-input') with tf.name_scope('input_reshape'): image_shaped_input = tf.reshape(x, [-1, 28, 28, 1]) tf.summary.image('input', image_shaped_input, 10) def weight_variable(shape): \"\"\"Create a weight variable with appropriate initialization.\"\"\" initial = tf.truncated_normal(shape, stddev=0.1) return tf.Variable(initial) def bias_variable(shape): \"\"\"Create a bias variable with appropriate initialization.\"\"\" initial = tf.constant(0.1, shape=shape) return tf.Variable(initial) def variable_summaries(var): \"\"\"Attach a lot of summaries to a Tensor (for TensorBoard visualization).\"\"\" with tf.name_scope('summaries'): # 计算参数的均值，并使用tf.summary.scaler记录 mean = tf.reduce_mean(var) tf.summary.scalar('mean', mean) # 计算参数的标准差 with tf.name_scope('stddev'): stddev = tf.sqrt(tf.reduce_mean(tf.square(var - mean))) # 使用tf.summary.scaler记录记录下标准差，最大值，最小值 tf.summary.scalar('stddev', stddev) tf.summary.scalar('max', tf.reduce_max(var)) tf.summary.scalar('min', tf.reduce_min(var)) # 用直方图记录参数的分布 tf.summary.histogram('histogram', var) def nn_layer(input_tensor, input_dim, output_dim, layer_name, act=tf.nn.relu): \"\"\"Reusable code for making a simple neural net layer. It does a matrix multiply, bias add, and then uses relu to nonlinearize. It also sets up name scoping so that the resultant graph is easy to read, and adds a number of summary ops. \"\"\" # 设置命名空间 with tf.name_scope(layer_name): # 调用之前的方法初始化权重w，并且调用参数信息的记录方法，记录w的信息 with tf.name_scope('weights'): weights = weight_variable([input_dim, output_dim]) variable_summaries(weights) # 调用之前的方法初始化权重b，并且调用参数信息的记录方法，记录b的信息 with tf.name_scope('biases'): biases = bias_variable([output_dim]) variable_summaries(biases) # 执行wx+b的线性计算，并且用直方图记录下来 with tf.name_scope('linear_compute'): preactivate = tf.matmul(input_tensor, weights) + biases tf.summary.histogram('linear', preactivate) # 将线性输出经过激励函数，并将输出也用直方图记录下来 activations = act(preactivate, name='activation') tf.summary.histogram('activations', activations) # 返回激励层的最终输出 return activations hidden1 = nn_layer(x, 784, 500, 'layer1') with tf.name_scope('dropout'): keep_prob = tf.placeholder(tf.float32) tf.summary.scalar('dropout_keep_probability', keep_prob) dropped = tf.nn.dropout(hidden1, keep_prob) y = nn_layer(dropped, 500, 10, 'layer2', act=tf.identity) with tf.name_scope('loss'): # 计算交叉熵损失（每个样本都会有一个损失） diff = tf.nn.softmax_cross_entropy_with_logits(labels=y_, logits=y) with tf.name_scope('total'): # 计算所有样本交叉熵损失的均值 cross_entropy = tf.reduce_mean(diff) tf.summary.scalar('loss', cross_entropy) with tf.name_scope('train'): train_step = tf.train.AdamOptimizer(learning_rate).minimize( cross_entropy) with tf.name_scope('accuracy'): with tf.name_scope('correct_prediction'): # 分别将预测和真实的标签中取出最大值的索引，弱相同则返回1(true),不同则返回0(false) correct_prediction = tf.equal(tf.argmax(y, 1), tf.argmax(y_, 1)) with tf.name_scope('accuracy'): # 求均值即为准确率 accuracy = tf.reduce_mean(tf.cast(correct_prediction, tf.float32)) tf.summary.scalar('accuracy', accuracy) # summaries合并 merged = tf.summary.merge_all() # 写到指定的磁盘路径中 train_writer = tf.summary.FileWriter(log_dir + '/train', sess.graph) test_writer = tf.summary.FileWriter(log_dir + '/test') # 运行初始化所有变量 tf.global_variables_initializer().run() def feed_dict(train): \"\"\"Make a TensorFlow feed_dict: maps data onto Tensor placeholders.\"\"\" if train: xs, ys = mnist.train.next_batch(100) k = dropout else: xs, ys = mnist.test.images, mnist.test.labels k = 1.0 return {x: xs, y_: ys, keep_prob: k} for i in range(max_steps): if i % 10 == 0: # 记录测试集的summary与accuracy summary, acc = sess.run([merged, accuracy], feed_dict=feed_dict(False)) test_writer.add_summary(summary, i) print('Accuracy at step %s: %s' % (i, acc)) else: # 记录训练集的summary if i % 100 == 99: # Record execution stats run_options = tf.RunOptions(trace_level=tf.RunOptions.FULL_TRACE) run_metadata = tf.RunMetadata() summary, _ = sess.run([merged, train_step], feed_dict=feed_dict(True), options=run_options, run_metadata=run_metadata) train_writer.add_run_metadata(run_metadata, 'step%03d' % i) train_writer.add_summary(summary, i) print('Adding run metadata for', i) else: # Record a summary summary, _ = sess.run([merged, train_step], feed_dict=feed_dict(True)) train_writer.add_summary(summary, i) train_writer.close() test_writer.close() Copyright © Yuanye.Ma 2020-2021 all right reserved，powered by Gitbook文件修订时间： 2023-04-02 10:05:52 "},"_posts/others/2019-07-29-stl入门.html":{"url":"_posts/others/2019-07-29-stl入门.html","title":"2019-07-29-stl入门","keywords":"","body":"复习 strcpy(str1, str2); // 字符串拷贝函数 strcat(str1, str2); // 字符串拼接函数，将str2的内容拼接到str1后边 strcmp(str1, str2); // 字符串比较函数， str1>str2时输出的是正整数，str1 STL入门 vector vector：可变长数组 创建vector的四种方法 // 第一种创建vector的方法 vector values; // 第二种创建vector的方法 vector values1(20); // 第三种创建vector的方法 vector numbers(20, 2.3); //不仅开辟了20个元素的空间，并且给每个元素赋初值为2.3 // 第四种创建vector的方法 double d[6] = {1,2,3,4,5,6}; vector words(d+1, d+5); // 给定一个区间，将区间内的数据拷贝到vector中作为初值。 修改vector的数据 //修改vector内部的数据 cout 删除vector中的数据 // 从vecotr中删除元素 cout 迭代器 // 迭代器的应用 vector::iterator it=words.begin(); //让it指向words的第一个元素 while(it!=words.end()){ // 如果it不指向words的最后一个元素，就执行循环体 cout::iterator it=words.begin(); it!=words.end(); it++) cout stack “先进后出”数据结构 #include #include using namespace std; int main() { stack st; // 创建一个栈容器 char str[] = \"abcdefgj\"; for(int i=0; str[i]!='\\0'; i++) st.push(str[i]); // 将元素入栈 // 出栈 while(!st.empty()) { cout stack三种操作：创建、入栈、出栈 queue \"先进先出\"数据结构 #include #include using namespace std; int main() { queue q; char str[]=\"abckegf\"; // 入队 for (int i=0; str[i]!='\\0'; i++) { cout queue三种操作：创建、入队、出队 set #include #include //引入头文件 using namespace std; int main() { set st1; // 创建一个set容器 set::iterator it; // 创建一个set容器的迭代器 if (st1.empty()) cout 创建、插入元素、删除元素、查找元素 map #include #include #include using namespace std; int main() { map id_name; map::iterator it; cout 创建、插入元素、查找元素、删除元素 掌握下边统计字符出现次数的程序 #include #include #include using namespace std; int main() { map wordt; char a[100000]; cin>>a; int len = strlen(a); for (int i=0; i::iterator it; for (it=wordt.begin(); it!=wordt.end(); it++) { //cout string的常用操作 搜索操作 string类提供了6个不同的搜索函数，每个函数有4个重载版本。每个操作都返回一个string::size_type值。表示匹配发生位置的下标。如果搜索失败，则返回一个名为string::npos 的static成员。（const string::size_type npos=-1，是一个unsigned类型） 函数名 解释 s.find(args) 查找s中args第一次出现的位置 s.rfind(args) 查找s中args最后一次出现的位置 s.find_first_of(args) 在s中查找args中任何一个字符第一次出现的位置 s.find_last_of(args) 在s中查找args中任何一个字符最后一次出现的位置 s.find_first_not_of(args) 在s中查找第一个不在args中的字符 s.find_last_not_of(args) 在s中查找最后一个不在args中的字符 args的4种重载 |类别|解释| | --- | --- | | c ,pos | 从s中位置pos开始查找字符c， pos默认为0 | | s2, pos | 从s中位置pos开始查找字符串s2， pos默认为0 | | cp, pos | 从s中位置pos开始查找指针cp指向的以空字符串结尾的c风格字符串， pos默认为0 | | cp, pos, n | 从s中位置pos开始查找指针cp指向的数组的前n个字符。pos和n无默认值 | Eg1: string name(\"AnnaBelle\"); auto pos = name.find(\"Anna\"); // pos = 0 auto pos = name.find(\"anna\"); // pos = string::npos string numbers(\"0123456789\"), name(\"r2d2\"); auto pos = name.find_first_of(numbers); // pos = 1 string dept(\"0375p3\"); auto pos = dept.find_first_not_of(numbers); // pos = 4 Eg2: string::size_type pos = 0; // 每步循环查找name中下一个数字。 while ((pos = name.find_first_of(numbers, pos)) != string::npos) { cout 构造操作 函数 解释 string s(cp, n) s是cp指向的数组中前n个字符的拷贝。此数组至少应该包含n个字符 string s(s2, pos2) s是string s2从下标pos2开始的字符的拷贝 string s(s2, pos2, len2) s是s2从下标pop2开始len2个字符的拷贝 这些构造函数接受一个string或者一个const char *参数，还接受指定拷贝多少个字符的参数。 const char *cp = \"hello world!!\"; // 以空字符结束的数组 char noNull[] = {'H','e'}; // 不是以空字符结束 string s1(cp); // 拷贝cp中的字符直到遇到空字符， s1 = \"hello world!!\" string s2(noNull, 2); // 从noNull中拷贝两个字符 string s3(noNull); // 未定义，noNull不是以空字符结束的 string s4(cp+6, 5); // 从cp[6]开始拷贝5个字符 s4 = \"world\" string s5(s1, 6, 5); // 从cp[6]开始拷贝5个字符 s5 = \"world\" string s6(s1, 6); // 从cp[6]开始拷贝直到结尾 s6 = \"world！！\" string s7(s1, 6, 20); // 从cp[6]开始拷贝直到结尾 s7 = \"world！！\" string s8(s1, 16); // 抛出一个out_of_range异常 通常从const char *创建string时，只恨指向的数组必须以空字符结尾，拷贝操作遇到空字符时停止。如果未传递计数值且数组也未以空字符结尾，或者给定的计数值大于数组大小，则构造函数的行为是未定义的。 当从string拷贝字符串时，我们可以提供一个可选的开始位置和一个计数值。开始位置必须小于或者等于个定的string的大小。如果位置大于size，则构造函数抛出一个out_of_range异常。如果我们传递一个计数值，则从给定位置开始拷贝这么多个字符。不管要求拷贝多少个字符，最多拷贝到string的结尾。 substr substr操作返回一个string string s(\"hello world\"); string s2 = s.substr(0, 5); // s2 = hello string s3 = s.substr(6); // s3 = world string s4 = s.substr(6, 11);// s4 = world string s5 = s.substr(12); // 抛出一个out_of_range的异常 Copyright © Yuanye.Ma 2020-2021 all right reserved，powered by Gitbook文件修订时间： 2023-04-02 10:05:52 "},"_posts/others/2019-08-06-C++继承.html":{"url":"_posts/others/2019-08-06-C++继承.html","title":"2019-08-06-C++继承","keywords":"","body":"C++继承和多态 继承 语法 class 子类名/派生类名 ： 继承方式 父类名/基类名 { }; 继承方式 public : 公共权限，类内/外都可以直接访问； protected : 保护权限，类内部以及子类内部可以直接访问，类外不能访问； private ： 私有权限，只能在类内部访问； class Base { public: int m_A; protected: int m_B; private: int m_C; }; //公共继承 class Son : public Base { // 父类中public修饰的属性，在子类中仍然是public的 // 父类中protected修饰的属性，在子类中仍然是protected的 // 父类中private修饰的属性，在子类中不可见 }; //保护继承 class Son : protected Base { // 父类中public修饰的属性，在子类中变为protected的 // 父类中protected修饰的属性，在子类中仍然是protected的 // 父类中private修饰的属性，在子类中不可见 }; //私有继承 class Son : private Base { // 父类中public修饰的属性，在子类中变为private的 // 父类中protected修饰的属性，在子类中变为private的 // 父类中private修饰的属性，在子类中不可见 }; 继承中的构造和析构 class Base { public: Base(int a) { m_A = a; } int m_A; } class Son: public Base { public: Son(int a):Base(a) //在初始化列表中调用父类的构造函数 { } } 先构造父类对象，然后创建子类对象。析构顺序和构造相反。 但是子类不会继承父类的构造函数和析构函数。 多继承 class Base1 { Base1() { m_A = 10; } int m_A; }; class Base2 { Base2() { m_B = 100; // 假如此变量也是m_A 在 Son s; s.m_A=10时会出现二义性。 } int m_B; }; class Son: public Base1, public Base2 { int m_C; int m_D; } cout 菱形继承 class Animal { public: int m_Age; } class Sheep: public Animal { } class Tuo: public Animal { } class SheepTuo: public Sheep, public Tuo { } SheepTuo st; st.Sheep::m_Age = 10 st.Tuo::m_Age = 20 // 相互不影响，但是会造成冗余甚至二义性 cout 菱形继承的解决方案，利用虚继承 class Animal { public: int m_Age; } // 虚基类 class Sheep: public Animal { } // 虚基类 class Tuo: virtual public Animal { } class SheepTuo: public Sheep, public Tuo { } SheepTuo st; st.Sheep::m_Age = 10 st.Tuo::m_Age = 20 cout 继承中的对象模型 class Base{ public: int m_A; protected: int m_B; private: int m_C; }; class Son:public Base { public: int m_D; }; void test01() { cout Vs2013 开发人员命令提示工具 可以查看对象模型 先cd到cpp文件所造的目录 cl /d1 reportSingleClassLayout类名 cpp文件名 继承中的同名成员处理 class Base { public: Base() { m_A = 100; } void func() { cout 防止继承的方式 class NoDrived final{...} // 类名后加final说明此类不能被继承 多态 静态联编：程序在编译的时候确定，函数重载就是静态联编形式 动态联编：程序在执行时确定 class Animal { speak() { cout 虚函数表 class Animal { speak() { coutspeak(); //输出 ”喵喵喵“ 多态原理解析 当父类中有了虚函数后，内部结构发生了改变 内部多了一个vfptr,指向虚函数表。 父类中结构vfptr &Animal::speak 构造函数中，会将虚函数表指针，指向自己的虚函数表 如果发生了重写，会替换掉虚函数表中原有的speak 改为&Cat::speak 虚函数 non-virtual函数：你不希望derived class重新定义（overrude， 覆写，虚函数被重新定义）它 virtual函数 : 你希望derived class重新定义（overrude）它，它已经有了一个默认的定义，可以不override。 pure-virtual函数 ： 你希望derived class重新定义（overrude）它，必须要override， 没有默认定义。 任何构造函数外的非静态函数都可以是虚函数。 class Shape { public: virtual void draw() const = 0; // 纯虚函数 virtual void error(); //虚函数 int objectlD() const; //非虚函数 }; class Rectabgle: public Shape{...}; class Ellipse: public Shape{...}; 一道题 64位电脑运行以下c++代码结果输出什么？ class A{ char a[2]; public: virtual void aa(){} }; class B:public virtual A{ char b[2]; char a[2]; public: virtual void bb(){}; virtual void aa(){}; }; class C:public virtual B{ char a[2]; char b[2]; char c[2]; public: virtual void cc(){}; virtual void aa(){}; virtual void bb(){}; }; int main() { cout 64位机器所以指针占8个字节的内存。 对于类A：a占两个字节的内存，八字节内存对齐，后边的虚函数表是个指针因此也占8个字节的内存，因此sizeof(A) = 16B; 由于B继承自A，因此B内又完全包含一个A，a+b=4个字节仍然不满8个字节，仍然需要填充4个字节来保持内存对齐，因此sizeof(B) = 16+16 = 32B。 同理sizeof(C) = 48B。 Copyright © Yuanye.Ma 2020-2021 all right reserved，powered by Gitbook文件修订时间： 2023-04-02 10:05:52 "},"_posts/others/uboot.html":{"url":"_posts/others/uboot.html","title":"Uboot","keywords":"","body":"uboot make xxx_defconfig Top Makefile : %config 依赖 scripts_basic $(Q)$(MAKE) $(build)=scripts/basic $(build) 定义在 scripts/Kbuild.include中 build := -f $(srctree)/scripts/Makefile.build obj 即 命令展开为 @ make -f $(srctree)/scripts/Makefile.build obj=scripts/basic 编译生成了 scripts/basic/fixdep outputmakefile FORCE 命令 $(Q)$(MAKE) $(build)=scripts/kconfig $@ 展开为 @ make -f $(srctree)/scripts/Makefile.build obj=scripts/kconfig xxx_defconfig src = scripts/kconf kbuild-dir = scripts/kconf kbuild-file = scripts/kconf/Makefile include scripts/kconf/Makefile # xxx_defconfig 目标定义在这个文件中 %_defconfig: $(obj)/conf $(Q)$$ 即展开为 @scripts/kconfig/conf -s --defconfig=arch/$(SRCARCH)/configs/xxx_defconfig $(Kconfig) 通过对conf源码的分析，大概知道conf程序用于维护 .config ， 如果传入了--defconfig参数就读取 Kconfig文件生成 .config文件 如果传入了 --silentoldconfig （在make 整个u-boot时）则生成以下文件 include/generated/autoconf.h 是C语言头文件，主要影响C语言编译过程。 include/config/auto.conf.cmd include/config/tristate.conf include/config/auto.conf 被顶层Makefile包含，影响编译过程。 make Copyright © Yuanye.Ma 2020-2021 all right reserved，powered by Gitbook文件修订时间： 2023-04-02 10:05:52 "},"_posts/others/基于Ubuntu进行STM32程序开发.html":{"url":"_posts/others/基于Ubuntu进行STM32程序开发.html","title":"基于Ubuntu进行STM32程序开发","keywords":"","body":"基于Ubuntu进行STM32程序开发 platform info Ubuntu version : Ubuntu 20.04.1 LTS正点原子 STM32f767 阿波罗开发板st-link version : v1.6.1-201-g4bfaab0openocd version : 0.10.0Cross Compiler : gcc-arm-none-eabi (9.2.1 20191025 release) install stlink driver sudo apt install libusb-1.0-0-dev gcc build-essential cmake libusb-1.0-0 git clone https://github.com/texane/stlink.git cd stlink make clean make release make debug sudo cp -a config/udev/rules.d/* /etc/udev/rules.d/ sudo udevadm control --reload-rules sudo udevadm trigger cd build/Release/bin/ echo \"export PATH=\\$PATH:`pwd` \" >> ~/.bashrc source ~/.bashrc test $ st-info --probe Found 1 stlink programmers serial: 323f68064248323848522157 hla-serial: \"\\x32\\x3f\\x68\\x06\\x42\\x48\\x32\\x38\\x48\\x52\\x21\\x57\" flash: 2097152 (pagesize: 2048) sram: 524288 chipid: 0x0451 descr: F76xxx openocd #git clone https://github.com/ntfreak/openocd.git sudo apt install openocd test 将st-link和开发板相连，并给板子上电。 $ openocd -f /usr/share/openocd/scripts/interface/stlink-v2.cfg -f /usr/share/openocd/scripts/target/stm32f7x.cfg Open On-Chip Debugger 0.10.0 Licensed under GNU GPL v2 For bug reports, read http://openocd.org/doc/doxygen/bugs.html Info : auto-selecting first available session transport \"hla_swd\". To override use 'transport select '. Info : The selected transport took over low-level target control. The results might differ compared to plain JTAG/SWD adapter speed: 2000 kHz adapter_nsrst_delay: 100 srst_only separate srst_nogate srst_open_drain connect_deassert_srst Info : Unable to match requested speed 2000 kHz, using 1800 kHz Info : Unable to match requested speed 2000 kHz, using 1800 kHz Info : clock speed 1800 kHz Info : STLINK v2 JTAG v35 API v2 SWIM v7 VID 0x0483 PID 0x3748 Info : using stlink api v2 Info : Target voltage: 3.230647 Info : stm32f7x.cpu: hardware has 8 breakpoints, 4 watchpoints 创建工程 可以直接使用 stm32CubeMX 生成 Makefile 工程 。 . ├── Core │ ├── Inc │ │ ├── gpio.h │ │ ├── main.h │ │ ├── stm32f7xx_hal_conf.h │ │ └── stm32f7xx_it.h │ └── Src │ ├── gpio.c │ ├── main.c │ ├── stm32f7xx_hal_msp.c │ ├── stm32f7xx_it.c │ └── system_stm32f7xx.c ├── Drivers │ ├── CMSIS │ │ ├── Device │ │ └── Include │ └── STM32F7xx_HAL_Driver │ ├── Inc │ └── Src ├── led.ioc ├── Makefile ├── startup_stm32f767xx.s └── STM32F767IGTx_FLASH.ld 其中 STM32F7xx_HAL_Driver 存储的是HAL的代码，此处不再展开。 CMSIS的内容如下 ./Drivers/CMSIS/ ├── Device │ └── ST │ └── STM32F7xx │ └── Include │ ├── stm32f767xx.h │ ├── stm32f7xx.h │ └── system_stm32f7xx.h └── Include ├── cmsis_compiler.h ├── cmsis_gcc.h ├── cmsis_version.h ├── core_cm7.h └── mpu_armv7.h 中最重要的也是和Keil中不一样的地方，就是以下三个部分 Makefile 链接器脚本 STM32F767IGTx_FLASH.ld 启动文件 startup_stm32f767xx.s 内容都比较简单，此处不列出来了。 编译代码 $ sudo apt install gcc-arm-none-eabi $ cd led # 进入到工程目录 $ make 烧写代码 打开openocd服务 打开一个Terminal窗口输入以下命令后回车 openocd -f /usr/share/openocd/scripts/interface/stlink-v2.cfg -f /usr/share/openocd/scripts/target/stm32f7x.cfg 执行过程如下 $ openocd -f /usr/share/openocd/scripts/interface/stlink-v2.cfg -f /usr/share/openocd/scripts/target/stm32f7x.cfg Open On-Chip Debugger 0.10.0 Licensed under GNU GPL v2 For bug reports, read http://openocd.org/doc/doxygen/bugs.html Info : auto-selecting first available session transport \"hla_swd\". To override use 'transport select '. Info : The selected transport took over low-level target control. The results might differ compared to plain JTAG/SWD adapter speed: 2000 kHz adapter_nsrst_delay: 100 srst_only separate srst_nogate srst_open_drain connect_deassert_srst Info : Unable to match requested speed 2000 kHz, using 1800 kHz Info : Unable to match requested speed 2000 kHz, using 1800 kHz Info : clock speed 1800 kHz Info : STLINK v2 JTAG v35 API v2 SWIM v7 VID 0x0483 PID 0x3748 Info : using stlink api v2 Info : Target voltage: 3.239128 Info : stm32f7x.cpu: hardware has 8 breakpoints, 4 watchpoints # -------------------------------------- 下边的内容是执行客户端指令时的输出 Info : accepting 'telnet' connection on tcp/4444 target halted due to debug-request, current mode: Thread xPSR: 0x81000000 pc: 0x08001142 msp: 0x2007ffe8 target halted due to debug-request, current mode: Thread xPSR: 0x01000000 pc: 0x0800116c msp: 0x20080000 ** Programming Started ** auto erase enabled Info : device id = 0x10016451 Info : flash size = 1024kbytes Info : Single Bank 1024 kiB STM32F76x/77x found target halted due to breakpoint, current mode: Thread xPSR: 0x61000000 pc: 0x20000046 msp: 0x20080000 wrote 32768 bytes from file build/led.bin in 2.035821s (15.718 KiB/s) ** Programming Finished ** ** Verify Started ** target halted due to breakpoint, current mode: Thread xPSR: 0x61000000 pc: 0x2000002e msp: 0x20080000 verified 4612 bytes in 0.716718s (6.284 KiB/s) ** Verified OK ** shutdown command invoked Info : dropped 'telnet' connection telnet 到 openocd 服务 再打开一个Terminal窗口，输入 telnet localhost 4444 , 之后在提示符后输入下边指令 > halt > program build/led.bin 0x8000000 verify > shutdown 执行过程如下： $ telnet localhost 4444 Trying 127.0.0.1... Connected to localhost. Escape character is '^]'. Open On-Chip Debugger > halt target halted due to debug-request, current mode: Thread xPSR: 0x81000000 pc: 0x08001142 msp: 0x2007ffe8 > program build/led.bin 0x8000000 verify target halted due to debug-request, current mode: Thread xPSR: 0x01000000 pc: 0x0800116c msp: 0x20080000 ** Programming Started ** auto erase enabled device id = 0x10016451 flash size = 1024kbytes Single Bank 1024 kiB STM32F76x/77x found target halted due to breakpoint, current mode: Thread xPSR: 0x61000000 pc: 0x20000046 msp: 0x20080000 wrote 32768 bytes from file build/led.bin in 2.035821s (15.718 KiB/s) ** Programming Finished ** ** Verify Started ** target halted due to breakpoint, current mode: Thread xPSR: 0x61000000 pc: 0x2000002e msp: 0x20080000 verified 4612 bytes in 0.716718s (6.284 KiB/s) ** Verified OK ** > shutdown shutdown command invoked Connection closed by foreign host. 按开发板上的 RESET 键后代码自动运行 以上3个步骤可以简写为一个步骤openocd -f /usr/share/openocd/scripts/interface/stlink-v2.cfg \\ -f /usr/share/openocd/scripts/target/stm32f7x.cfg \\ -c \"program build/led.bin 0x8000000 verify\" \\ -c \"shutdown\" openocd 烧写程序的命令格式 program [preverify] [verify] [reset] [exit] [offset] gdb 调试代码 由于 Ubuntu 20.04 不能通过apt install 的方式安装 gdb-arm-none-eabi , 具体安装方式可以参照这个链接 arm-none-eabi-gdb的使用方式可以参照这篇文章 安装 按照这个链接下载安装后。 $ arm-none-eabi-gdb ./build/led.elf arm-none-eabi-gdb: error while loading shared libraries: libncurses.so.5: cannot open shared object file: No such file or directory $ sudo apt install libncurses5 启动 openocd $ openocd -f /usr/share/openocd/scripts/interface/stlink-v2.cfg \\ -f /usr/share/openocd/scripts/target/stm32f7x.cfg 启动 arm-none-eabi-gdb $ arm-none-eabi-gdb ./build/led.elf GNU gdb (GNU Arm Embedded Toolchain 10-2020-q4-major) 10.1.90.20201028-git Copyright (C) 2020 Free Software Foundation, Inc. License GPLv3+: GNU GPL version 3 or later This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. Type \"show copying\" and \"show warranty\" for details. This GDB was configured as \"--host=x86_64-linux-gnu --target=arm-none-eabi\". Type \"show configuration\" for configuration details. For bug reporting instructions, please see: . Find the GDB manual and other documentation resources online at: . For help, type \"help\". Type \"apropos word\" to search for commands related to \"word\"... Reading symbols from ./build/led.elf... (gdb) target remote localhost:3333 # 链接openocd Remote debugging using localhost:3333 0x00000000 in ?? () (gdb) monitor reset # reset板子 (gdb) monitor halt # 挂起CPU target halted due to debug-request, current mode: Thread xPSR: 0x21000000 pc: 0x080005c6 msp: 0x2007fff8 (gdb) load # 加载程序文件 Loading section .isr_vector, size 0x1f8 lma 0x8000000 Loading section .text, size 0xed4 lma 0x80001f8 Loading section .rodata, size 0x10 lma 0x80010cc Loading section .ARM, size 0x8 lma 0x80010dc Loading section .init_array, size 0x4 lma 0x80010e4 Loading section .fini_array, size 0x4 lma 0x80010e8 Loading section .data, size 0xc lma 0x80010ec Start address 0x08001008, load size 4344 Transfer rate: 1 KB/sec, 620 bytes/write. (gdb) list # 查看代码 59 60 /** 61 * @brief The application entry point. 62 * @retval int 63 */ 64 int main(void) 65 { 66 /* USER CODE BEGIN 1 */ 67 68 /* USER CODE END 1 */ (gdb) b main # 设置断点 Breakpoint 1 at 0x80005ba: file Core/Src/main.c, line 73. Note: automatically using hardware breakpoints for read-only addresses. (gdb) info break # 查看断点 Num Type Disp Enb Address What 1 breakpoint keep y 0x080005ba in main at Core/Src/main.c:73 (gdb) s 65 movs r1, #0 (gdb) c Continuing. Breakpoint 1, main () at Core/Src/main.c:73 73 HAL_Init(); (gdb) p The history is empty. (gdb) bt #0 main () at Core/Src/main.c:73 (gdb) s HAL_Init () at Drivers/STM32F7xx_HAL_Driver/Src/stm32f7xx_hal.c:151 151 HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4); (gdb) list 146 #if (PREFETCH_ENABLE != 0U) 147 __HAL_FLASH_PREFETCH_BUFFER_ENABLE(); 148 #endif /* PREFETCH_ENABLE */ 149 150 /* Set Interrupt Group Priority */ 151 HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4); 152 153 /* Use systick as time base source and configure 1ms tick (default clock after Reset is HSI) */ 154 HAL_InitTick(TICK_INT_PRIORITY); 155 (gdb) f #0 HAL_Init () at Drivers/STM32F7xx_HAL_Driver/Src/stm32f7xx_hal.c:151 151 HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4); (gdb) list 146 #if (PREFETCH_ENABLE != 0U) 147 __HAL_FLASH_PREFETCH_BUFFER_ENABLE(); 148 #endif /* PREFETCH_ENABLE */ 149 150 /* Set Interrupt Group Priority */ 151 HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4); 152 153 /* Use systick as time base source and configure 1ms tick (default clock after Reset is HSI) */ 154 HAL_InitTick(TICK_INT_PRIORITY); 155 (gdb) quit A debugging session is active. Inferior 1 [Remote target] will be detached. Quit anyway? (y or n) y Detaching from program: /home/myye/stm32f767_led/led/build/led.elf, Remote target Ending remote debugging. [Inferior 1 (Remote target) detached] GDB 常用的命令 命令 作用/举例 list 列出附近代码 break main (b 16) 在符号main处设置断点（在第16行设置断点） break info 查看断点 delet break [n] 删除编号为n的断点，不加n的话删除所有断点 step 进入子函数单步运行 next 跳过子函数单步运行 until u 16 运行到16行停下 continue 运行代码到断点处停下 print print a 显示变量a的值 display display tmp 跟踪tmp，在每次停下时会自动显示变量的数值 bt 查看栈 quit 退出调试 以上命令还需要在实践中进一步熟悉。 Copyright © Yuanye.Ma 2020-2021 all right reserved，powered by Gitbook文件修订时间： 2023-04-02 10:05:52 "},"_posts/others/跟我一起写Makefile笔记.html":{"url":"_posts/others/跟我一起写Makefile笔记.html","title":"跟我一起写Makefile笔记","keywords":"","body":"makefile的自动化变量 $ 静态模式 : : ... 其中 targets: 定义了一系列的目标文件，可以有通配符，是目标的一个集合 target-parrtern 是指明了targets的模式，也就是目标集模式 prereq-parrterns 是目标的依赖模式，它对target-parrtern形成的模式再进行一次依赖目标的定义。 下面看一个例子 objs = foo.o bar.o all: $(objs) $(objs): %.o : %c $(CC) -c $(CFLAGS) & 例子中目标从$objs中获取， %.o是变量$objs的模式，及所有以.o结尾的目标。依赖模式是%.c，也就是所有.o文件替换为.c作为依赖的文件名。 书写命令 @:省略命令 exec: @echo \"xxx正在编译\" make exec时输出 \"xxx正在编译\" 而隐藏了命令echo -：忽略错误，标记不管命令出不出错都认为是成功的 clean : -rm -f *.o 使用变量 在makefile中变量是可以使用后边的变量来定义的。 foo = $(bar) bar = $(ugh) ugh = Huh? all: echo $(foo) #执行make输出Huh? 好处就是可以把变量的真实值推到后边定义； 缺点是一旦发生嵌套定义就会报错，或者导致不可预知的错误。 := 这种方法定义的变量，前面的变量不能使用后边的变量，只能使用前边已经定义的变量。 x := foo y := $(x) bar x := later 其等价于 y := foo bar x := later a := $(b) bar b := foo 则 a的值是 bar b的值是 foo ?= FOO ?= bar 其含义是如果FOO没有被定义过，那么变量FOO的值就是bar，如果FOO先前被定义过，那么这条语句什么都不干。 += 追加变量值 objects = main.o foo.o bar.o utils.o objects += another.o 则$(objects)的值是 main.o foo.o bar.o utils.o another.o 隐含规则 老式风格的“后缀规则” 双后缀: 双后缀规则定义了一对后缀：依赖目标(源文件)的后缀和目标文件的后缀。比如 .c.o相当于 %.o:%.c。 .c.o: $(CC) -c $(CFLAGS) $(CPPFLAGS) -o $@ $ 单后缀：但后缀规则只定义一个后缀。 后缀规则不允许任何的依赖文件，如果有依赖文件的话，那就不是后缀规则，那些后缀统统被认为是文件名。 Copyright © Yuanye.Ma 2020-2021 all right reserved，powered by Gitbook文件修订时间： 2023-04-02 10:05:52 "},"_posts/笔试题/2019-08-14-2019笔试题.html":{"url":"_posts/笔试题/2019-08-14-2019笔试题.html","title":"2019-08-14-2019笔试题","keywords":"","body":"2019贝壳找房四道笔试题 1. 计算绝对值 题目描述： 给出n个正整数，要求将找出相邻两个数字中差的绝对值最小的一对数字，如果有差的绝对值相同的，则输出最前面的一对数。 输入： 输入包含两行，第一行为n,第二行是用空格分隔的n个正整数。 输出： 输出包含一行两个正整数，要求按照原来的顺序输出。 样例输入： 9 1 3 4 7 2 6 5 12 32 样例输出： 3 4 code #include using namespace std; int main() { int n = 0; cin>>n; int nums[n]; for (int i=0; i>nums[i]; int min_dif = abs(nums[1]-nums[0]); int l = nums[0]; int r = nums[1]; for (int i=1; i 2. 举重大赛 题目描述： 举重大赛开始了，为了保证公平，要求比赛的双方体重较小值要大于等于较大值的90%，那么对于这N个人最多能进行多少场比赛呢？任意两人之间醉倒进行一场比赛。 输入： 第一行：一个整数N，表示参赛人数（2 第二行： N个正整数表示体重（0 输出： 一个数，表示最多能进行的比赛场数 样例输入： 5 1 1 1 1 1 样例输出： 10 code #include using namespace std; int main() { int n = 0; cin>>n; int nums[n]; for (int i=0; i>nums[i]; int cnt = 0; sort(nums, nums+n); for (int i=0; i= (double)(9.0/10)*nums[j]) cnt++; else break; //已经按照体重进行了排序，所以如果j不满足条件，那么后边的都不满足 } } cout 3. 特殊的测试 题目描述： 小C在做一种特殊的服务器负载测试，对于一个请求队列中的请求，每一个请求都有一个负荷值，为了保证服务器稳定，请求队列中的请求负荷必须按照先递增后递减的规律（仅递增，仅递减也可以），比如[1,2,8,4,3]和[1,3,5]都是满足要求的。还有一些不满足的，比如[1,2,2,1]和[2，1，2]。现在给你一个请求队列，你可以对请求的负荷值进行增加，要求调整完的序列满足要求。 输入： 第一行是N（1 第二行有N个整数Ai, Ai是第i个请求的负荷值。 输出： 输出这个最小增加总和。 样例输入： 5 1 4 3 2 5 样例输出： 6 样例说明： 1 5 3+2 2+4 5 一共增加了2+4=6。 code #include #include using namespace std; int main() { int n = 0; cin>>n; int nums[n]; for (int i=0; i>nums[i]; vector back(nums, nums+n); if (n0 && nums[j] nums[i+1]) nums[i+1] = nums[i]+1; i++; } else { if (nums[j] > nums[j-1]) nums[j-1] = nums[j]+1; j--; } } } int sum = 0; for (int i=0; i 4. 最长上升子序列 leetcode的第300道题目 题目描述： 给定一个无序的整数数组，找到其中最长上升子序列的长度。 输入: [10,9,2,5,3,7,101,18] 输出: 4 解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。 code #include #include using namespace std; int main() { int n = 0; cin>>n; int nums[n]; for (int i=0; i>nums[i]; int maxx = 0; int dp[n]; for (int i=0; i maxx) maxx = dp[i]; } cout 图森笔试题 1. 求卷积 code #include #include using namespace std; int A[505][505]; int B[3][3]; int main() { int n, m; cin>>n>>m; for (int i=0; i>A[i][j]; } } for (int i=0; i>B[i][j]; } } vector > C(n-2, vector(m-2)); for (int i=0; i 2. 迷宫求最短路径 code #include #include using namespace std; const int MAX_N = 1005; const int MAX_M = 1005; const int INF = 0x3f3f3f3f; typedef pair P; char maze[MAX_N][MAX_M + 1]; int N, M; int sx, sy; //起点的位置 int gx, gy; //终点的位置 int d[MAX_N][MAX_M];//储存起点到某一点的距离 int dx[4] = { 1,0,-1,0 }, dy[4] = { 0,1,0,-1 }; //表明每次x和y方向的位移 void bfs() { queue que; for (int i = 0; i >N>>M; for (int i = 0; i >maze[i][j]; if (maze[i][j] == 'S') { sx = i; sy = j; } if (maze[i][j] == 'E') { gx = i; gy = j; } } bfs(); cout 3. 我也不知道是什么题 code #include #include #include using namespace std; string toStr(int x) { string ans; while(x) { ans.push_back(x%10+'0'); x /= 10; } return string(ans.rbegin(), ans.rend()); } vector tok(int x, int k) { string tt = toStr(x); int len_t = tt.length(); vector str_t; int kk = k/len_t; if (kk%len_t || kk==0) kk+=1; for (int i=kk-1;i>=0; i--) { for (int j=i; j v_t = tok(t, k); vector s_t = tok(s, k); int l_v_t = v_t.size()-k; int l_v_s = s_t.size()-k; int i; for (i=0; i s_t[l_v_s+i]) { return \"Tu\"; } else if (v_t[l_v_t+i] >n; for (int i=0; i>t>>s>>k; cout 小米 1. 完全背包问题 n件商品，每件商品的价格固定，数量不限，固定的钱数，求最少拿走的商品数量。 2. 给定一个字符串表示的二叉树，输出中序遍历序列 输入样例：1(2(3,4(,5)),6(7,)) 输出样例：3245176 string solution(string) { string res; int len = input.length(); if (len == 0) return res; stack st; for (int i=0; i='0' && input[i]='0' && input[i-1] 华为 1. 计算数轴上关系匹配的点 #include #include #include using namespace std; int str2int(string str) { int res = 0; for (auto it=str.begin(); it!=str.end(); it++) { if (*it > '0' && *it A, vector B, int R) { string res; int len_a = A.size(); int len_b = B.size(); for (int i=0; i B[len_b-1]) break; bool flag = false; for (int j=0; j=A[i]) j--; res += \"(\" + int2str(A[i]) + \",\" + int2str(B[j+1]) +\")\"; } } return res; } vector str2vec(string str) { string tmp; vector vec; for (auto it=str.begin(); it!=str.end(); it++) { if (*it >= '0' && *it >s; int pos = s.find('R'); string R = s.substr(pos+2); int r = str2int(R); s = s.substr(0, pos-1); pos = s.find(\"B\"); string str_b = s.substr(pos+3); vector B = str2vec(str_b); s = s.substr(0, pos-1); string str_a = s.substr(3); vector A = str2vec(str_a); cout 2. 翻转字符串 #include #include #include using namespace std; #define VALID(it) ((*(it)>='0' && *(it)='a'&&*(it)='A'&& *(it) 另一种方法 1 #include 2 #include 3 4 static char buf[] = \"I am an 20 ye-ars out--standing @ * -stu- dent\"; 5 6 int is_valid(char ch) 7 { 8 if (((ch>='a') && (ch='A') && (ch= '0') && (ch 3. 修改机票信息 #include #include #include #include #include using namespace std; struct INFO{ string hbh; string zwh; string name; bool rewrite; INFO(string num_hb, string num_zw, string na) { this->hbh = num_hb; this->zwh = num_zw; this->name = na; this->rewrite = false; } }; bool cmp(const INFO & a, const INFO & b) { if (a.hbh == b.hbh) { return a.zwh>n; vector info; for (int i=0; i>hbh>>zwh>>name; INFO tmp(hbh, zwh, name); info.push_back(tmp); } cin>>m; for (int i=0; i>ohb>>ozw>>nhb>>nzw; for (int j=0; j 总结 华为的题，总体感觉不难，和刷LeetCode的感觉是不一样的，leetcode注重算法。而华为的题感觉更加注重用代码实现逻辑功能。输入处理起来异常麻烦。 第一题没有A掉，很明显代码中的条件处理的也不够，但是过了百分之八十，我同学他们没有考虑数字是两位或者多位的情况也过了百分之八十，不知道怎么回事。 第二题A掉了。 第三题，没时间写完，后来写的没有处理机票重复的情况。 vivo 1. 2. 报数 N个人站成一个圈，从1开始报数到M的整数倍时出去一个人，问出去的人的序列。 #include #include #include #include using namespace std; /** * Welcome to vivo ! */ typedef struct _node { int num; struct _node * next; }node; void solution(int N, int M) { // TODO Write your code here node * head = NULL; node * tail = NULL; for (int i=1; inum = i; p->next = NULL; if (head == NULL) { head = p; tail = p; } else { tail->next = p; tail = p; tail->next = head; } } node * q = head; int count = 1; while (q!=NULL && q!=q->next) { if (count % M == 0) { coutnumnext; q->num = qq->num; q->next = qq->next; delete qq; } else { q=q->next; } count++; } if (q!=NULL) coutnum 3. 天平问题 类似与这道题 Copyright © Yuanye.Ma 2020-2021 all right reserved，powered by Gitbook文件修订时间： 2023-04-02 10:05:52 "},"_posts/笔试题/2019-08-24-开发岗笔试基础题总结.html":{"url":"_posts/笔试题/2019-08-24-开发岗笔试基础题总结.html","title":"2019-08-24-开发岗笔试基础题总结","keywords":"","body":"const和指针 const int * a // a是一个指针，指向一个const int类型的内存， a本身可以修改指向别的变量，但是a所指向的内存中的数据不能修改。 int const * a // 和第一种相同 int * const a // const修饰的是a， a是一个int *型的变量。也就是说a本身不能修改，即指向确定的内存，但所指向的内存中的数据可以修改。 const int * const a // a以及a所指向的内存中的值都不能被修改。 主要看const后边修饰的是什么， 第一种const修饰的是int * a， 那就是*a不能被改变， 而a可以改变。 第二种const修饰的是* a, 同样*a不能改变，即指向的内存中的值不能改变。 第三种const修饰的是a，即a本身不能被修改，也就是说指向确定的内存空间，而*a内存中的值可以被改变。 结构体的内存对齐 #include #include using namespace std; struct a{ char a; int b; short c; double d; }; struct b{ char a; short b; int c; float d; }; int main() { cout 结构体的内存对齐有以下 结构体变量的起始地址能够被其最宽的成员大小整除 结构体每个成员相对于起始地址的偏移能够被其自身大小整除，如果不能则在前一个成员后面补充字节 结构体总体大小能够被最宽的成员的大小整除，如不能则在后面补充字节 拿struct a来说， 第一个成员是char类型的，占用一个字节，偏移地址为0。 第二个成员是int类型，本身占用4个字节，原本偏移为1，但是1不能被4整除，因此在a后边需要补充3个字节，这样b的起始地址偏移就变成了4，能够被自身大小整除，因此b的起始地址偏移为4。 第三个成员是short类型，本身占用2个字节，偏移为8，能够被本身大小整除。 第四个成员是double类型，本身占用8个字节，偏移为10，不能被本身大小整除，前一个c后边需要补充6个字节，也就是说double d的起始地址偏移为16。 最后，整个结构体占用24个字节，最宽的成员是double d占8个字节，24能被8整除，所以sizeof (struct a) = 24。 使用定义在 stddef.h 的宏offsetof(type, member) ，可以查看成员相对与结构体类型的偏移值 一道关于内存计算的题 #include #include using namespace std; int main() { int array[2019]={0}; array[19] = 2019; int offset = (unsigned long)((short *)array+2019) - (unsigned long)array + *(unsigned char *)(array+19); cout C++ 对象的存储方式 #include #include using namespace std; class A{ public: A(){} ~A(){} void p(const string & s) { coutp(\"hello world\\n\"); } 此程序能够正常编译运行输出hello world。 c++类方法存储在代码段，因此同一个类的所有方法公用代码段，p->p(\"hello world\\n\")；访问的是代码段，所以不会出现段错误或者core dump。 红黑树的性质 红黑树是每个节点都带有颜色属性的二叉查找树。在二叉查找树强制一般要求外，对于任何有效的红黑树增加额外的要求。 节点是红色或者黑色； 根是黑色的； 所有叶子节点都是黑色的（叶子是NIL节点）； 每个红色节点必须有两个黑色的子节点（或：从每个叶子节点到根的所有路径上不能有两个连续的红色节点）； 从任一节点到其每个叶子节点的所有简单路径都包含相同数目的黑色节点。 这些约束确保了红黑树的关键特性：从根到叶子的最长可能路径不多于最短的可能路径的两倍长。保证红黑树大致是平衡的。保证红黑树在最坏的请胯下也是高效的。 二叉查找树，也叫二叉搜索树、有序二叉树或者排序二叉树，是一颗空树或者具有以下性质的二叉树： 若任一节点的左子树不为空，则左子树上所有节点的值均小于它的根节点的值； 若任一节点的右子树不为空，则右子树上所有节点的值均大于它的根节点的值； 任意节点的左右子树也分别为二叉查找树； 没有键值相等的节点。 TCP三次握手和四次挥手 死锁 死锁：多个进程由于互相等待对方持有的资源而造成的谁都无法执行的情况叫死锁。 死锁产生的四个必要条件 互斥使用 不可抢占 请求和保持 循环等待 死锁处理方法 死锁预防：破坏死锁产生的条件； 一次性申请所有资源，不会占有资源还去申请其他资源 缺点1：需要预知未来，编程困难 缺点2：许多资源分配后很长时间后才使用，资源利用率低 对资源进行排序，资源申请必须按照顺序进行，不会出现环路等待 缺点：仍然造成资源浪费 死锁避免：检测每个资源请求，如果会造成死锁就拒绝分配相应资源； 银行家算法 请求出现时：首先假装分配，然后调用银行家算法，如果进程序列无法运行下去就拒绝。 时间复杂度为)， m为资源个数， n为进程的个数。 死锁检测+恢复：检测到死锁出现时，让一些进程回滚从而让出资源； 银行家算法每次申请都需要执行), 效率低：发现问题再处理 定时检测或者发现资源利用率低时检测。 选择哪些进程回滚？ 如何实现回滚？ 死锁忽略 (windows, linux采用的方式) 代价最小 PC重启影响小 死锁出现概率小 Linux I/O多路复用 聊聊IO多路复用之select、poll、epoll详解 epoll例程 Copyright © Yuanye.Ma 2020-2021 all right reserved，powered by Gitbook文件修订时间： 2023-04-02 10:05:52 "},"_posts/笔试题/2019-08-29-背包问题答题模板.html":{"url":"_posts/笔试题/2019-08-29-背包问题答题模板.html","title":"2019-08-29-背包问题答题模板","keywords":"","body":"背包问题答题模板 0-1背包 每件商品只能拿一件或者不拿。 // 假设 int m; // 背包容量 int n; // 商品数量 int v[n]; // 商品的价值列表 int w[n]; // 商品的重量（cost）列表 int dp[n][m]; 朴素二维数组方式 for （int i=1; i=v[i]) dp[i][j] = max(dp[i-1][j], dp[i-1][j-w[i]]+v[i]); dp[i][j] = dp[i-1][j]; } } return dp[m]; // dp数组的最后一个元素即为最优解。 滚动数组方式优化 for (int i=1; i=w[i]; j--) { dp[j] = max(dp[j], dp[j-w[i]]+v[i]); } } 一个AC的例程 #include using namespace std; int v[1005]; int w[1005]; int dp[1005]; int main() { int n,m; cin>>n>>m; for (int i=1; i>v[i]>>w[i]; for (int i=1; i=v[i]; j--) { dp[j] = max(dp[j], dp[j-v[i]]+w[i]); } } cout 关于dp数组的初始化 要求恰好装满背包时，初始时dp[0]=0，其他的dp[1...m]=负无穷。这样就可以保证最终得到的dp[m]是一种恰好装满背包的最优解。 如果没有恰好装满背包的要求而只是希望价格尽量大时，初始化时应该将dp[0...m]=0。 初始化时dp数组就是在没有任何物品放入背包时的合法状态。如果要求背包恰好装满，那么此时只有容量为0的背包可以在什么都不装且价值为0的情况下被\"恰好装满\"，其他容量的背包均没有合法的解，属于未定义的状态，应该被赋值为负无穷。 如果背包并非必须装满，那么任何容量的背包都有一个合法解”什么都不装“，这个解的价值为0，所以初始时状态的值也就全部为0. 完全背包 每件商品可以拿无数件。 滚动数组 for (int i=1; i=w[i]; j--) { for (int k=0; k*w[i] 优化 for (int i=1; i 一个AC的例程。 #include using namespace std; int dp[1005]; int main() { int n,m; cin>>n>>m; int v[1005]; int w[1005]; for (int i=1; i>v[i]>>w[i]; for (int i=1; i 多重背包 每件物品只能拿固定次。 朴素做法 for (int i=1; i=0; j--) { for (int k=1; k 一个AC的例程。 #include using namespace std; int dp[1005]; int main() { int n,m; cin>>n>>m; int v[1005]; int w[1005]; int c[1005]; for (int i=1; i>v[i]>>w[i]>>c[i]; } for (int i=1; i=v[i]; j--) { for (int k=1; k 二进制优化 另一种优化 这两种优化方式暂时没弄懂 混合背包 二维费用的背包问题 int n; // 商品数目 int v; // 约束1 int m; // 约束2 int c_v[n]; // 约束1的cost int c_m[n]; // 约束2的cost for (int i=1; i=c_v[i]; j--) { for (int k=m; k>=c_m[i]; k--) { f[j][k] = max(f[j][k], f[j-c_v[i]][l-v_m[i]]+c); } } } 下边是一道题的AC代码 #include using namespace std; int v_v[1005]; int v_m[1005]; int w[1005]; int dp[1005][1005]; int main() { int n, v, m; cin>>n>>v>>m; for (int i=1; i>v_v[i]>>v_m[i]>>w[i]; } for (int i=1; i=v_v[i]; j--) { for (int k=m; k>=v_m[i]; k--) { dp[j][k] = max(dp[j][k], dp[j-v_v[i]][k-v_m[i]]+w[i]); } } } cout Copyright © Yuanye.Ma 2020-2021 all right reserved，powered by Gitbook文件修订时间： 2023-04-02 10:05:52 "},"draft/30天自制操作系统实验记录.html":{"url":"draft/30天自制操作系统实验记录.html","title":"30天自制操作系统实验记录","keywords":"","body":"qemu安装以及简单使用 $ sudo apt update $ sudo apt install qemu # 创建磁盘 qemu-img create ubuntu.img 10G # 安装系统到磁盘 qemu -hda ubuntu.img -boot d -cdrom ubuntu.iso -m 512 # -boot [a|d|c]选项让qemu从a:磁盘，d:光盘 c:硬盘启动 # 'drives': floppy (a), hard disk (c), CD-ROM (d), network (n) # 安装完成后启动虚拟机 qemu ubuntu.img -m 512 30天自制操作系统 day 1-3 hello world $ vim ipl.s 写入 ; helloOS ; 显示hello world的程序 ORG 0X7C00 ; 以下的记述用于标准FAT12格式的软盘 start: JMP entry DB \"HELLOIPL\" ; 启动区名称(8字节) DW 512 ; 扇区大小(512字节) DB 1 ; 簇大小(1扇区) DW 1 ; FAT起始位置 DB 2 ; FAT个数 DW 224 ; 根目录大小(224项) DW 2880 ; 磁盘大小(2880扇区) DB 0xf0 ; 磁盘种类 DW 9 ; FAT长度 DW 18 ; 每个磁道扇区数 DW 2 ; 磁头数 DD 0 ; 不使用分区 DD 2880 ; 重写一次磁盘大小 DB 0,0,0x29 ; 意义不明 DD 0xffffffff ; 可能是卷标号码 DB \"HELLO-OS \" ; 磁盘名称(11字节) DB \"FAT12 \" ; 格式名称(8字节) RESB 18 ; 空出18字节 entry: MOV AX, 0 MOV SS, AX MOV SP, 0x7c00 MOV DS, AX MOV ES, AX MOV SI, msg putloop: MOV AL, [SI] ADD SI, 1 CMP AL, 0 JE fin ; if (AL == 0) { goto fin } MOV AH, 0x0e ;显示一个文字 MOV BX, 15 ;指定字符颜色 INT 0x10 ;调用显卡BIOS JMP putloop fin: HLT JMP fin msg: DB 0x0a, 0x0a DB \"hello world\" DB 0x0a DB 0 tail: RESB 0x1fe-(tail-start) DB 0x55, 0xaa 使用nasm编译 $ nasm -f bin ipl.s -o ipl.bin -f format Specifies the output file format. To see a list of valid output formats, use the -hf option. $ file ipl.bin ipl.bin: DOS/MBR boot sector $ qemu-img info ipl.bin image: hello.bin file format: raw virtual size: 512 B (512 bytes) disk size: 4 KiB 启动虚拟机 $ qemu-system-i386 -hda ipl.bin -boot a 磁盘操作 AH=0x02 ; 读盘 AH=0x03 ; 写盘 AH=0x04 ; 校验 AH=0x0c ; 寻道 AL=处理对象的扇区数目 CH=柱面号 & 0xff CL=扇区号（0-5位）| （柱面号&0x300）>>2 DH=磁头号 DL=驱动器号 ES:BX=缓冲地址 返回值： FLAGS.CF==0 ;没有错误 AH=0 FLAGS.CF==1 ;有错误 AH内存储错误码 第一个扇区为启动分区系统启动后自动加载，其他扇区需要第一个分区中的代码加载到内存中的指定位置。 C0-H0-S1(柱面0-磁头0-扇区1) ---> C0-H0-S2 ---> ... --->C0-H0-S18 ---> C0-H1-S1 ---> ... ---> C1-H0-S1 $ vim ipl.S 写入以下内容，第一个扇区为启动扇区，以0x55aa结尾，该扇区要读取后续扇区的内容到内存中。 ;ipl ORG 0x07c00 ;设置程序加载地址 entry: ;设置堆栈 MOV AX, 0 MOV SS, AX MOV SP, 0x7c00 ;设置数据段 MOV DS, AX ;显示提示信息 welcome: MOV SI, msg_start startloop: MOV AL, [SI] ADD SI, 1 CMP AL, 0 JE read MOV AH, 0x0e ;设置显示模式 MOV BX, 0x0b ;设置字体颜色为白色 INT 0x10 ;调用BIOS显示字符 JMP startloop ;读磁盘 read: CYLS EQU 10 ;计划读取10个柱面 MOV AX, 0x0c20 MOV ES, AX MOV CH, 0 ;柱面0 MOV DH, 0 ;磁头0 MOV CL, 2 ;扇区2 readloop: MOV SI, 0 ;记录失败次数 retry: MOV AH, 0x02 ;读取磁盘 MOV AL, 1 ;1个扇区 MOV BX, 0 ;ES:BX缓冲地址 MOV DL, 0X00 ;A驱动器 INT 0x13 ;启动BIOS读取磁盘 JNC next ;FLAGS.CF==0 没有错误 ADD SI, 1 CMP SI, 5 JAE error ; SI>5 错误满5次 MOV AH, 0X00 MOV DL, 0X00 INT 0x13 ;重置驱动器 JMP retry next: MOV AX, ES ;将缓冲区地址往后挪一个扇区 ADD AX, 0x0020 MOV ES, AX ADD CL, 1 ;读取下一个扇区 CMP CL, 18 JBE readloop ;if (CL 准备后续代码 $ vim asmhead.s 写入以下内容，主要显示加载成功 ;Bootsect第二阶段 ORG 0xC200 showdemo: ;MOV AX, 0x0 ;MOV SS, AX ;MOV SP, 0xC200 ;MOV DS, AX ;MOV ES, AX MOV SI, msg putloop: MOV AL, [SI] ADD SI, 1 CMP AL, 0 JE fin MOV AH, 0x0e MOV BX, 0x0a INT 0x10 JMP putloop fin: HLT JMP fin msg: DB 0x0a, 0x0a DB \"load successful\" DB 0x0a DB 0 准备Makefile all: Image qemu-system-i386 -fda Image -boot a bootsect.bin: ipl.s nasm -f bin ipl.s -o bootsect.bin asmhead.bin: asmhead.s nasm -f bin asmhead.s -o asmhead.bin Image: bootsect.bin asmhead.bin dd if=bootsect.bin of=Image bs=512 count=1 dd if=asmhead.bin of=Image bs=512 count=1 seek=1 clean: rm -rf *.bin Image 进入32位模式 导入C语言 Copyright © Yuanye.Ma 2020-2021 all right reserved，powered by Gitbook文件修订时间： 2023-04-02 10:05:52 "},"draft/关于系统调用.html":{"url":"draft/关于系统调用.html","title":"关于系统调用","keywords":"","body":"关于系统调用 [toc] x86架构 /*arch/x86/kernel/entry_32.S || arch/x86/kernel/entry_64.S */ .section .rodata,\"a\" #include \"syscall_table_32.S\" syscall_table_size=(.-sys_call_table) /*arch/x86/kernel/syscall_table_32.S*/ ENTRY(sys_call_table) .long sys_restart_syscall /* 0 - old \"setup()\" system call, used for restarting */ .long sys_exit .long ptregs_fork .long sys_read .long sys_write .long sys_open /* 5 */ .long sys_close /*省略*/ 系统调用号的定义 /*arch/x86/include/asm/unistd.h\"*/ #ifdef __KERNEL__ # ifdef CONFIG_X86_32 # include \"unistd_32.h\" # else # include \"unistd_64.h\" # endif #else # ifdef __i386__ # include \"unistd_32.h\" # else # include \"unistd_64.h\" # endif #endif /*根据CPU是32位还是64位包含不同的头文件*/ /*arch/x86/include/asm/unistd_32.h\"*/ #ifndef _ASM_X86_UNISTD_32_H #define _ASM_X86_UNISTD_32_H /* * This file contains the system call numbers. */ #define __NR_restart_syscall 0 #define __NR_exit 1 #define __NR_fork 2 #define __NR_read 3 #define __NR_write 4 #define __NR_open 5 #define __NR_close 6 /*省略*/ /*arch/x86/include/asm/unistd_64.h*/ #ifndef _ASM_X86_UNISTD_64_H #define _ASM_X86_UNISTD_64_H #ifndef __SYSCALL #define __SYSCALL(a, b) #endif /* * This file contains the system call numbers. * * Note: holes are not allowed. */ /* at least 8 syscall per cacheline */ #define __NR_read 0 __SYSCALL(__NR_read, sys_read) #define __NR_write 1 __SYSCALL(__NR_write, sys_write) #define __NR_open 2 __SYSCALL(__NR_open, sys_open) #define __NR_close 3 __SYSCALL(__NR_close, sys_close) #define __NR_stat 4 __SYSCALL(__NR_stat, sys_newstat) #define __NR_fstat 5 __SYSCALL(__NR_fstat, sys_newfstat) #define __NR_lstat 6 __SYSCALL(__NR_lstat, sys_newlstat) #define __NR_poll 7 __SYSCALL(__NR_poll, sys_poll) /*省略*/ ARM架构 /*./arch/arm/kernel/entry-common.S*/ #define CALL(x) .equ NR_syscalls,NR_syscalls+1 #include \"calls.S\" #undef CALL #define CALL(x) .long x /*arch/arm/kernel/calls.S*/ /* * linux/arch/arm/kernel/calls.S * * Copyright (C) 1995-2005 Russell King * * This program is free software; you can redistribute it and/or modify * it under the terms of the GNU General Public License version 2 as * published by the Free Software Foundation. * * This file is included thrice in entry-common.S */ /* 0 */ CALL(sys_restart_syscall) CALL(sys_exit) CALL(sys_fork_wrapper) CALL(sys_read) CALL(sys_write) /* 5 */ CALL(sys_open) CALL(sys_close) CALL(sys_ni_syscall) /* was sys_waitpid */ /*略*/ 系统调用号定义 /*arch/arm/include/asm/unistd.h*/ #ifndef __ASM_ARM_UNISTD_H #define __ASM_ARM_UNISTD_H #define __NR_OABI_SYSCALL_BASE 0x900000 #if defined(__thumb__) || defined(__ARM_EABI__) #define __NR_SYSCALL_BASE 0 #else #define __NR_SYSCALL_BASE __NR_OABI_SYSCALL_BASE #endif /* * This file contains the system call numbers. */ #define __NR_restart_syscall (__NR_SYSCALL_BASE+ 0) #define __NR_exit (__NR_SYSCALL_BASE+ 1) #define __NR_fork (__NR_SYSCALL_BASE+ 2) #define __NR_read (__NR_SYSCALL_BASE+ 3) #define __NR_write (__NR_SYSCALL_BASE+ 4) #define __NR_open (__NR_SYSCALL_BASE+ 5) #define __NR_close (__NR_SYSCALL_BASE+ 6) /* 7 was sys_waitpid */ #define __NR_creat (__NR_SYSCALL_BASE+ 8) #define __NR_link (__NR_SYSCALL_BASE+ 9) 尝试跟踪一下0号系统调用restart_syscall 在目录树中搜索restart_syscall看到如下结果 ​ include/linux/syscalls.h:293:asmlinkage long sys_restart_syscall(void); //函数声明 ​ kernel/signal.c:2009:SYSCALL_DEFINE0(restart_syscall) //函数实现 /*include/linux/syscalls.h*/ asmlinkage long sys_restart_syscall(void); /*kernel/signal.c*/ /* * System call entry points. */ SYSCALL_DEFINE0(restart_syscall) { struct restart_block *restart = &current_thread_info()->restart_block; return restart->fn(restart); } 宏SYSCALL_DEFINE0的实现 /*include/linux/syscalls.h*/ #define SYSCALL_DEFINE0(name) asmlinkage long sys_##name(void) #define SYSCALL_DEFINE1(name, ...) SYSCALL_DEFINEx(1, _##name, __VA_ARGS__) #define SYSCALL_DEFINE2(name, ...) SYSCALL_DEFINEx(2, _##name, __VA_ARGS__) #define SYSCALL_DEFINE3(name, ...) SYSCALL_DEFINEx(3, _##name, __VA_ARGS__) #define SYSCALL_DEFINE4(name, ...) SYSCALL_DEFINEx(4, _##name, __VA_ARGS__) #define SYSCALL_DEFINE5(name, ...) SYSCALL_DEFINEx(5, _##name, __VA_ARGS__) #define SYSCALL_DEFINE6(name, ...) SYSCALL_DEFINEx(6, _##name, __VA_ARGS__) #define SYSCALL_DEFINEx(x, sname, ...) \\ __SYSCALL_DEFINEx(x, sname, __VA_ARGS__) #define __SYSCALL_DEFINEx(x, name, ...) \\ asmlinkage long sys##name(__SC_DECL##x(__VA_ARGS__)) 关于 asmlinkage system call handler : 系统调用处理程序，是assembly code； system call routine ：系统调用例程，是C code。 system call handler调用system call routine时（发生中断，需要保护现场），便将一般用途的寄存器的值Push到stack中，因此system call routine就要从stack中读取system call handler传递的参数。 assembly调用C，并且是以stack方式传递参数时，在C function的prototype(原型)前要加上asmlinkage。 加上asmlinkage后，C function就会去stack取参数，而不是从register取参数。 #ifdef CONFIG_X86_32 #define asmlinkage CPP_ASMLINKAGE __attribute__((regparm(0))) /* * For 32-bit UML - mark functions implemented in assembly that use * regparm input parameters: */ #define asmregparm __attribute__((regparm(3))) /* * Make sure the compiler doesn't do anything stupid with the * arguments on the stack - they are owned by the *caller*, not * the callee. This just fools gcc into not spilling into them, * and keeps it from doing tailcall recursion and/or using the * stack slots for temporaries, since they are live and \"used\" * all the way to the end of the function. * * NOTE! On x86-64, all the arguments are in registers, so this * only matters on a 32-bit kernel. */ 参考 GNU说明 以下内容参考 进程的系统调用命令转换为int 0x80中断的过程 系统调用模块的初始化 对系统调用的初始化就是对int 0x80中断的初始化。 系统启动时，汇编子程序setup_idt（arch/i386/kernel/head.S）准备了一张256项的idt表，由start_kernel()(init/main.c), trap_init()(arch/i386/kernel/trap.c)调用C语言宏定义set_system_gate(0x80, &system_call)(include/asm/system.h)设置0x80软中断的服务程序为system_call（arch/i386/kernel/entry.S）, system_call就是所有系统调用的入口。 内核如何为各种系统调用服务 当进程需要进行系统调用时，必须以C语言函数形式写一句系统调用命令。该命令如果已在某个头文件中由相应的_syscallN()展开，则用户程序必须包含该文件。当进程执行到用户程序的系统调用命令时，实际上执行了由宏命令_syscallN()展开的函数。系统调用的参数由各通用寄存器传递，然后执行int 0x80， 以内核态进入入口地址system_call 在基于ARM的Linux中，异常向量表已经被放置在了0xFFFF0000这个位置。这个过程的完成： start_kernel ---> setup_arch ---> early_trap_init 浅析基于ARM的Linux下的系统调用的实现 linux-2.6.26内核中ARM中断实现详解(转） 内核如何为系统调用传递参数 参数传递 除了系统调用号以外，大部分系统调用都还需要一些外部的参数输人。所以，在发生异常的时候，应该把这些参数从用户空间传给内核。最简单的办法就是像传递系统调用号一样把这些参数也存放在寄存器里。在x86系统上，ebx, ecx, edx, esi和edi按照顺序存放前五个参数。需要六个或六个以上参数的情况不多见，此时，应该用一个单独的寄存器存放指向所有这些参数在用户空间地址的指针。 给用户空间的返回值也通过寄存器传递。在x86系统上，它存放在eax寄存器中。 参数验证 系统调用的返回值 如何访问系统调用 系统调用上下文 系统调用访问示例 添加系统调用 Copyright © Yuanye.Ma 2020-2021 all right reserved，powered by Gitbook文件修订时间： 2023-04-02 10:05:52 "}}